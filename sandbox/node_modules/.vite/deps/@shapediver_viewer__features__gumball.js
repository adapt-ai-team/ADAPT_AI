import {
  require_dist,
  require_dist2,
  require_three
} from "./chunk-JYJXU3BZ.js";
import {
  __commonJS,
  __toCommonJS,
  esm_exports,
  init_esm
} from "./chunk-EGMV4VNK.js";

// node_modules/@shapediver/viewer.features.gumball/dist/three/TransformControls.js
var require_TransformControls = __commonJS({
  "node_modules/@shapediver/viewer.features.gumball/dist/three/TransformControls.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransformControlsPlane = exports.TransformControlsGizmo = exports.TransformControls = void 0;
    var three_1 = require_three();
    var _raycaster = new three_1.Raycaster();
    var _tempVector = new three_1.Vector3();
    var _tempVector2 = new three_1.Vector3();
    var _tempQuaternion = new three_1.Quaternion();
    var _unit = {
      X: new three_1.Vector3(1, 0, 0),
      Y: new three_1.Vector3(0, 1, 0),
      Z: new three_1.Vector3(0, 0, 1)
    };
    var TransformationType;
    (function(TransformationType2) {
      TransformationType2["TRANSLATION"] = "translation";
      TransformationType2["ROTATION"] = "rotation";
      TransformationType2["SCALE"] = "scale";
    })(TransformationType || (TransformationType = {}));
    var TransformControls = class extends three_1.Object3D {
      // #endregion Properties (59)
      // #region Constructors (1)
      constructor(camera, domElement, updateCallback, updateMatricesCallback) {
        super();
        this._axis = null;
        this._cameraPosition = new three_1.Vector3();
        this._cameraQuaternion = new three_1.Quaternion();
        this._dragging = false;
        this._enableRotation = true;
        this._enableRotationX = true;
        this._enableRotationY = true;
        this._enableRotationZ = true;
        this._enableScaling = true;
        this._enableScalingX = true;
        this._enableScalingY = true;
        this._enableScalingZ = true;
        this._enableTranslation = true;
        this._enableTranslationX = true;
        this._enableTranslationY = true;
        this._enableTranslationZ = true;
        this._enabled = true;
        this._eye = new three_1.Vector3();
        this._hovering = false;
        this._object = void 0;
        this._parentQuaternionInv = new three_1.Quaternion();
        this._pivotDragged = false;
        this._pointEnd = new three_1.Vector3();
        this._pointStart = new three_1.Vector3();
        this._rotationAngle = 0;
        this._rotationAxis = new three_1.Vector3();
        this._rotationSnap = null;
        this._scaleSnap = null;
        this._showX = true;
        this._showY = true;
        this._showZ = true;
        this._size = 1;
        this._space = "local";
        this._translationSnap = null;
        this._worldPosition = new three_1.Vector3();
        this._worldPositionStart = new three_1.Vector3();
        this._worldQuaternion = new three_1.Quaternion();
        this._worldQuaternionStart = new three_1.Quaternion();
        this.userData.ambientOcclusion = false;
        this._camera = camera;
        this._updateCallback = updateCallback;
        this._updateMatricesCallback = updateMatricesCallback;
        if (domElement === void 0) {
          console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
          domElement = document;
        }
        this.isTransformControls = true;
        this.visible = false;
        this.domElement = domElement;
        this.domElement.style.touchAction = "none";
        const _gizmo = new TransformControlsGizmo(this);
        this._gizmo = _gizmo;
        this.add(_gizmo);
        const _plane = new TransformControlsPlane(this);
        this._plane = _plane;
        this.add(_plane);
        this._offset = new three_1.Vector3();
        this._startNorm = new three_1.Vector3();
        this._endNorm = new three_1.Vector3();
        this._cameraScale = new three_1.Vector3();
        this._parentPosition = new three_1.Vector3();
        this._parentQuaternion = new three_1.Quaternion();
        this._parentQuaternion = new three_1.Quaternion();
        this._parentScale = new three_1.Vector3();
        this._worldScaleStart = new three_1.Vector3();
        this._worldQuaternionInv = new three_1.Quaternion();
        this._worldScale = new three_1.Vector3();
        this._positionStart = new three_1.Vector3();
        this._quaternionStart = new three_1.Quaternion();
        this._scaleStart = new three_1.Vector3();
      }
      // #endregion Constructors (1)
      // #region Public Getters And Setters (66)
      get axis() {
        return this._axis;
      }
      set axis(value) {
        this._axis = value;
      }
      get camera() {
        return this._camera;
      }
      get cameraPosition() {
        return this._cameraPosition;
      }
      get cameraQuaternion() {
        return this._cameraQuaternion;
      }
      get dragging() {
        return this._dragging;
      }
      set dragging(value) {
        this._dragging = value;
        this.dispatchEvent({ type: "dragging-changed", value });
      }
      get enableRotation() {
        return this._enableRotation;
      }
      set enableRotation(value) {
        this._enableRotation = value;
      }
      get enableRotationX() {
        return this._enableRotationX;
      }
      set enableRotationX(value) {
        this._enableRotationX = value;
      }
      get enableRotationY() {
        return this._enableRotationY;
      }
      set enableRotationY(value) {
        this._enableRotationY = value;
      }
      get enableRotationZ() {
        return this._enableRotationZ;
      }
      set enableRotationZ(value) {
        this._enableRotationZ = value;
      }
      get enableScaling() {
        return this._enableScaling;
      }
      set enableScaling(value) {
        this._enableScaling = value;
      }
      get enableScalingX() {
        return this._enableScalingX;
      }
      set enableScalingX(value) {
        this._enableScalingX = value;
      }
      get enableScalingY() {
        return this._enableScalingY;
      }
      set enableScalingY(value) {
        this._enableScalingY = value;
      }
      get enableScalingZ() {
        return this._enableScalingZ;
      }
      set enableScalingZ(value) {
        this._enableScalingZ = value;
      }
      get enableTranslation() {
        return this._enableTranslation;
      }
      set enableTranslation(value) {
        this._enableTranslation = value;
      }
      get enableTranslationX() {
        return this._enableTranslationX;
      }
      set enableTranslationX(value) {
        this._enableTranslationX = value;
      }
      get enableTranslationY() {
        return this._enableTranslationY;
      }
      set enableTranslationY(value) {
        this._enableTranslationY = value;
      }
      get enableTranslationZ() {
        return this._enableTranslationZ;
      }
      set enableTranslationZ(value) {
        this._enableTranslationZ = value;
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        this._enabled = value;
      }
      get eye() {
        return this._eye;
      }
      get hovering() {
        return this._hovering;
      }
      get mode() {
        return this._mode;
      }
      set mode(value) {
        this._mode = value;
      }
      get object() {
        return this._object;
      }
      set object(value) {
        this._object = value;
      }
      get pivotDragged() {
        return this._pivotDragged;
      }
      set pivotDragged(value) {
        this._pivotDragged = value;
      }
      get pointEnd() {
        return this._pointEnd;
      }
      get pointStart() {
        return this._pointStart;
      }
      get rotationAngle() {
        return this._rotationAngle;
      }
      set rotationAngle(value) {
        this._rotationAngle = value;
      }
      get rotationAxis() {
        return this._rotationAxis;
      }
      get rotationSnap() {
        return this._rotationSnap;
      }
      set rotationSnap(value) {
        this._rotationSnap = value;
      }
      get scaleSnap() {
        return this._scaleSnap;
      }
      set scaleSnap(value) {
        this._scaleSnap = value;
      }
      get showX() {
        return this._showX;
      }
      set showX(value) {
        this._showX = value;
      }
      get showY() {
        return this._showY;
      }
      set showY(value) {
        this._showY = value;
      }
      get showZ() {
        return this._showZ;
      }
      set showZ(value) {
        this._showZ = value;
      }
      get size() {
        return this._size;
      }
      set size(value) {
        this._size = value;
      }
      get space() {
        return this._space;
      }
      set space(value) {
        this._space = value;
      }
      get translationSnap() {
        return this._translationSnap;
      }
      set translationSnap(value) {
        this._translationSnap = value;
      }
      get worldPosition() {
        return this._worldPosition;
      }
      get worldPositionStart() {
        return this._worldPositionStart;
      }
      get worldQuaternion() {
        return this._worldQuaternion;
      }
      get worldQuaternionStart() {
        return this._worldQuaternionStart;
      }
      // #endregion Public Getters And Setters (66)
      // #region Public Methods (21)
      // Set current object
      attach(object) {
        this.object = object;
        this.visible = true;
        return this;
      }
      // Detach from object
      detach() {
        this.object = void 0;
        this.visible = false;
        this.axis = null;
        return this;
      }
      dispose() {
        this.traverse(function(child) {
          if (child.geometry)
            child.geometry.dispose();
          if (child.material)
            child.material.dispose();
        });
      }
      getPointer(event) {
        if (this.domElement.ownerDocument.pointerLockElement) {
          return {
            x: 0,
            y: 0,
            button: event.button
          };
        } else {
          const rect = this.domElement.getBoundingClientRect();
          return {
            x: (event.clientX - rect.left) / rect.width * 2 - 1,
            y: -(event.clientY - rect.top) / rect.height * 2 + 1,
            button: event.button
          };
        }
      }
      getRaycaster() {
        return _raycaster;
      }
      intersectObjectWithRay(object, raycaster, includeInvisible) {
        const allIntersections = raycaster.intersectObject(object, true);
        for (let i = 0; i < allIntersections.length; i++) {
          if (allIntersections[i].object.visible || includeInvisible) {
            return allIntersections[i];
          }
        }
        return false;
      }
      onPointerDown(event) {
        if (!this.enabled)
          return;
        if (!document.pointerLockElement) {
          this.domElement.setPointerCapture(event.pointerId);
        }
        this.pointerHover(this.getPointer(event));
        this.pointerDown(this.getPointer(event));
      }
      onPointerHover(event) {
        if (!this.enabled)
          return;
        switch (event.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(event));
            break;
        }
      }
      onPointerMove(event) {
        if (!this.enabled)
          return;
        this.pointerMove(this.getPointer(event));
      }
      onPointerUp(event) {
        if (!this.enabled)
          return;
        this.domElement.releasePointerCapture(event.pointerId);
        this.pointerUp(this.getPointer(event));
      }
      pointerDown(pointer) {
        var _a, _b;
        if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0)
          return;
        if (this.axis !== null) {
          if (pointer !== null)
            _raycaster.setFromCamera(pointer, this.camera);
          const planeIntersect = this.intersectObjectWithRay(this._plane, _raycaster, true);
          if (planeIntersect) {
            this.object.updateMatrixWorld();
            (_b = (_a = this.object) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.updateMatrixWorld();
            this._positionStart.copy(this.object.position);
            this._quaternionStart.copy(this.object.quaternion);
            this._scaleStart.copy(this.object.scale);
            this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
            this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
          }
          this.dragging = true;
        }
      }
      pointerHover(pointer) {
        if (this.object === void 0 || this.dragging === true)
          return;
        if (pointer !== null)
          _raycaster.setFromCamera(pointer, this.camera);
        const intersections = [];
        if (this.enableTranslation) {
          const intersection = this.intersectObjectWithRay(this._gizmo.picker.translate, _raycaster, true);
          if (intersection) {
            intersections.push({
              mode: TransformationType.TRANSLATION,
              intersection
            });
          }
        }
        if (this.enableRotation) {
          const intersection = this.intersectObjectWithRay(this._gizmo.picker.rotate, _raycaster, true);
          if (intersection) {
            intersections.push({
              mode: TransformationType.ROTATION,
              intersection
            });
          }
        }
        if (this.enableScaling && this.space === "local") {
          const intersection = this.intersectObjectWithRay(this._gizmo.picker.scale, _raycaster, true);
          if (intersection) {
            intersections.push({
              mode: TransformationType.SCALE,
              intersection
            });
          }
        }
        intersections.sort((a, b) => a.intersection.distance - b.intersection.distance);
        if (intersections.length > 0) {
          this.axis = intersections[0].intersection.object.name;
          this.mode = intersections[0].mode;
        } else {
          this.axis = null;
          this.mode = void 0;
        }
        this._hovering = intersections.length > 0;
      }
      pointerMove(pointer) {
        const axis = this.axis;
        const object = this.object;
        let space = this.space;
        if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
          space = "world";
        }
        if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1)
          return;
        if (pointer !== null)
          _raycaster.setFromCamera(pointer, this.camera);
        const planeIntersect = this.intersectObjectWithRay(this._plane, _raycaster, true);
        if (!planeIntersect)
          return;
        this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
        if (this.mode === TransformationType.TRANSLATION) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);
          if (space === "local" && axis !== "XYZ") {
            this._offset.applyQuaternion(this._worldQuaternionInv);
          }
          if (axis.indexOf("X") === -1)
            this._offset.x = 0;
          if (axis.indexOf("Y") === -1)
            this._offset.y = 0;
          if (axis.indexOf("Z") === -1)
            this._offset.z = 0;
          if (space === "local" && axis !== "XYZ") {
            this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
          } else {
            this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
          }
          object.position.copy(this._offset).add(this._positionStart);
          if (this.translationSnap) {
            if (space === "local") {
              object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
              if (axis.search("X") !== -1) {
                object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
              }
              if (axis.search("Y") !== -1) {
                object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
              }
              if (axis.search("Z") !== -1) {
                object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
              }
              object.position.applyQuaternion(this._quaternionStart);
            }
            if (space === "world") {
              if (object.parent) {
                object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
              }
              if (axis.search("X") !== -1) {
                object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
              }
              if (axis.search("Y") !== -1) {
                object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
              }
              if (axis.search("Z") !== -1) {
                object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
              }
              if (object.parent) {
                object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
              }
            }
          }
        }
        if (this.mode === TransformationType.SCALE && space === "local") {
          if (axis.search("XYZ") !== -1) {
            let d = this.pointEnd.length() / this.pointStart.length();
            if (this.pointEnd.dot(this.pointStart) < 0)
              d *= -1;
            _tempVector2.set(d, d, d);
          } else {
            _tempVector.copy(this.pointStart);
            _tempVector2.copy(this.pointEnd);
            _tempVector.applyQuaternion(this._worldQuaternionInv);
            _tempVector2.applyQuaternion(this._worldQuaternionInv);
            _tempVector2.divide(_tempVector);
            if (axis.search("X") === -1) {
              _tempVector2.x = 1;
            }
            if (axis.search("Y") === -1) {
              _tempVector2.y = 1;
            }
            if (axis.search("Z") === -1) {
              _tempVector2.z = 1;
            }
          }
          object.scale.copy(this._scaleStart).multiply(_tempVector2);
          if (this.scaleSnap) {
            if (axis.search("X") !== -1) {
              object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
            }
            if (axis.search("Y") !== -1) {
              object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
            }
            if (axis.search("Z") !== -1) {
              object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
            }
          }
        }
        if (this.mode === TransformationType.ROTATION) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);
          const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          let _inPlaneRotation = false;
          if (axis === "XYZE") {
            this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
            this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
          } else if (axis === "X" || axis === "Y" || axis === "Z") {
            this.rotationAxis.copy(_unit[axis]);
            _tempVector.copy(_unit[axis]);
            if (space === "local") {
              _tempVector.applyQuaternion(this.worldQuaternion);
            }
            _tempVector.cross(this.eye);
            if (_tempVector.length() === 0) {
              _inPlaneRotation = true;
            } else {
              this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
            }
          }
          if (axis === "E" || _inPlaneRotation) {
            this.rotationAxis.copy(this.eye);
            this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
            this._startNorm.copy(this.pointStart).normalize();
            this._endNorm.copy(this.pointEnd).normalize();
            this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
          }
          if (this.rotationSnap)
            this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
          if (space === "local" && axis !== "E" && axis !== "XYZE") {
            object.quaternion.copy(this._quaternionStart);
            object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
          } else {
            this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
            object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
            object.quaternion.multiply(this._quaternionStart).normalize();
          }
        }
        if (this._updateCallback)
          this._updateCallback();
      }
      pointerUp(pointer) {
        if (pointer !== null && pointer.button !== 0)
          return;
        if (this.dragging && this.axis !== null) {
          if (this._updateMatricesCallback)
            this._updateMatricesCallback();
        }
        this.dragging = false;
        this.axis = null;
      }
      reset() {
        var _a, _b, _c;
        if (!this.enabled)
          return;
        if (this.dragging) {
          (_a = this.object) === null || _a === void 0 ? void 0 : _a.position.copy(this._positionStart);
          (_b = this.object) === null || _b === void 0 ? void 0 : _b.quaternion.copy(this._quaternionStart);
          (_c = this.object) === null || _c === void 0 ? void 0 : _c.scale.copy(this._scaleStart);
          this.pointStart.copy(this.pointEnd);
        }
      }
      setRotationSnap(rotationSnap) {
        this.rotationSnap = rotationSnap;
      }
      setScaleSnap(scaleSnap) {
        this.scaleSnap = scaleSnap;
      }
      setSize(size) {
        this.size = size;
      }
      setSpace(space) {
        this.space = space;
      }
      setTranslationSnap(translationSnap) {
        this.translationSnap = translationSnap;
      }
      // updateMatrixWorld updates key transformation variables
      updateMatrixWorld(force = false) {
        if (this.object !== void 0) {
          this.object.updateMatrixWorld();
          if (this.object.parent === null) {
            console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
          } else {
            this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
          }
          this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
          this._parentQuaternionInv.copy(this._parentQuaternion).invert();
          this._worldQuaternionInv.copy(this.worldQuaternion).invert();
        }
        this.camera.updateMatrixWorld();
        this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
        if (this.camera.isOrthographicCamera) {
          this.camera.getWorldDirection(this.eye).negate();
        } else {
          this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
        }
        super.updateMatrixWorld(force);
      }
    };
    exports.TransformControls = TransformControls;
    var _tempEuler = new three_1.Euler();
    var _alignVector = new three_1.Vector3(0, 1, 0);
    var _zeroVector = new three_1.Vector3(0, 0, 0);
    var _lookAtMatrix = new three_1.Matrix4();
    var _tempQuaternion2 = new three_1.Quaternion();
    var _identityQuaternion = new three_1.Quaternion();
    var _dirVector = new three_1.Vector3();
    var _tempMatrix = new three_1.Matrix4();
    var _unitX = new three_1.Vector3(1, 0, 0);
    var _unitY = new three_1.Vector3(0, 1, 0);
    var _unitZ = new three_1.Vector3(0, 0, 1);
    var _v1 = new three_1.Vector3();
    var _v2 = new three_1.Vector3();
    var _v3 = new three_1.Vector3();
    var TransformControlsGizmo = class extends three_1.Object3D {
      // #endregion Properties (5)
      // #region Constructors (1)
      constructor(_transformControls) {
        super();
        this._transformControls = _transformControls;
        this.isTransformControlsGizmo = true;
        this.type = "TransformControlsGizmo";
        const gizmoMaterial = new three_1.MeshBasicMaterial({
          depthTest: false,
          depthWrite: false,
          fog: false,
          toneMapped: false,
          transparent: true
        });
        const gizmoLineMaterial = new three_1.LineBasicMaterial({
          depthTest: false,
          depthWrite: false,
          fog: false,
          toneMapped: false,
          transparent: true
        });
        const materialInvisible = gizmoMaterial.clone();
        materialInvisible.opacity = 0.15;
        const translationMaterialInvisible = materialInvisible.clone();
        const rotationMaterialInvisible = materialInvisible.clone();
        const scaleMaterialInvisible = materialInvisible.clone();
        const materialHelper = gizmoLineMaterial.clone();
        materialHelper.opacity = 0.5;
        const translationMaterialHelper = materialHelper.clone();
        const rotationMaterialHelper = materialHelper.clone();
        const scaleMaterialHelper = materialHelper.clone();
        const materialRed = gizmoMaterial.clone();
        materialRed.color.setHex(16711680);
        const translationMaterialRed = materialRed.clone();
        const rotationMaterialRed = materialRed.clone();
        const scaleMaterialRed = materialRed.clone();
        const materialGreen = gizmoMaterial.clone();
        materialGreen.color.setHex(65280);
        const translationMaterialGreen = materialGreen.clone();
        const rotationMaterialGreen = materialGreen.clone();
        const scaleMaterialGreen = materialGreen.clone();
        const materialBlue = gizmoMaterial.clone();
        materialBlue.color.setHex(255);
        const translationMaterialBlue = materialBlue.clone();
        const rotationMaterialBlue = materialBlue.clone();
        const scaleMaterialBlue = materialBlue.clone();
        const materialRedTransparent = gizmoMaterial.clone();
        materialRedTransparent.color.setHex(16711680);
        materialRedTransparent.opacity = 0.5;
        const translationMaterialRedTransparent = materialRedTransparent.clone();
        const scaleMaterialRedTransparent = materialRedTransparent.clone();
        const materialGreenTransparent = gizmoMaterial.clone();
        materialGreenTransparent.color.setHex(65280);
        materialGreenTransparent.opacity = 0.5;
        const translationMaterialGreenTransparent = materialGreenTransparent.clone();
        const scaleMaterialGreenTransparent = materialGreenTransparent.clone();
        const materialBlueTransparent = gizmoMaterial.clone();
        materialBlueTransparent.color.setHex(255);
        materialBlueTransparent.opacity = 0.5;
        const translationMaterialBlueTransparent = materialBlueTransparent.clone();
        const scaleMaterialBlueTransparent = materialBlueTransparent.clone();
        const materialWhiteTransparent = gizmoMaterial.clone();
        materialWhiteTransparent.opacity = 0.25;
        const translationMaterialWhiteTransparent = materialWhiteTransparent.clone();
        const scaleMaterialWhiteTransparent = materialWhiteTransparent.clone();
        const materialYellowTransparent = gizmoMaterial.clone();
        materialYellowTransparent.color.setHex(16776960);
        materialYellowTransparent.opacity = 0.25;
        const rotationMaterialYellowTransparent = materialYellowTransparent.clone();
        const materialGray = gizmoMaterial.clone();
        materialGray.color.setHex(7895160);
        const rotationMaterialGray = materialGray.clone();
        const arrowGeo = new three_1.CylinderGeometry(0, 0.04, 0.1, 12);
        arrowGeo.translate(0, 0.05, 0);
        const translationArrowGeometry = arrowGeo.clone();
        const scaleHandleGeometry = new three_1.BoxGeometry(0.08, 0.08, 0.08);
        scaleHandleGeometry.translate(0, 0.04, 0);
        const lineGeo = new three_1.BufferGeometry();
        lineGeo.setAttribute("position", new three_1.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
        const translationLineGeometry = lineGeo.clone();
        const scaleLineGeometry = lineGeo.clone();
        const rotationLineGeometry = lineGeo.clone();
        const lineGeo2 = new three_1.CylinderGeometry(75e-4, 75e-4, 0.5, 3);
        lineGeo2.translate(0, 0.25, 0);
        const translationLineGeometry2 = lineGeo2.clone();
        function CircleGeometry(radius, arc) {
          const geometry = new three_1.TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
          geometry.rotateY(Math.PI / 2);
          geometry.rotateX(Math.PI / 2);
          return geometry;
        }
        function TranslateHelperGeometry() {
          const geometry = new three_1.BufferGeometry();
          geometry.setAttribute("position", new three_1.Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
          return geometry;
        }
        const gizmoTranslate = {
          X: [
            [new three_1.Mesh(translationArrowGeometry, translationMaterialRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
            // [new Mesh(translationArrowGeometry, translationMaterialRed), [- 0.5, 0, 0], [0, 0, Math.PI / 2]],
            [new three_1.Mesh(translationLineGeometry2, translationMaterialRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
          ],
          Y: [
            [new three_1.Mesh(translationArrowGeometry, translationMaterialGreen), [0, 0.5, 0]],
            // [new Mesh(translationArrowGeometry, translationMaterialGreen), [0, - 0.5, 0], [Math.PI, 0, 0]],
            [new three_1.Mesh(translationLineGeometry2, translationMaterialGreen)]
          ],
          Z: [
            [new three_1.Mesh(translationArrowGeometry, translationMaterialBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
            // [new Mesh(translationArrowGeometry, translationMaterialBlue), [0, 0, - 0.5], [- Math.PI / 2, 0, 0]],
            [new three_1.Mesh(translationLineGeometry2, translationMaterialBlue), null, [Math.PI / 2, 0, 0]]
          ],
          XYZ: [
            [new three_1.Mesh(new three_1.OctahedronGeometry(0.1, 0), translationMaterialWhiteTransparent.clone()), [0, 0, 0]]
          ],
          XY: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialBlueTransparent.clone()), [0.25, 0.25, 0]]
          ],
          YZ: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialRedTransparent.clone()), [0, 0.25, 0.25], [0, Math.PI / 2, 0]]
          ],
          XZ: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialGreenTransparent.clone()), [0.25, 0, 0.25], [-Math.PI / 2, 0, 0]]
          ]
        };
        const pickerTranslate = {
          X: [
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]]
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [- 0.3, 0, 0], [0, 0, Math.PI / 2]]
          ],
          Y: [
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0.3, 0]]
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, - 0.3, 0], [0, 0, Math.PI]]
          ],
          Z: [
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]]
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0, - 0.3], [- Math.PI / 2, 0, 0]]
          ],
          XYZ: [
            [new three_1.Mesh(new three_1.OctahedronGeometry(0.2, 0), translationMaterialInvisible)]
          ],
          XY: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0.25, 0.25, 0]]
          ],
          YZ: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0, 0.25, 0.25], [0, Math.PI / 2, 0]]
          ],
          XZ: [
            [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0.25, 0, 0.25], [-Math.PI / 2, 0, 0]]
          ]
        };
        const helperTranslate = {
          START: [
            [new three_1.Mesh(new three_1.OctahedronGeometry(0.01, 2), translationMaterialHelper), null, null, null, "helper"]
          ],
          END: [
            [new three_1.Mesh(new three_1.OctahedronGeometry(0.01, 2), translationMaterialHelper), null, null, null, "helper"]
          ],
          DELTA: [
            [new three_1.Line(TranslateHelperGeometry(), translationMaterialHelper), null, null, null, "helper"]
          ],
          X: [
            [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
          ],
          Y: [
            [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
          ],
          Z: [
            [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
          ]
        };
        const rotationScale = 1.5;
        const gizmoRotate = {
          // XYZE: [
          //     [new Mesh(CircleGeometry(0.5 * rotationScale, 1), rotationMaterialGray), null, [0, Math.PI / 2, 0]]
          // ],
          X: [
            [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialRed)]
          ],
          Y: [
            [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialGreen), null, [0, 0, -Math.PI / 2]]
          ],
          Z: [
            [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialBlue), null, [0, Math.PI / 2, 0]]
          ],
          E: [
            [new three_1.Mesh(CircleGeometry(0.6 * rotationScale, 1), rotationMaterialYellowTransparent), null, [0, Math.PI / 2, 0]]
          ]
        };
        const helperRotate = {
          AXIS: [
            [new three_1.Line(rotationLineGeometry, rotationMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
          ]
        };
        const pickerRotate = {
          // XYZE: [
          //     [new Mesh(new SphereGeometry(0.25 * rotationScale, 10, 8), rotationMaterialInvisible)]
          // ],
          X: [
            [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
          ],
          Y: [
            [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
          ],
          Z: [
            [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
          ],
          E: [
            [new three_1.Mesh(new three_1.TorusGeometry(0.6 * rotationScale, 0.1, 2, 24), rotationMaterialInvisible)]
          ]
        };
        const gizmoScale = {
          X: [
            // [new Mesh(scaleHandleGeometry, scaleMaterialRed), [0.5, 0, 0], [0, 0, - Math.PI / 2]],
            // [new Mesh(scaleLineGeometry2, scaleMaterialRed), [0, 0, 0], [0, 0, - Math.PI / 2]],
            [new three_1.Mesh(scaleHandleGeometry, scaleMaterialRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
          ],
          Y: [
            // [new Mesh(scaleHandleGeometry, scaleMaterialGreen), [0, 0.5, 0]],
            // [new Mesh(scaleLineGeometry2, scaleMaterialGreen)],
            [new three_1.Mesh(scaleHandleGeometry, scaleMaterialGreen), [0, -0.5, 0], [0, 0, Math.PI]]
          ],
          Z: [
            // [new Mesh(scaleHandleGeometry, scaleMaterialBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
            // [new Mesh(scaleLineGeometry2, scaleMaterialBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
            [new three_1.Mesh(scaleHandleGeometry, scaleMaterialBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
          ]
          // XY: [
          //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialBlueTransparent), [0.15, 0.15, 0]]
          // ],
          // YZ: [
          //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
          // ],
          // XZ: [
          //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialGreenTransparent), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]
          // ],
          // XYZ: [
          //     [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), scaleMaterialWhiteTransparent.clone())],
          // ]
        };
        const pickerScale = {
          X: [
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0.3, 0, 0], [0, 0, - Math.PI / 2]],
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
          ],
          Y: [
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0.3, 0]],
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
          ],
          Z: [
            // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
            [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
          ]
          // XY: [
          //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0.15, 0.15, 0]],
          // ],
          // YZ: [
          //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
          // ],
          // XZ: [
          //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]],
          // ],
          // XYZ: [
          //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), scaleMaterialInvisible), [0, 0, 0]],
          // ]
        };
        const helperScale = {
          X: [
            [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
          ],
          Y: [
            [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
          ],
          Z: [
            [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
          ]
        };
        function setupGizmo(gizmoMap) {
          const gizmo = new three_1.Object3D();
          for (const name in gizmoMap) {
            for (let i = gizmoMap[name].length; i--; ) {
              const object = gizmoMap[name][i][0].clone();
              const position = gizmoMap[name][i][1];
              const rotation = gizmoMap[name][i][2];
              const scale = gizmoMap[name][i][3];
              const tag = gizmoMap[name][i][4];
              object.name = name;
              object.userData.ambientOcclusion = false;
              object.tag = tag;
              if (position) {
                object.position.set(position[0], position[1], position[2]);
              }
              if (rotation) {
                object.rotation.set(rotation[0], rotation[1], rotation[2]);
              }
              if (scale) {
                object.scale.set(scale[0], scale[1], scale[2]);
              }
              object.updateMatrix();
              const tempGeometry = object.geometry.clone();
              tempGeometry.applyMatrix4(object.matrix);
              object.geometry = tempGeometry;
              object.renderOrder = Infinity;
              object.position.set(0, 0, 0);
              object.rotation.set(0, 0, 0);
              object.scale.set(1, 1, 1);
              gizmo.add(object);
            }
          }
          return gizmo;
        }
        this.gizmo = {
          "translate": setupGizmo(gizmoTranslate),
          "rotate": setupGizmo(gizmoRotate),
          "scale": setupGizmo(gizmoScale)
        };
        this.picker = {
          "translate": setupGizmo(pickerTranslate),
          "rotate": setupGizmo(pickerRotate),
          "scale": setupGizmo(pickerScale)
        };
        this.helper = {
          "translate": setupGizmo(helperTranslate),
          "rotate": setupGizmo(helperRotate),
          "scale": setupGizmo(helperScale)
        };
        this.add(this.gizmo["scale"]);
        this.add(this.picker["scale"]);
        this.add(this.helper["scale"]);
        this.add(this.gizmo["translate"]);
        this.add(this.picker["translate"]);
        this.add(this.helper["translate"]);
        this.add(this.gizmo["rotate"]);
        this.add(this.picker["rotate"]);
        this.add(this.helper["rotate"]);
        this.picker["translate"].visible = false;
        this.picker["rotate"].visible = false;
        this.picker["scale"].visible = false;
      }
      // #endregion Constructors (1)
      // #region Public Methods (1)
      // updateMatrixWorld will update transformations and appearance of individual handles
      updateMatrixWorld(force) {
        var _a;
        const space = this._transformControls.space;
        let quaternion = new three_1.Quaternion();
        if (space === "local") {
          (_a = this._transformControls.object) === null || _a === void 0 ? void 0 : _a.getWorldQuaternion(quaternion);
        } else {
          quaternion = _identityQuaternion;
        }
        this.gizmo["translate"].visible = this._transformControls.enableTranslation;
        this.gizmo["rotate"].visible = this._transformControls.enableRotation;
        this.gizmo["scale"].visible = this._transformControls.enableScaling && this._transformControls.space === "local";
        this.helper["translate"].visible = this._transformControls.enableTranslation;
        this.helper["rotate"].visible = this._transformControls.enableRotation;
        this.helper["scale"].visible = this._transformControls.enableScaling && this._transformControls.space === "local";
        let handles = [];
        if (this._transformControls.enableTranslation) {
          let pickers = this.picker.translate.children;
          let gizmos = this.gizmo.translate.children;
          let helpers = this.helper.translate.children;
          if (this._transformControls.enableTranslationX === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "X");
          if (this._transformControls.enableTranslationY === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Y");
          if (this._transformControls.enableTranslationZ === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Z");
          handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
          handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
          handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
        }
        if (this._transformControls.enableRotation) {
          let pickers = this.picker.rotate.children;
          let gizmos = this.gizmo.rotate.children;
          let helpers = this.helper.rotate.children;
          if (this._transformControls.enableRotationX === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "X");
          if (this._transformControls.enableRotationY === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Y");
          if (this._transformControls.enableRotationZ === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Z");
          if (this._transformControls.enableRotationX === false || this._transformControls.enableRotationY === false || this._transformControls.enableRotationZ === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "E");
          handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.ROTATION })));
          handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.ROTATION })));
          handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.ROTATION })));
        }
        if (this._transformControls.enableScaling && this._transformControls.space === "local") {
          let pickers = this.picker.scale.children;
          let gizmos = this.gizmo.scale.children;
          let helpers = this.helper.scale.children;
          if (this._transformControls.enableScalingX === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "X");
          if (this._transformControls.enableScalingY === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Y");
          if (this._transformControls.enableScalingZ === false)
            [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, "Z");
          handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.SCALE })));
          handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.SCALE })));
          handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.SCALE })));
        }
        for (let i = 0; i < handles.length; i++) {
          const handle = handles[i];
          handle.object.visible = true;
          handle.object.rotation.set(0, 0, 0);
          handle.object.position.copy(this._transformControls.worldPosition);
          let factor;
          if (this._transformControls.camera.isOrthographicCamera) {
            factor = (this._transformControls.camera.top - this._transformControls.camera.bottom) / this._transformControls.camera.zoom;
          } else {
            factor = this._transformControls.worldPosition.distanceTo(this._transformControls.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this._transformControls.camera.fov / 360) / this._transformControls.camera.zoom, 7);
          }
          handle.object.scale.set(1, 1, 1).multiplyScalar(factor * this._transformControls.size);
          if (handle.object.tag === "helper") {
            handle.object.visible = false;
            if (handle.object.name === "AXIS") {
              handle.object.visible = !!this._transformControls.axis;
              if (this._transformControls.axis === "X") {
                _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
                handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                  handle.object.visible = false;
                }
              }
              if (this._transformControls.axis === "Y") {
                _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
                handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                  handle.object.visible = false;
                }
              }
              if (this._transformControls.axis === "Z") {
                _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
                handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                  handle.object.visible = false;
                }
              }
              if (this._transformControls.axis === "XYZE") {
                _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
                _alignVector.copy(this._transformControls.rotationAxis);
                handle.object.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
                handle.object.quaternion.multiply(_tempQuaternion);
                handle.object.visible = this._transformControls.dragging;
              }
              if (this._transformControls.axis === "E") {
                handle.object.visible = false;
              }
            } else if (handle.object.name === "START") {
              handle.object.position.copy(this._transformControls.worldPositionStart);
              handle.object.visible = this._transformControls.dragging;
            } else if (handle.object.name === "END") {
              handle.object.position.copy(this._transformControls.worldPosition);
              handle.object.visible = this._transformControls.dragging;
            } else if (handle.object.name === "DELTA") {
              handle.object.position.copy(this._transformControls.worldPositionStart);
              handle.object.quaternion.copy(this._transformControls.worldQuaternionStart);
              _tempVector.set(1e-10, 1e-10, 1e-10).add(this._transformControls.worldPositionStart).sub(this._transformControls.worldPosition).multiplyScalar(-1);
              _tempVector.applyQuaternion(this._transformControls.worldQuaternionStart.clone().invert());
              handle.object.scale.copy(_tempVector);
              handle.object.visible = this._transformControls.dragging;
            } else {
              handle.object.quaternion.copy(quaternion);
              if (this._transformControls.dragging) {
                handle.object.position.copy(this._transformControls.worldPositionStart);
              } else {
                handle.object.position.copy(this._transformControls.worldPosition);
              }
              if (this._transformControls.axis) {
                handle.object.visible = this._transformControls.axis.search(handle.object.name) !== -1;
              }
            }
            continue;
          }
          handle.object.quaternion.copy(quaternion);
          if (this._transformControls.enableTranslation && handle.mode === TransformationType.TRANSLATION || this._transformControls.enableScaling && handle.mode === TransformationType.SCALE) {
            const AXIS_HIDE_THRESHOLD = 0.99;
            const PLANE_HIDE_THRESHOLD = 0.2;
            if (handle.object.name === "X") {
              if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
            if (handle.object.name === "Y") {
              if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
            if (handle.object.name === "Z") {
              if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
            if (handle.object.name === "XY") {
              if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
            if (handle.object.name === "YZ") {
              if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
            if (handle.object.name === "XZ") {
              if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                handle.object.scale.set(1e-10, 1e-10, 1e-10);
                handle.object.visible = false;
              }
            }
          }
          if (this._transformControls.enableRotation) {
            _tempQuaternion2.copy(quaternion);
            _alignVector.copy(this._transformControls.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
            if (handle.object.name.search("E") !== -1) {
              handle.object.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this._transformControls.eye, _zeroVector, _unitY));
            }
            if (handle.object.name === "X") {
              _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
              _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
              handle.object.quaternion.copy(_tempQuaternion);
            }
            if (handle.object.name === "Y") {
              _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
              _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
              handle.object.quaternion.copy(_tempQuaternion);
            }
            if (handle.object.name === "Z") {
              _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
              _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
              handle.object.quaternion.copy(_tempQuaternion);
            }
          }
          handle.object.visible = handle.object.visible && (handle.object.name.indexOf("X") === -1 || this._transformControls.showX);
          handle.object.visible = handle.object.visible && (handle.object.name.indexOf("Y") === -1 || this._transformControls.showY);
          handle.object.visible = handle.object.visible && (handle.object.name.indexOf("Z") === -1 || this._transformControls.showZ);
          handle.object.visible = handle.object.visible && (handle.object.name.indexOf("E") === -1 || this._transformControls.showX && this._transformControls.showY && this._transformControls.showZ);
          if (!(handle.object.material instanceof three_1.MeshNormalMaterial)) {
            handle.object.material._color = handle.object.material._color || handle.object.material.color.clone();
            handle.object.material._opacity = handle.object.material._opacity || handle.object.material.opacity;
            handle.object.material.color.copy(handle.object.material._color);
            handle.object.material.opacity = handle.object.material._opacity;
            if (this._transformControls.enabled && this._transformControls.axis && handle.mode === this._transformControls.mode) {
              if (handle.object.name === this._transformControls.axis) {
                handle.object.material.color.setHex(16776960);
                handle.object.material.opacity = 1;
              } else if (this._transformControls.axis.split("").some(function(a) {
                return handle.object.name === a;
              })) {
                handle.object.material.color.setHex(16776960);
                handle.object.material.opacity = 1;
              }
            } else if (this._transformControls.enabled && this._transformControls.pivotDragged) {
              handle.object.material.color.setHex(16776960);
              handle.object.material.opacity = 1;
            }
          }
        }
        super.updateMatrixWorld(force);
      }
      // #endregion Public Methods (1)
      // #region Private Methods (1)
      filterOutAxis(pickers, gizmos, helpers, axis) {
        const pickersAxis = pickers.filter((object) => object.name.includes(axis));
        const gizmosAxis = gizmos.filter((object) => object.name.includes(axis));
        const helpersAxis = helpers.filter((object) => object.name.includes(axis));
        [pickersAxis, gizmosAxis, helpersAxis].forEach((objects) => {
          objects.forEach((object) => {
            object.visible = false;
          });
        });
        pickers = pickers.filter((object) => !object.name.includes(axis));
        gizmos = gizmos.filter((object) => !object.name.includes(axis));
        helpers = helpers.filter((object) => !object.name.includes(axis));
        return [pickers, gizmos, helpers];
      }
    };
    exports.TransformControlsGizmo = TransformControlsGizmo;
    var TransformControlsPlane = class extends three_1.Mesh {
      // #endregion Properties (2)
      // #region Constructors (1)
      constructor(_transformControls) {
        super(new three_1.PlaneGeometry(1e5, 1e5, 2, 2), new three_1.MeshBasicMaterial({ visible: false, wireframe: true, side: three_1.DoubleSide, transparent: true, opacity: 0.1, toneMapped: false }));
        this._transformControls = _transformControls;
        this.isTransformControlsPlane = true;
        this.type = "TransformControlsPlane";
      }
      // #endregion Constructors (1)
      // #region Public Methods (1)
      updateMatrixWorld(force) {
        const space = this._transformControls.space;
        this.position.copy(this._transformControls.worldPosition);
        _v1.copy(_unitX).applyQuaternion(space === "local" ? this._transformControls.worldQuaternion : _identityQuaternion);
        _v2.copy(_unitY).applyQuaternion(space === "local" ? this._transformControls.worldQuaternion : _identityQuaternion);
        _v3.copy(_unitZ).applyQuaternion(space === "local" ? this._transformControls.worldQuaternion : _identityQuaternion);
        _alignVector.copy(_v2);
        if (this._transformControls.mode === TransformationType.TRANSLATION || this._transformControls.mode === TransformationType.SCALE) {
          switch (this._transformControls.axis) {
            case "X":
              _alignVector.copy(this._transformControls.eye).cross(_v1);
              _dirVector.copy(_v1).cross(_alignVector);
              break;
            case "Y":
              _alignVector.copy(this._transformControls.eye).cross(_v2);
              _dirVector.copy(_v2).cross(_alignVector);
              break;
            case "Z":
              _alignVector.copy(this._transformControls.eye).cross(_v3);
              _dirVector.copy(_v3).cross(_alignVector);
              break;
            case "XY":
              _dirVector.copy(_v3);
              break;
            case "YZ":
              _dirVector.copy(_v1);
              break;
            case "XZ":
              _alignVector.copy(_v3);
              _dirVector.copy(_v2);
              break;
            case "XYZ":
            case "E":
              _dirVector.set(0, 0, 0);
              break;
            default:
          }
        }
        if (this._transformControls.mode === TransformationType.ROTATION) {
          _dirVector.set(0, 0, 0);
        }
        if (_dirVector.length() === 0) {
          this.quaternion.copy(this._transformControls.cameraQuaternion);
        } else {
          _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
          this.quaternion.setFromRotationMatrix(_tempMatrix);
        }
        super.updateMatrixWorld(force);
      }
    };
    exports.TransformControlsPlane = TransformControlsPlane;
  }
});

// node_modules/@shapediver/viewer.features.gumball/dist/implementation/Gumball.js
var require_Gumball = __commonJS({
  "node_modules/@shapediver/viewer.features.gumball/dist/implementation/Gumball.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Gumball_eventEngine;
    var _Gumball_keysPressed;
    var _Gumball_matrixId;
    var _Gumball_nodes;
    var _Gumball_parentObject;
    var _Gumball_singleNode;
    var _Gumball_transformControls;
    var _Gumball_transformationControlsPlaceholder;
    var _Gumball_viewport;
    var _Gumball_cameraFreezeFlag;
    var _Gumball_canvasEventListenerToken;
    var _Gumball_closed;
    var _Gumball_continuousRenderingFlag;
    var _Gumball_continuousShadowMapUpdateFlag;
    var _Gumball_currentMatrix;
    var _Gumball_enableRotation;
    var _Gumball_enableRotationX;
    var _Gumball_enableRotationY;
    var _Gumball_enableRotationZ;
    var _Gumball_enableScaling;
    var _Gumball_enableScalingX;
    var _Gumball_enableScalingY;
    var _Gumball_enableScalingZ;
    var _Gumball_enableTranslation;
    var _Gumball_enableTranslationX;
    var _Gumball_enableTranslationY;
    var _Gumball_enableTranslationZ;
    var _Gumball_initialOffset;
    var _Gumball_initialTransform;
    var _Gumball_matrix;
    var _Gumball_moving;
    var _Gumball_pivotDragging;
    var _Gumball_pivotOffset;
    var _Gumball_previousGumballMatrix;
    var _Gumball_reuseTransformation;
    var _Gumball_scale;
    var _Gumball_show;
    var _Gumball_space;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gumball = void 0;
    var THREE = __importStar(require_three());
    var viewer_1 = require_dist2();
    var viewer_shared_services_1 = require_dist();
    var gl_matrix_1 = (init_esm(), __toCommonJS(esm_exports));
    var TransformControls_1 = require_TransformControls();
    var Gumball = class {
      // #endregion Properties (38)
      // #region Constructors (1)
      constructor(viewport, nodes, settings) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        _Gumball_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _Gumball_keysPressed.set(this, {});
        _Gumball_matrixId.set(this, "SD_gumball_matrix");
        _Gumball_nodes.set(this, []);
        _Gumball_parentObject.set(this, new THREE.Object3D());
        _Gumball_singleNode.set(this, void 0);
        _Gumball_transformControls.set(this, void 0);
        _Gumball_transformationControlsPlaceholder.set(this, new THREE.Object3D());
        _Gumball_viewport.set(this, void 0);
        _Gumball_cameraFreezeFlag.set(this, void 0);
        _Gumball_canvasEventListenerToken.set(this, void 0);
        _Gumball_closed.set(this, false);
        _Gumball_continuousRenderingFlag.set(this, void 0);
        _Gumball_continuousShadowMapUpdateFlag.set(this, void 0);
        _Gumball_currentMatrix.set(this, new THREE.Matrix4());
        _Gumball_enableRotation.set(this, true);
        _Gumball_enableRotationX.set(this, true);
        _Gumball_enableRotationY.set(this, true);
        _Gumball_enableRotationZ.set(this, true);
        _Gumball_enableScaling.set(this, true);
        _Gumball_enableScalingX.set(this, true);
        _Gumball_enableScalingY.set(this, true);
        _Gumball_enableScalingZ.set(this, true);
        _Gumball_enableTranslation.set(this, true);
        _Gumball_enableTranslationX.set(this, true);
        _Gumball_enableTranslationY.set(this, true);
        _Gumball_enableTranslationZ.set(this, true);
        _Gumball_initialOffset.set(this, gl_matrix_1.vec3.create());
        _Gumball_initialTransform.set(this, []);
        _Gumball_matrix.set(this, gl_matrix_1.mat4.create());
        _Gumball_moving.set(this, false);
        _Gumball_pivotDragging.set(this, false);
        _Gumball_pivotOffset.set(this, gl_matrix_1.mat4.create());
        _Gumball_previousGumballMatrix.set(this, []);
        _Gumball_reuseTransformation.set(this, true);
        _Gumball_scale.set(this, 0.15);
        _Gumball_show.set(this, true);
        _Gumball_space.set(this, "local");
        __classPrivateFieldSet(this, _Gumball_viewport, viewport, "f");
        __classPrivateFieldSet(this, _Gumball_canvasEventListenerToken, __classPrivateFieldGet(this, _Gumball_viewport, "f").addCanvasEventListener(this), "f");
        __classPrivateFieldSet(this, _Gumball_nodes, nodes, "f");
        __classPrivateFieldSet(this, _Gumball_singleNode, nodes.length === 1, "f");
        __classPrivateFieldSet(this, _Gumball_transformControls, new TransformControls_1.TransformControls(viewport.threeJsCoreObjects.camera, viewport.threeJsCoreObjects.renderer.domElement, this.updateObjects.bind(this), this.updateObjectMatrices.bind(this)), "f");
        this.enableRotation = (_a = settings === null || settings === void 0 ? void 0 : settings.enableRotation) !== null && _a !== void 0 ? _a : true;
        this.enableRotationX = (_c = (_b = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : true;
        this.enableRotationY = (_e = (_d = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _d === void 0 ? void 0 : _d.y) !== null && _e !== void 0 ? _e : true;
        this.enableRotationZ = (_g = (_f = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _f === void 0 ? void 0 : _f.z) !== null && _g !== void 0 ? _g : true;
        this.enableScaling = (_h = settings === null || settings === void 0 ? void 0 : settings.enableScaling) !== null && _h !== void 0 ? _h : false;
        this.enableScalingX = (_k = (_j = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _j === void 0 ? void 0 : _j.x) !== null && _k !== void 0 ? _k : true;
        this.enableScalingY = (_m = (_l = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _l === void 0 ? void 0 : _l.y) !== null && _m !== void 0 ? _m : true;
        this.enableScalingZ = (_p = (_o = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _o === void 0 ? void 0 : _o.z) !== null && _p !== void 0 ? _p : true;
        this.enableTranslation = (_q = settings === null || settings === void 0 ? void 0 : settings.enableTranslation) !== null && _q !== void 0 ? _q : true;
        this.enableTranslationX = (_s = (_r = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _r === void 0 ? void 0 : _r.x) !== null && _s !== void 0 ? _s : true;
        this.enableTranslationY = (_u = (_t = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _t === void 0 ? void 0 : _t.y) !== null && _u !== void 0 ? _u : true;
        this.enableTranslationZ = (_w = (_v = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _v === void 0 ? void 0 : _v.z) !== null && _w !== void 0 ? _w : true;
        this.scale = (_x = settings === null || settings === void 0 ? void 0 : settings.scale) !== null && _x !== void 0 ? _x : 0.15;
        __classPrivateFieldSet(this, _Gumball_space, (_y = settings === null || settings === void 0 ? void 0 : settings.space) !== null && _y !== void 0 ? _y : "local", "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").space = __classPrivateFieldGet(this, _Gumball_space, "f");
        __classPrivateFieldSet(this, _Gumball_reuseTransformation, (_z = settings === null || settings === void 0 ? void 0 : settings.reuseTransformation) !== null && _z !== void 0 ? _z : true, "f");
        this.setup();
      }
      // #endregion Constructors (1)
      // #region Public Getters And Setters (32)
      get closed() {
        return __classPrivateFieldGet(this, _Gumball_closed, "f");
      }
      get enableRotation() {
        return __classPrivateFieldGet(this, _Gumball_enableRotation, "f");
      }
      set enableRotation(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotation, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = value;
      }
      get enableRotationX() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationX, "f");
      }
      set enableRotationX(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationX = value;
      }
      get enableRotationY() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationY, "f");
      }
      set enableRotationY(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationY = value;
      }
      get enableRotationZ() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationZ, "f");
      }
      set enableRotationZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationZ = value;
      }
      get enableScaling() {
        return __classPrivateFieldGet(this, _Gumball_enableScaling, "f");
      }
      set enableScaling(value) {
        __classPrivateFieldSet(this, _Gumball_enableScaling, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = value;
      }
      get enableScalingX() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingX, "f");
      }
      set enableScalingX(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingX = value;
      }
      get enableScalingY() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingY, "f");
      }
      set enableScalingY(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingY = value;
      }
      get enableScalingZ() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingZ, "f");
      }
      set enableScalingZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingZ = value;
      }
      get enableTranslation() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslation, "f");
      }
      set enableTranslation(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslation, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = value;
      }
      get enableTranslationX() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationX, "f");
      }
      set enableTranslationX(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationX = value;
      }
      get enableTranslationY() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationY, "f");
      }
      set enableTranslationY(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationY = value;
      }
      get enableTranslationZ() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationZ, "f");
      }
      set enableTranslationZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationZ = value;
      }
      get matrix() {
        return __classPrivateFieldGet(this, _Gumball_matrix, "f");
      }
      get reuseTransformation() {
        return __classPrivateFieldGet(this, _Gumball_reuseTransformation, "f");
      }
      get scale() {
        return __classPrivateFieldGet(this, _Gumball_scale, "f");
      }
      set scale(value) {
        __classPrivateFieldSet(this, _Gumball_scale, value, "f");
        const size = viewer_1.sceneTree.root.boundingBox.boundingSphere.radius * value;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").setSize(size);
      }
      get show() {
        return __classPrivateFieldGet(this, _Gumball_show, "f");
      }
      set show(value) {
        __classPrivateFieldSet(this, _Gumball_show, value, "f");
      }
      get space() {
        return __classPrivateFieldGet(this, _Gumball_space, "f");
      }
      // #endregion Public Getters And Setters (32)
      // #region Public Methods (10)
      close() {
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").remove(__classPrivateFieldGet(this, _Gumball_transformControls, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").remove(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").detach();
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").dispose();
        __classPrivateFieldGet(this, _Gumball_viewport, "f").threeJsCoreObjects.scene.remove(__classPrivateFieldGet(this, _Gumball_parentObject, "f"));
        __classPrivateFieldGet(this, _Gumball_viewport, "f").removeCanvasEventListener(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        if (__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"))
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"));
        if (__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"))
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"));
        if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"))
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
      }
      keyPressed(key) {
        if (Array.isArray(key)) {
          let result = false;
          for (let i = 0; i < key.length; i++) {
            result = result || this.keyPressCheck(key[i]);
          }
          return result;
        } else {
          return this.keyPressCheck(key);
        }
      }
      onKeyDown(event) {
        if (this.closed)
          return;
        __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[event.key] = true;
        if (__classPrivateFieldGet(this, _Gumball_moving, "f") === false && Object.values(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).length === 1 && this.keyPressed("p") && __classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === false) {
          this.activatePivotDragging();
        }
      }
      onKeyUp(event) {
        if (this.closed)
          return;
        delete __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[event.key];
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true && !this.keyPressed("p")) {
          this.deactivatePivotDragging();
        }
      }
      onMouseWheel(event) {
      }
      onPointerDown(event) {
        if (this.closed)
          return;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerDown(event);
        __classPrivateFieldSet(this, _Gumball_moving, __classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging, "f");
        if (__classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging || __classPrivateFieldGet(this, _Gumball_transformControls, "f").hovering)
          __classPrivateFieldGet(this, _Gumball_viewport, "f").addRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
      }
      onPointerEnd(event) {
        if (this.closed)
          return;
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
        __classPrivateFieldGet(this, _Gumball_viewport, "f").removeRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerUp(event);
      }
      onPointerMove(event) {
        if (this.closed)
          return;
        if (!__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"))
          __classPrivateFieldSet(this, _Gumball_continuousRenderingFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_RENDERING), "f");
        if (!__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"))
          __classPrivateFieldSet(this, _Gumball_continuousShadowMapUpdateFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE), "f");
        if (__classPrivateFieldGet(this, _Gumball_moving, "f") === false && Object.values(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).length === 1 && this.keyPressed("p") && __classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === false) {
          this.activatePivotDragging();
        }
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true && !this.keyPressed("p")) {
          this.deactivatePivotDragging();
        }
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerHover(event);
        if (__classPrivateFieldGet(this, _Gumball_moving, "f"))
          __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerMove(event);
        if (__classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging || __classPrivateFieldGet(this, _Gumball_transformControls, "f").hovering) {
          __classPrivateFieldGet(this, _Gumball_viewport, "f").addRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        } else {
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        }
      }
      onPointerOut(event) {
        if (this.closed)
          return;
        if (__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f")) {
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"));
          __classPrivateFieldSet(this, _Gumball_continuousRenderingFlag, void 0, "f");
        }
        if (__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f")) {
          __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"));
          __classPrivateFieldSet(this, _Gumball_continuousShadowMapUpdateFlag, void 0, "f");
        }
        __classPrivateFieldGet(this, _Gumball_viewport, "f").render();
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
      }
      onPointerUp(event) {
        if (this.closed)
          return;
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
      }
      // #endregion Public Methods (10)
      // #region Private Methods (7)
      activatePivotDragging() {
        __classPrivateFieldSet(this, _Gumball_pivotDragging, true, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").pivotDragged = true;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = true;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = false;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = false;
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f") === true && this.reuseTransformation === true) {
          const index = __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations.findIndex((t) => t.id === "SD_gumball_matrix");
          if (index !== -1) {
            __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.clone(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations[index].matrix);
          } else {
            __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.create();
          }
        }
        __classPrivateFieldSet(this, _Gumball_currentMatrix, __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix.clone().multiply(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f")).invert()), "f");
      }
      deactivatePivotDragging() {
        __classPrivateFieldSet(this, _Gumball_pivotDragging, false, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").pivotDragged = false;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = __classPrivateFieldGet(this, _Gumball_enableTranslation, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = __classPrivateFieldGet(this, _Gumball_enableRotation, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = __classPrivateFieldGet(this, _Gumball_enableScaling, "f");
      }
      getMatrix(previousMatrix) {
        const m = new THREE.Matrix4().copy(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix);
        const placeholderMatrix = gl_matrix_1.mat4.fromValues(...m.toArray());
        const initialOffsetCorrectionMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.negate(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _Gumball_initialOffset, "f")));
        const placeholderMatrixWithoutInitialOffset = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), placeholderMatrix, initialOffsetCorrectionMatrix);
        __classPrivateFieldSet(this, _Gumball_matrix, gl_matrix_1.mat4.clone(placeholderMatrixWithoutInitialOffset), "f");
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f") === true) {
          if (this.reuseTransformation === true) {
            const finalMatrix = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
            return finalMatrix;
          } else {
            const finalMatrix = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
            gl_matrix_1.mat4.multiply(finalMatrix, finalMatrix, previousMatrix);
            return finalMatrix;
          }
        } else {
          const finalMatrix = gl_matrix_1.mat4.create();
          gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
          gl_matrix_1.mat4.multiply(finalMatrix, finalMatrix, previousMatrix);
          return finalMatrix;
        }
      }
      keyPressCheck(key) {
        const pressedKeys = Object.keys(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).filter((key2) => __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[key2] === true);
        if (key.includes("+") && key.length > 1) {
          const keys = key.split("+");
          if (keys.length !== pressedKeys.length)
            return false;
          let result = true;
          for (let i = 0; i < keys.length; i++)
            result = result && (__classPrivateFieldGet(this, _Gumball_keysPressed, "f")[keys[i]] || false);
          return result;
        } else {
          if (pressedKeys.length > 1)
            return false;
          return __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[key] || false;
        }
      }
      setup() {
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f")) {
          const index = __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations.findIndex((t) => t.id === "SD_gumball_matrix");
          if (index !== -1) {
            __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.clone(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations[index].matrix);
          } else {
            __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.create();
          }
          if (this.reuseTransformation === true) {
            const trueBB = new viewer_1.Box();
            __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].traverseData((d) => {
              if (d instanceof viewer_1.GeometryData) {
                trueBB.union(d.boundingBox);
              }
            });
            gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), trueBB.boundingSphere.center);
            __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
            const transformations = {};
            __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].traverse((c) => {
              if (c.name.startsWith("mesh_") && c.parent)
                transformations[c.parent.name] = gl_matrix_1.mat4.clone(c.parent.nodeMatrix);
            });
            if (Object.keys(transformations).length === 1 && Object.keys(transformations)[0] !== "no_transformations") {
              __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.clone(transformations[Object.keys(transformations)[0]]);
              const initialWorldTransform = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].worldMatrix, __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0]);
              __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().fromArray(initialWorldTransform));
            } else {
              __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.create();
              __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].worldMatrix));
            }
          } else {
            __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.create();
            gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].boundingBox.boundingSphere.center);
            __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
          }
        } else {
          const boundingBox = new viewer_1.Box();
          __classPrivateFieldSet(this, _Gumball_previousGumballMatrix, [], "f");
          for (let i = 0; i < __classPrivateFieldGet(this, _Gumball_nodes, "f").length; i++) {
            const node = __classPrivateFieldGet(this, _Gumball_nodes, "f")[i];
            boundingBox.union(node.boundingBox);
            const index = node.transformations.findIndex((t) => t.id === "SD_gumball_matrix");
            if (index !== -1) {
              __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f").push(gl_matrix_1.mat4.clone(node.transformations[index].matrix));
            } else {
              __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f").push(gl_matrix_1.mat4.create());
            }
            const transformations = {};
            node.traverse((c) => {
              if (c.name.startsWith("mesh_") && c.parent) {
                transformations[c.parent.name] = gl_matrix_1.mat4.clone(c.parent.nodeMatrix);
              }
            });
            if (Object.keys(transformations).length === 1 && Object.keys(transformations)[0] !== "no_transformations") {
              __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i] = gl_matrix_1.mat4.clone(transformations[Object.keys(transformations)[0]]);
            } else {
              __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i] = gl_matrix_1.mat4.create();
            }
          }
          gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), boundingBox.boundingSphere.center);
          __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
        }
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").attach(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").setSize(__classPrivateFieldGet(this, _Gumball_scale, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").add(__classPrivateFieldGet(this, _Gumball_transformControls, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").add(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_viewport, "f").threeJsCoreObjects.scene.add(__classPrivateFieldGet(this, _Gumball_parentObject, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").addEventListener("dragging-changed", (event) => {
          if (event.value === true) {
            if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"))
              __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
            __classPrivateFieldSet(this, _Gumball_cameraFreezeFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CAMERA_FREEZE), "f");
          } else if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f")) {
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
            __classPrivateFieldSet(this, _Gumball_cameraFreezeFlag, void 0, "f");
          }
        });
      }
      updateObjectMatrices() {
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true) {
          const currentMatrix = __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix.clone().multiply(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f")).invert());
          const delta = new THREE.Matrix4().multiplyMatrices(__classPrivateFieldGet(this, _Gumball_currentMatrix, "f").clone().invert(), currentMatrix);
          gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f"), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f"), gl_matrix_1.mat4.fromValues(...delta.toArray()));
          this.deactivatePivotDragging();
        } else {
          const eventData = {
            viewportId: __classPrivateFieldGet(this, _Gumball_viewport, "f").id,
            transformations: [],
            localTransformations: [],
            nodes: []
          };
          __classPrivateFieldGet(this, _Gumball_nodes, "f").forEach((node, i) => {
            const matrix = this.getMatrix(__classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[i]);
            eventData.nodes.push(node);
            if (__classPrivateFieldGet(this, _Gumball_singleNode, "f")) {
              eventData.transformations.push(gl_matrix_1.mat4.clone(matrix));
              gl_matrix_1.mat4.multiply(matrix, matrix, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
            } else {
              eventData.transformations.push(gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), matrix, __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
            }
            const transformation = node.transformations.find((t) => t.id === __classPrivateFieldGet(this, _Gumball_matrixId, "f"));
            eventData.localTransformations.push(gl_matrix_1.mat4.clone(matrix));
            if (transformation) {
              transformation.matrix = matrix;
            } else {
              node.transformations.push({
                id: __classPrivateFieldGet(this, _Gumball_matrixId, "f"),
                matrix
              });
            }
            node.updateVersion();
          });
          __classPrivateFieldGet(this, _Gumball_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE_GUMBALL.MATRIX_CHANGED, eventData);
        }
      }
      updateObjects() {
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true)
          return;
        __classPrivateFieldGet(this, _Gumball_nodes, "f").forEach((node, i) => {
          const threeJsObject = node.convertedObject[__classPrivateFieldGet(this, _Gumball_viewport, "f").id];
          if (threeJsObject) {
            const matrix = this.getMatrix(__classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[i]);
            if (__classPrivateFieldGet(this, _Gumball_singleNode, "f"))
              gl_matrix_1.mat4.multiply(matrix, matrix, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
            threeJsObject.matrixAutoUpdate = false;
            threeJsObject.matrix.copy(new THREE.Matrix4().fromArray(matrix));
            threeJsObject.matrixWorldNeedsUpdate = true;
          }
        });
      }
    };
    exports.Gumball = Gumball;
    _Gumball_eventEngine = /* @__PURE__ */ new WeakMap(), _Gumball_keysPressed = /* @__PURE__ */ new WeakMap(), _Gumball_matrixId = /* @__PURE__ */ new WeakMap(), _Gumball_nodes = /* @__PURE__ */ new WeakMap(), _Gumball_parentObject = /* @__PURE__ */ new WeakMap(), _Gumball_singleNode = /* @__PURE__ */ new WeakMap(), _Gumball_transformControls = /* @__PURE__ */ new WeakMap(), _Gumball_transformationControlsPlaceholder = /* @__PURE__ */ new WeakMap(), _Gumball_viewport = /* @__PURE__ */ new WeakMap(), _Gumball_cameraFreezeFlag = /* @__PURE__ */ new WeakMap(), _Gumball_canvasEventListenerToken = /* @__PURE__ */ new WeakMap(), _Gumball_closed = /* @__PURE__ */ new WeakMap(), _Gumball_continuousRenderingFlag = /* @__PURE__ */ new WeakMap(), _Gumball_continuousShadowMapUpdateFlag = /* @__PURE__ */ new WeakMap(), _Gumball_currentMatrix = /* @__PURE__ */ new WeakMap(), _Gumball_enableRotation = /* @__PURE__ */ new WeakMap(), _Gumball_enableRotationX = /* @__PURE__ */ new WeakMap(), _Gumball_enableRotationY = /* @__PURE__ */ new WeakMap(), _Gumball_enableRotationZ = /* @__PURE__ */ new WeakMap(), _Gumball_enableScaling = /* @__PURE__ */ new WeakMap(), _Gumball_enableScalingX = /* @__PURE__ */ new WeakMap(), _Gumball_enableScalingY = /* @__PURE__ */ new WeakMap(), _Gumball_enableScalingZ = /* @__PURE__ */ new WeakMap(), _Gumball_enableTranslation = /* @__PURE__ */ new WeakMap(), _Gumball_enableTranslationX = /* @__PURE__ */ new WeakMap(), _Gumball_enableTranslationY = /* @__PURE__ */ new WeakMap(), _Gumball_enableTranslationZ = /* @__PURE__ */ new WeakMap(), _Gumball_initialOffset = /* @__PURE__ */ new WeakMap(), _Gumball_initialTransform = /* @__PURE__ */ new WeakMap(), _Gumball_matrix = /* @__PURE__ */ new WeakMap(), _Gumball_moving = /* @__PURE__ */ new WeakMap(), _Gumball_pivotDragging = /* @__PURE__ */ new WeakMap(), _Gumball_pivotOffset = /* @__PURE__ */ new WeakMap(), _Gumball_previousGumballMatrix = /* @__PURE__ */ new WeakMap(), _Gumball_reuseTransformation = /* @__PURE__ */ new WeakMap(), _Gumball_scale = /* @__PURE__ */ new WeakMap(), _Gumball_show = /* @__PURE__ */ new WeakMap(), _Gumball_space = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@shapediver/viewer.features.gumball/dist/implementation/updateGumballTransformation.js
var require_updateGumballTransformation = __commonJS({
  "node_modules/@shapediver/viewer.features.gumball/dist/implementation/updateGumballTransformation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGumballTransformation = void 0;
    var updateGumballTransformation = (node, transformation) => {
      if (transformation) {
        const transformIndex = node.transformations.findIndex((t) => t.id === "SD_gumball_matrix");
        if (transformIndex !== -1) {
          node.transformations[transformIndex].matrix = transformation;
          node.updateVersion();
        } else {
          node.transformations.push({
            id: "SD_gumball_matrix",
            matrix: transformation
          });
          node.updateVersion();
        }
      } else {
        const transformIndex = node.transformations.findIndex((t) => t.id === "SD_gumball_matrix");
        if (transformIndex !== -1) {
          node.transformations.splice(transformIndex, 1);
          node.updateVersion();
        }
      }
    };
    exports.updateGumballTransformation = updateGumballTransformation;
  }
});

// node_modules/@shapediver/viewer.features.gumball/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@shapediver/viewer.features.gumball/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGumballTransformation = exports.Gumball = void 0;
    var Gumball_1 = require_Gumball();
    Object.defineProperty(exports, "Gumball", { enumerable: true, get: function() {
      return Gumball_1.Gumball;
    } });
    var updateGumballTransformation_1 = require_updateGumballTransformation();
    Object.defineProperty(exports, "updateGumballTransformation", { enumerable: true, get: function() {
      return updateGumballTransformation_1.updateGumballTransformation;
    } });
  }
});
export default require_dist3();
//# sourceMappingURL=@shapediver_viewer__features__gumball.js.map

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Tree_root;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tree = void 0;
const tsyringe_1 = require("tsyringe");
const TreeNode_1 = require("./TreeNode");
let Tree = class Tree {
    // #endregion Properties (1)
    // #region Constructors (1)
    /**
     * @ignore
     * Management of the main tree node.
     */
    constructor() {
        // #region Properties (1)
        _Tree_root.set(this, new TreeNode_1.TreeNode('root'));
    }
    // #endregion Constructors (1)
    // #region Public Accessors (1)
    get root() {
        return __classPrivateFieldGet(this, _Tree_root, "f");
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (4)
    /**
     * Add the node as a child of the corresponding parent node.
     *
     * @param node the node to be added
     * @param parent the targeted parent node
     * @param root optional root at which the process begins, root node will be used per default
     */
    addNode(node, parent = __classPrivateFieldGet(this, _Tree_root, "f"), root = __classPrivateFieldGet(this, _Tree_root, "f")) {
        if (root === parent) {
            root.addChild(node);
            return true;
        }
        for (let i = 0; i < root.children.length; i++) {
            const child = root.children[i];
            if (child && this.addNode(node, parent, child)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Add the node at the corresponding path. (paths are dot separated ids)
     *
     * @param node the node to be added
     * @param path the path at which the node should be added
     * @param root optional root at which the process begins, root node will be used per default
     */
    addNodeAtPath(node, path = this.root.getPath(), root = __classPrivateFieldGet(this, _Tree_root, "f")) {
        if (root.name === path) {
            root.addChild(node);
            return true;
        }
        const pathStart = path.substr(0, path.indexOf('.'));
        if (root.name === pathStart) {
            const shortenedPath = path.substr(pathStart.length + 1, path.length);
            for (let i = 0; i < root.children.length; i++) {
                const child = root.children[i];
                if (child && this.addNodeAtPath(node, shortenedPath, child)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Remove a node from the tree.
     *
     * @param node the node to remove
     * @param root optional root at which the process begins, root node will be used per default
     */
    removeNode(node, root = __classPrivateFieldGet(this, _Tree_root, "f")) {
        if (root.hasChild(node)) {
            root.removeChild(node);
            return true;
        }
        for (let i = 0; i < root.children.length; i++) {
            const child = root.children[i];
            if (child && this.removeNode(node, child)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Remove a node via the path of it.
     *
     * @param path the path of the node to be removed
     * @param root optional root at which the process begins, root node will be used per default
     */
    removeNodeAtPath(path, root = __classPrivateFieldGet(this, _Tree_root, "f")) {
        var _a;
        if (root.name === path) {
            (_a = root.parent) === null || _a === void 0 ? void 0 : _a.removeChild(root);
            return true;
        }
        const pathStart = path.substr(0, path.indexOf('.'));
        if (root.name === pathStart) {
            const shortenedPath = path.substr(pathStart.length + 1, path.length);
            for (let i = 0; i < root.children.length; i++) {
                const child = root.children[i];
                if (child && this.removeNodeAtPath(shortenedPath, child)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get the node at the provided path.
     *
     * @param path
     * @param root
     * @returns
     */
    getNodeAtPath(path = this.root.getPath(), root = __classPrivateFieldGet(this, _Tree_root, "f")) {
        if (root.name === path)
            return root;
        const pathStart = path.substr(0, path.indexOf('.'));
        if (root.name === pathStart) {
            const shortenedPath = path.substr(pathStart.length + 1, path.length);
            for (let i = 0; i < root.children.length; i++) {
                const child = root.children[i];
                const res = this.getNodeAtPath(shortenedPath, child);
                if (res)
                    return res;
            }
        }
        return null;
    }
};
_Tree_root = new WeakMap();
Tree = __decorate([
    tsyringe_1.singleton(),
    __metadata("design:paramtypes", [])
], Tree);
exports.Tree = Tree;
//# sourceMappingURL=Tree.js.map
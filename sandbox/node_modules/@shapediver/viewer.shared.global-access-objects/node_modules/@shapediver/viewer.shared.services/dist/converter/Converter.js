"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = void 0;
const tinycolor_1 = require("@ctrl/tinycolor");
const gl_matrix_1 = require("gl-matrix");
const HttpClient_1 = require("../http-client/HttpClient");
const base64_1 = require("../utilities/base64");
class Converter {
    constructor() {
        // #region Properties (2)
        this._httpClient = HttpClient_1.HttpClient.instance;
        // #endregion Private Methods (1)
    }
    // #endregion Properties (2)
    // #region Public Static Getters And Setters (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * Converts a data URL to a Blob object.
     *
     * @param dataURL
     * @returns
     */
    dataURLtoBlob(dataURL) {
        // Split the data URL to get the base64 data
        const arr = dataURL.split(",");
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = window.atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        // Convert the binary string to a Uint8Array
        while (n--)
            u8arr[n] = bstr.charCodeAt(n);
        // Create a Blob object from the Uint8Array
        return {
            blob: new Blob([u8arr], { type: mime }),
            arrayBuffer: u8arr.buffer,
        };
    }
    /**
     * Convert the given image to an ArrayBuffer and return the image data.
     *
     * @param image The image to convert.
     * @param arrayBuffer Optional: The ArrayBuffer of the image, if it was already converted.
     * @returns
     */
    constructImageData(image, arrayBuffer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (image instanceof File) {
                return {
                    imageData: {
                        filename: image.name,
                        format: image.type,
                        size: image.size,
                    },
                    arrayBuffer: arrayBuffer || (yield image.arrayBuffer()),
                };
            }
            else {
                return {
                    imageData: {
                        format: image.type,
                        size: image.size,
                    },
                    arrayBuffer: arrayBuffer || (yield image.arrayBuffer()),
                };
            }
        });
    }
    /**
     * Convert the given input to an ArrayBuffer.
     *
     * @param input
     * @returns
     */
    convertToArrayBuffer(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (input instanceof File) {
                return yield input.arrayBuffer();
            }
            else if (input instanceof Blob) {
                return yield input.arrayBuffer();
            }
            else if (input instanceof ArrayBuffer) {
                return input;
            }
            else {
                const result = yield input();
                if (result instanceof Blob) {
                    return yield result.arrayBuffer();
                }
                else {
                    return result;
                }
            }
        });
    }
    // #endregion Public Static Getters And Setters (1)
    // #region Public Methods (8)
    processSVG(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = yield new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
            data = data.replace("data:image/svg+xml;base64,", "");
            data = (0, base64_1.atobCustom)(data);
            const svgC = document.createElement("DIV");
            svgC.id = "svgc";
            svgC.innerHTML = data;
            // now we can access the svg element as a DOM object
            const svgE = svgC.getElementsByTagName("svg");
            const childImageURIs = [];
            let styleURIs = [];
            // collect image urls
            for (let i = 0; i < svgE.length; ++i) {
                for (let j = 0; j < 2; ++j) {
                    const childImages = (svgE[i].getElementsByTagName(["image", "img"][j]));
                    for (let k = 0; k < childImages.length; ++k) {
                        if (childImages[k].href.baseVal.substring(0, 5) != "data:") {
                            childImageURIs.push(childImages[k].href.baseVal);
                        }
                    }
                }
                // collect potential font definitions
                // we assume styles are imported using the following syntax:
                // @import url(CSS_URL);
                const styleElements = (svgE[i].getElementsByTagName("style"));
                for (let j = 0; j < styleElements.length; ++j) {
                    const regex = /@import\x20url\(\s*(.*?)\s*\);/g;
                    let m;
                    while ((m = regex.exec(styleElements[j].innerHTML)) !== null) {
                        styleURIs.push(m[1]);
                    }
                    // make unique
                    styleURIs = styleURIs.filter(function (value, index, self) {
                        return self.indexOf(value) === index;
                    });
                }
            }
            // creating a promise for each image which needs to be converted to a data URI
            const replacementPromises = [];
            const createImagePromise = (uri) => __awaiter(this, void 0, void 0, function* () {
                if (uri.length > 0) {
                    const response = (yield this._httpClient.get(uri, undefined, true));
                    const uInt8Array = new Uint8Array(response.data);
                    let i = uInt8Array.length;
                    const biStr = []; //new Array(i);
                    while (i--)
                        biStr[i] = String.fromCharCode(uInt8Array[i]);
                    const base64Data = (0, base64_1.btoaCustom)(biStr.join(""));
                    const imgDataUrl = "data:" +
                        response.headers["content-type"] +
                        ";base64," +
                        base64Data;
                    // replace url in SVG string
                    // CAUTION theoretically this could cause unwanted replacements
                    data = data.replace(uri, imgDataUrl);
                }
            });
            for (let i = 0; i < childImageURIs.length; ++i)
                replacementPromises.push(createImagePromise(childImageURIs[i]));
            // now we create promises for the google fonts to be imported
            const createStylePromise = (styleUrl) => __awaiter(this, void 0, void 0, function* () {
                const response = (yield this._httpClient.get(styleUrl, {
                    responseType: "text",
                }));
                let cssString = response.data;
                // we assume that fonts are imported using the following syntax:
                // url(FONT_URI);
                const fontURLs = [];
                const regex = /url\(\s*(.*?)\s*\)/g;
                let m;
                while ((m = regex.exec(cssString)) !== null) {
                    fontURLs.push(m[1]);
                }
                const fontPromises = [];
                const createFontPromise = (fUrl) => __awaiter(this, void 0, void 0, function* () {
                    const response = (yield this._httpClient.get(fUrl, {
                        responseType: "arraybuffer",
                    }));
                    const uInt8Array = new Uint8Array(response.data);
                    let i = uInt8Array.length;
                    const biStr = []; //new Array(i);
                    while (i--)
                        biStr[i] = String.fromCharCode(uInt8Array[i]);
                    const base64Data = (0, base64_1.btoaCustom)(biStr.join(""));
                    const fontDataUrl = "data:" +
                        response.headers["content-type"] +
                        ";base64," +
                        base64Data;
                    if (fUrl.length > 0)
                        cssString = cssString.replace(fUrl, fontDataUrl);
                });
                for (let j = 0; j < fontURLs.length; ++j)
                    fontPromises.push(createFontPromise(fontURLs[j]));
                yield Promise.all(fontPromises);
                data = data.replace("@import url(" + styleUrl + ");", cssString);
            });
            for (let i = 0; i < styleURIs.length; ++i)
                replacementPromises.push(createStylePromise(styleURIs[i]));
            yield Promise.all(replacementPromises);
            const du = "data:image/svg+xml," + encodeURIComponent(data);
            const img = new Image(); // same as document.createElement('img')
            img.crossOrigin = "Anonymous";
            const promise = new Promise((resolve, reject) => {
                img.onload = () => resolve();
                img.onerror = reject;
            });
            img.src = du;
            yield promise;
            return img;
        });
    }
    responseToImage(response) {
        return __awaiter(this, void 0, void 0, function* () {
            // if we already receive and image, this conversion already happened
            if (response.data instanceof HTMLImageElement)
                return response.data;
            if (response.headers["content-type"] === "image/svg+xml") {
                const img = yield this.processSVG(response.data.blob);
                return img;
            }
            else {
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => resolve();
                    img.onerror = reject;
                });
                img.crossOrigin = "anonymous";
                img.src = URL.createObjectURL(response.data.blob);
                yield promise;
                URL.revokeObjectURL(img.src);
                return img;
            }
        });
    }
    toAlpha(color) {
        const c = this.toHexColor(color);
        if (c.length <= 8)
            return 1;
        return parseInt(c.slice(c.length - 2, c.length), 16) / 255;
    }
    toColorArray(color) {
        if (typeof color !== "string" || !color.startsWith("#"))
            color = this.toHexColor(color);
        const tColor = new tinycolor_1.TinyColor(color);
        const rgb = tColor.toRgb();
        return [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];
    }
    /**
     * @param color
     * @param defColor
     */
    toHex8Color(color, defColorString = "#000") {
        const c = this.toHexColor(color, defColorString);
        const tColor = new tinycolor_1.TinyColor(c);
        const cH8 = tColor.toHex8String();
        return cH8.replace("#", "0x");
    }
    /**
     * This color converter is mostly left 'as-is' from viewer v2.
     * I didn't want to break something that works.
     *
     * @param color
     * @param defColor
     */
    toHexColor(color, defColorString = "#000") {
        if (!color || color === "default")
            return defColorString;
        if (color.constructor === Float32Array)
            color = Array.from(color);
        const tColor = new tinycolor_1.TinyColor(color);
        if (color instanceof tinycolor_1.TinyColor)
            return this.tinyColorToString(tColor);
        // check if we got a number
        if (typeof color === "number") {
            let cs = color.toString(16);
            const cl = cs.length;
            if (cl < 3)
                cs = cs.padStart(3, "0");
            else if (cl < 6)
                cs = cs.padStart(6, "0");
            else if (cl < 8)
                cs = cs.padEnd(8, "0");
            const tc = new tinycolor_1.TinyColor(cs);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check if the input is a THREE.Color
        if (typeof color === "object" &&
            "isColor" in color &&
            "getHexString" in color &&
            typeof color.getHexString ===
                "function") {
            const tc = new tinycolor_1.TinyColor(color.getHexString());
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check for array of numbers
        if (Array.isArray(color) && (color.length == 3 || color.length == 4)) {
            let isRGBArray = true;
            for (let i = 0; i < 3; ++i) {
                color[i] = parseFloat(color[i]);
                if (isNaN(color[i])) {
                    isRGBArray = false;
                }
            }
            if (!isRGBArray)
                return defColorString;
            const tc = new tinycolor_1.TinyColor({
                r: Math.max(0, Math.min(color[0], 255)),
                g: Math.max(0, Math.min(color[1], 255)),
                b: Math.max(0, Math.min(color[2], 255)),
            });
            if (color.length == 4) {
                const a = parseFloat(color[3]);
                if (!isNaN(a)) {
                    tc.setAlpha(Math.max(0, Math.min(a, 255)) / 255);
                }
            }
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // if we got something other than a string, check if
        // tinycolor can work with it
        if (typeof color !== "string") {
            const tc = new tinycolor_1.TinyColor(color);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // tinycolor doesn't like 0x
        const tmpColor = color.replace("0x", "#");
        // if we got no alpha value, add full opacity
        if (tmpColor.match(/^#[a-f0-9]{6}$/i) !== null) {
            const tc = new tinycolor_1.TinyColor(tmpColor + "ff");
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // standard case
        if (tmpColor.match(/^#[a-f0-9]{8}$/i) !== null) {
            const tc = new tinycolor_1.TinyColor(tmpColor);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // correct number which have the alpha value defined as a single hex digit
        if (tmpColor.match(/^#[a-f0-9]{7}$/i) !== null) {
            const tc = new tinycolor_1.TinyColor(tmpColor.slice(0, 7) + "0" + tmpColor.slice(-1));
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        // check if tinycolor understands the string
        const tc = new tinycolor_1.TinyColor(tmpColor);
        return tc.isValid ? this.tinyColorToString(tc) : defColorString;
    }
    toThreeJsColorInput(color) {
        const c = this.toHexColor(color);
        return c.slice(0, c.length - 2);
    }
    toVec3(point) {
        if (Array.isArray(point) &&
            point.length >= 3 &&
            typeof point[0] === "number" &&
            typeof point[1] === "number" &&
            typeof point[2] === "number")
            return gl_matrix_1.vec3.fromValues(point[0], point[1], point[2]);
        const pointCast1 = point;
        if ((pointCast1.x || pointCast1.x === 0) &&
            typeof pointCast1.x === "number" &&
            (pointCast1.y || pointCast1.y === 0) &&
            typeof pointCast1.y === "number" &&
            (pointCast1.z || pointCast1.z === 0) &&
            typeof pointCast1.z === "number")
            return gl_matrix_1.vec3.fromValues(pointCast1.x, pointCast1.y, pointCast1.z);
        const pointCast2 = point;
        if ((pointCast2.X || pointCast2.X === 0) &&
            typeof pointCast2.X === "number" &&
            (pointCast2.Y || pointCast2.Y === 0) &&
            typeof pointCast2.Y === "number" &&
            (pointCast2.Z || pointCast2.Z === 0) &&
            typeof pointCast2.Z === "number")
            return gl_matrix_1.vec3.fromValues(pointCast2.X, pointCast2.Y, pointCast2.Z);
        return gl_matrix_1.vec3.create();
    }
    // #endregion Public Methods (8)
    // #region Private Methods (1)
    tinyColorToString(color) {
        return color.toHex8String();
    }
}
exports.Converter = Converter;
//# sourceMappingURL=Converter.js.map
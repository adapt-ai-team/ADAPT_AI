import { CAMERATYPE } from '@shapediver/viewer.rendering-engine.camera-engine';
import { vec2, vec3 } from 'gl-matrix';
import { Box } from '@shapediver/viewer.shared.math';
import { ICamera } from '../../../interfaces/viewer/camera/ICamera';
import { IViewer } from '../../../interfaces/viewer/IViewer';
export declare abstract class AbstractCamera implements ICamera {
    #private;
    /**
     * @ignore
     * @param camera
     */
    constructor(camera: ICamera, viewer: IViewer);
    get autoAdjust(): boolean;
    set autoAdjust(value: boolean);
    get cameraMovementDuration(): number;
    set cameraMovementDuration(value: number);
    get defaultPosition(): vec3;
    set defaultPosition(value: vec3);
    get defaultTarget(): vec3;
    set defaultTarget(value: vec3);
    get enableCameraControls(): boolean;
    set enableCameraControls(value: boolean);
    get id(): string;
    get order(): number | undefined;
    set order(value: number | undefined);
    get position(): vec3;
    set position(value: vec3);
    get revertAtMouseUp(): boolean;
    set revertAtMouseUp(value: boolean);
    get revertAtMouseUpDuration(): number;
    set revertAtMouseUpDuration(value: number);
    get target(): vec3;
    set target(value: vec3);
    get type(): CAMERATYPE;
    get zoomExtentsFactor(): number;
    set zoomExtentsFactor(value: number);
    /**
     * Let the camera follow a path from different position and target pairs to another.
     *
     * @param path the defined path
     * @param options various options to be adjusted
     * @returns
     */
    animate(path: {
        position: vec3;
        target: vec3;
    }[], options?: {
        easing?: string;
        duration?: number;
        default?: boolean;
        coordinates?: string;
        interpolation?: string;
    }): Promise<boolean>;
    /**
     * Calculate the position for our {@link zoomTo} method.
     * A specific target can be provided, as well as a specific camera startingPosition and startingTarget.
     * If no target is provided, the current bounding box is used.
     * If not startingPosition and startingTarget are provided, the current camera position and target are used.
     *
     * @param zoomTarget
     * @param startingPosition
     * @param startingTarget
     * @returns
     */
    calculateZoomTo(zoomTarget?: Box, startingPosition?: vec3, startingTarget?: vec3): {
        position: vec3;
        target: vec3;
    };
    project(p: vec3): vec2;
    /**
     * Reset the camera to its default position and target.
     *
     * @param options various options to be adjusted
     * @returns
     */
    reset(options?: {
        easing?: string;
        duration?: number;
        coordinates?: string;
        interpolation?: string;
    }): Promise<boolean>;
    /**
     * Set the camera to its a specific position and target.
     *
     * @param options various options to be adjusted
     * @returns
     */
    set(position: vec3, target: vec3, options?: {
        easing?: string;
        duration?: number;
        coordinates?: string;
        interpolation?: string;
    }): Promise<boolean>;
    unproject(p: vec3): vec3;
    /**
     * Zoom in on a specific part of the scene, or the whole scene (default).
     *
     * @param zoomTarget the target to zoom to
     * @param options various options to be adjusted
     * @returns
     */
    zoomTo(zoomTarget?: string[] | Box, options?: {
        easing?: string;
        duration?: number;
        coordinates?: string;
        interpolation?: string;
    }): Promise<boolean>;
}
//# sourceMappingURL=AbstractCamera.d.ts.map
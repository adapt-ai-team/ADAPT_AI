import { CAMERATYPE } from '@shapediver/viewer.rendering-engine.camera-engine';
import { BUSY_MODE_DISPLAY, RENDERERTYPE, SPINNER_POSITIONING, TEXTURE_ENCODING, TONE_MAPPING, VISIBILITYMODE } from '@shapediver/viewer.rendering-engine.rendering-engine';
import { DomEventEngine, IDomEventListener } from '@shapediver/viewer.shared.services';
import { vec3 } from 'gl-matrix';
import { AnimationData, SDTFAttributeVisualizationData, SDTFItemData, SDTFOverview } from '@shapediver/viewer.shared.types';
import { TreeNode } from '@shapediver/viewer.shared.node-tree';
import { ICamera } from '../../interfaces/viewer/camera/ICamera';
import { IOrthographicCamera } from '../../interfaces/viewer/camera/IOrthographicCamera';
import { IPerspectiveCamera } from '../../interfaces/viewer/camera/IPerspectiveCamera';
import { ILightScene } from '../../interfaces/viewer/lights/ILightScene';
import { IViewer } from '../../interfaces/viewer/IViewer';
export declare class Viewer implements IViewer {
    #private;
    /**
     * @ignore
     * @param id
     * @param type
     * @param canvas
     */
    constructor(properties: {
        id: string;
        canvas?: HTMLCanvasElement;
        visibility: VISIBILITYMODE;
        branding: {
            logo: string | null;
            backgroundColor: string;
            busyModeSpinner: string;
            busyModeDisplay: BUSY_MODE_DISPLAY;
            spinnerPositioning: SPINNER_POSITIONING;
        };
    });
    get ambientOcclusion(): boolean;
    set ambientOcclusion(value: boolean);
    get ambientOcclusionIntensity(): number;
    set ambientOcclusionIntensity(value: number);
    get animations(): AnimationData[];
    get automaticResizing(): boolean;
    set automaticResizing(value: boolean);
    get beautyRenderBlendingDuration(): number;
    set beautyRenderBlendingDuration(value: number);
    get beautyRenderDelay(): number;
    set beautyRenderDelay(value: number);
    get busy(): boolean;
    set busy(value: boolean);
    get camera(): ICamera | null;
    get cameras(): {
        [key: string]: ICamera;
    };
    get canvas(): HTMLCanvasElement;
    get clearAlpha(): number;
    set clearAlpha(value: number);
    get clearColor(): string | number | vec3;
    set clearColor(value: string | number | vec3);
    get closed(): boolean;
    get convertSDTFItemToVisualizationData(): ((overview: SDTFOverview, itemData?: SDTFItemData) => SDTFAttributeVisualizationData) | undefined;
    set convertSDTFItemToVisualizationData(value: ((overview: SDTFOverview, itemData?: SDTFItemData) => SDTFAttributeVisualizationData) | undefined);
    get domEventEngine(): DomEventEngine;
    get environmentMap(): string | string[];
    set environmentMap(value: string | string[]);
    get environmentMapAsBackground(): boolean;
    set environmentMapAsBackground(value: boolean);
    get environmentMapResolution(): string;
    set environmentMapResolution(value: string);
    get gridColor(): string | number | vec3;
    set gridColor(value: string | number | vec3);
    get gridVisibility(): boolean;
    set gridVisibility(value: boolean);
    get groundPlaneColor(): string | number | vec3;
    set groundPlaneColor(value: string | number | vec3);
    get groundPlaneVisibility(): boolean;
    set groundPlaneVisibility(value: boolean);
    get id(): string;
    get lightScene(): ILightScene | null;
    get lightSceneId(): string;
    set lightSceneId(value: string);
    get lightScenes(): {
        [key: string]: ILightScene;
    };
    get outputEncoding(): TEXTURE_ENCODING;
    set outputEncoding(value: TEXTURE_ENCODING);
    get physicallyCorrectLights(): boolean;
    set physicallyCorrectLights(value: boolean);
    get pointSize(): number;
    set pointSize(value: number);
    get shadows(): boolean;
    set shadows(value: boolean);
    get show(): boolean;
    set show(value: boolean);
    get showStatistics(): boolean;
    set showStatistics(value: boolean);
    get textureEncoding(): TEXTURE_ENCODING;
    set textureEncoding(value: TEXTURE_ENCODING);
    get toneMapping(): TONE_MAPPING;
    set toneMapping(value: TONE_MAPPING);
    get toneMappingExposure(): number;
    set toneMappingExposure(value: number);
    get type(): RENDERERTYPE;
    set type(value: RENDERERTYPE);
    addCameraFreezeFlag(): string;
    addCanvasEventListener(listener: IDomEventListener): string;
    addContinuousRenderingFlag(): string;
    addShadowMapUpdateFlag(): string;
    applySettings(sections?: {
        camera?: boolean;
        light?: boolean;
        scene?: boolean;
        environment?: boolean;
    }): void;
    assignCamera(id: string): void;
    assignLightScene(id: string): boolean;
    close(): Promise<boolean>;
    createCamera(type: CAMERATYPE, id?: string): ICamera;
    createLightScene(properties?: {
        name?: string;
        standard?: boolean;
    }): ILightScene;
    createOrthographicCamera(id?: string): IOrthographicCamera;
    createPerspectiveCamera(id?: string): IPerspectiveCamera;
    deregisterBusyMode(value: string): boolean;
    displayErrorMessage(message: string): void;
    getEnvironmentMapImageUrl(): string;
    getScreenshot(type?: string, quality?: number): string;
    registerBusyMode(value: string): boolean;
    removeCamera(id: string): boolean;
    removeCameraFreezeFlag(token: string): boolean;
    removeCanvasEventListener(token: string): boolean;
    removeContinuousRenderingFlag(token: string): boolean;
    removeLightScene(id: string): boolean;
    removeShadowMapUpdateFlag(token: string): boolean;
    render(): void;
    reset(): void;
    resize(width: number, height: number): void;
    update(): void;
    updateNode(node: TreeNode): void;
}
//# sourceMappingURL=Viewer.d.ts.map
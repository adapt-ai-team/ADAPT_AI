"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationEngine = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const TWEEN = __importStar(require("@tweenjs/tween.js"));
const gl_matrix_1 = require("gl-matrix");
class AnimationEngine {
    constructor() {
        // #region Properties (3)
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._animations = {};
        // #endregion Private Methods (1)
    }
    // #endregion Properties (3)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Accessors (1)
    get animations() {
        return this._animations;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (3)
    init() { }
    update(deltaTime) {
        const animations = Object.values(this._animations);
        let running = false;
        for (let i = 0; i < animations.length; i++) {
            const animation = animations[i];
            if (animation.animationTime === -1) {
                // if we just stopped we need to render one more time
                running = true;
                animation.animationTime = 0;
            }
            if (!animation.animate)
                continue;
            running = true;
            animation.animationTime += deltaTime;
            if (animation.animationTime / 1000.0 > animation.duration) {
                if (animation.repeat) {
                    animation.startAnimation();
                }
                else {
                    animation.stopAnimation();
                }
            }
            const animationDuration = animation.duration;
            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;
            for (let j = 0; j < animation.tracks.length; j++) {
                const track = animation.tracks[j];
                const id = animation.id + "_" + j;
                if (currentAnimationDeltaTime < track.times[0] ||
                    currentAnimationDeltaTime >
                        track.times[track.times.length - 1])
                    continue;
                for (let k = 1; k < track.times.length; k++) {
                    if (currentAnimationDeltaTime < track.times[k] &&
                        currentAnimationDeltaTime > track.times[k - 1]) {
                        const prevAnimation = track.node.transformations.filter((t) => t.id === id);
                        track.node.transformations =
                            track.node.transformations.filter((el) => {
                                return !prevAnimation.includes(el);
                            });
                        const factor = (currentAnimationDeltaTime - track.times[k - 1]) /
                            (track.times[k] - track.times[k - 1]);
                        let translationTransformation = track.node.transformations.find((t) => t.id === "gltf_matrix_translation");
                        if (!translationTransformation) {
                            translationTransformation = {
                                id: "gltf_matrix_translation",
                                matrix: gl_matrix_1.mat4.create(),
                            };
                            track.node.transformations.push(translationTransformation);
                        }
                        let rotationTransformation = track.node.transformations.find((t) => t.id === "gltf_matrix_rotation");
                        if (!rotationTransformation) {
                            rotationTransformation = {
                                id: "gltf_matrix_rotation",
                                matrix: gl_matrix_1.mat4.create(),
                            };
                            track.node.transformations.push(rotationTransformation);
                        }
                        let scaleTransformation = track.node.transformations.find((t) => t.id === "gltf_matrix_scale");
                        if (!scaleTransformation) {
                            scaleTransformation = {
                                id: "gltf_matrix_scale",
                                matrix: gl_matrix_1.mat4.create(),
                            };
                            track.node.transformations.push(scaleTransformation);
                        }
                        let mappedFactor = factor;
                        if (track.interpolation instanceof Function) {
                            mappedFactor = track.interpolation(factor);
                        }
                        else if (track.interpolation !== "step" &&
                            track.interpolation !== "linear") {
                            // the track.interpolation is in the dot-separated format "easingFamily.easingFunction"
                            const keys = track.interpolation.split(".");
                            // in the case this does not match the format we just use the factor as is
                            // this will result in a linear interpolation
                            if (keys.length === 2) {
                                const easingFamily = TWEEN.Easing[keys[0]];
                                if (easingFamily) {
                                    const easingFunction = easingFamily[keys[1]];
                                    if (easingFunction) {
                                        mappedFactor = easingFunction(factor);
                                    }
                                }
                            }
                        }
                        if (track.path === "rotation") {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let quaternion;
                            if (track.interpolation === "step") {
                                quaternion = gl_matrix_1.quat.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]);
                            }
                            else {
                                quaternion = gl_matrix_1.quat.slerp(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]), gl_matrix_1.vec4.fromValues(track.values[k * 4 + 0], track.values[k * 4 + 1], track.values[k * 4 + 2], track.values[k * 4 + 3]), mappedFactor);
                            }
                            const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);
                            if (pivotMatrix && pivotMatrixInverse) {
                                rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);
                            }
                            else {
                                rotationTransformation.matrix = rotationMatrix;
                            }
                        }
                        else if (track.path === "translation") {
                            let vector;
                            if (track.interpolation === "step") {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[k * 3 + 0], track.values[k * 3 + 1], track.values[k * 3 + 2]), mappedFactor);
                            }
                            translationTransformation.matrix =
                                gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);
                        }
                        else if (track.path === "scale") {
                            let pivotMatrix, pivotMatrixInverse;
                            if (track.pivot) {
                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));
                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));
                            }
                            let vector;
                            if (track.interpolation === "step") {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[k * 3 + 0], track.values[k * 3 + 1], track.values[k * 3 + 2]), mappedFactor);
                            }
                            const scalingMatrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);
                            if (pivotMatrix && pivotMatrixInverse) {
                                scaleTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, scalingMatrix), pivotMatrixInverse);
                            }
                            else {
                                scaleTransformation.matrix = scalingMatrix;
                            }
                        }
                        else if (track.path === "weights") {
                            const weights = [];
                            const weightCount = track.values.length / track.times.length;
                            if (track.interpolation === "step") {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l]);
                            }
                            else {
                                for (let l = 0; l < weightCount; l++)
                                    weights.push(track.values[(k - 1) * weightCount + l] *
                                        (1.0 - mappedFactor) +
                                        mappedFactor *
                                            track.values[(k - 1) * weightCount + l]);
                            }
                            const applyWeights = (node) => {
                                for (let l = 0; l < node.data.length; l++)
                                    if (node.data[l] instanceof viewer_shared_types_1.GeometryData &&
                                        node.data[l]
                                            .morphWeights.length === weightCount)
                                        (node.data[l]).morphWeights = weights;
                                for (let l = 0; l < node.children.length; l++)
                                    applyWeights(node.children[l]);
                            };
                            applyWeights(track.node);
                        }
                        break;
                    }
                }
            }
        }
        return running;
    }
    updateAnimationData() {
        this._animations = {};
        const animationArray = this.gatherAnimations();
        const names = animationArray.map((a) => a.name);
        for (let i = 0; i < animationArray.length; i++) {
            const animationName = animationArray[i].name;
            const nameIndices = [];
            for (let j = 0; j < names.length; j++)
                if (animationName === names[j])
                    nameIndices.push(j);
            let animationNameAdjusted = animationName;
            // name adjustement if the name occurs multiple times
            if (nameIndices.length > 1) {
                animationNameAdjusted =
                    animationName + "_" + nameIndices.indexOf(i);
                // even further name adjustement if the name is even then the same after adjustements (probably will never happen)
                while (names.includes(animationNameAdjusted))
                    animationNameAdjusted += "_0";
            }
            this._animations[animationNameAdjusted] = animationArray[i];
        }
    }
    // #endregion Public Methods (3)
    // #region Private Methods (1)
    gatherAnimations(node = this._tree.root) {
        let out = [];
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.AnimationData)
                out.push(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out = out.concat(this.gatherAnimations(node.children[i]));
        return out;
    }
}
exports.AnimationEngine = AnimationEngine;
//# sourceMappingURL=AnimationEngine.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box = void 0;
const gl_matrix_1 = require("gl-matrix");
const __1 = require("..");
class Box {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity), _max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity)) {
        this._min = _min;
        this._max = _max;
        // #region Properties (2)
        this._boundingSphere = new __1.Sphere();
        this._boundingSphereState = {
            min: gl_matrix_1.vec3.create(),
            max: gl_matrix_1.vec3.create(),
        };
    }
    // #endregion Constructors (1)
    // #region Public Accessors (5)
    intersect(origin, direction) {
        let tmin, tmax, txmin, txmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / direction[0], invdiry = 1 / direction[1], invdirz = 1 / direction[2];
        txmin =
            invdirx >= 0
                ? (this.min[0] - origin[0]) * invdirx
                : (this.max[0] - origin[0]) * invdirx;
        txmax =
            invdirx >= 0
                ? (this.max[0] - origin[0]) * invdirx
                : (this.min[0] - origin[0]) * invdirx;
        tmin = txmin;
        tmax = txmax;
        tymin =
            invdiry >= 0
                ? (this.min[1] - origin[1]) * invdiry
                : (this.max[1] - origin[1]) * invdiry;
        tymax =
            invdiry >= 0
                ? (this.max[1] - origin[1]) * invdiry
                : (this.min[1] - origin[1]) * invdiry;
        if (tmin > tymax || tymin > tmax)
            return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
        tzmin =
            invdirz >= 0
                ? (this.min[2] - origin[2]) * invdirz
                : (this.max[2] - origin[2]) * invdirz;
        tzmax =
            invdirz >= 0
                ? (this.max[2] - origin[2]) * invdirz
                : (this.min[2] - origin[2]) * invdirz;
        if (tmin > tzmax || tzmin > tmax)
            return null;
        if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0)
            return null;
        return tmin >= 0 ? tmin : tmax;
    }
    intersects(origin, direction) {
        return this.intersect(origin, direction) === null ? false : true;
    }
    get boundingSphere() {
        if (!(this._boundingSphereState.min[0] === this.min[0] &&
            this._boundingSphereState.min[1] === this.min[1] &&
            this._boundingSphereState.min[2] === this.min[2] &&
            this._boundingSphereState.max[0] === this.max[0] &&
            this._boundingSphereState.max[1] === this.max[1] &&
            this._boundingSphereState.max[2] === this.max[2])) {
            this._boundingSphere.setFromBox(this);
            this._boundingSphereState = {
                min: gl_matrix_1.vec3.clone(this.min),
                max: gl_matrix_1.vec3.clone(this.max),
            };
        }
        return this._boundingSphere;
    }
    get max() {
        return this._max;
    }
    set max(value) {
        this._max = value;
    }
    get min() {
        return this._min;
    }
    set min(value) {
        this._min = value;
    }
    // #endregion Public Accessors (5)
    // #region Public Methods (5)
    applyMatrix(matrix) {
        const points = [];
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.max[2]), matrix));
        this.min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity);
        this.max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity);
        for (let i = 0, il = points.length; i < il; i++) {
            this.min = gl_matrix_1.vec3.fromValues(Math.min(this.min[0], points[i][0]), Math.min(this.min[1], points[i][1]), Math.min(this.min[2], points[i][2]));
            this.max = gl_matrix_1.vec3.fromValues(Math.max(this.max[0], points[i][0]), Math.max(this.max[1], points[i][1]), Math.max(this.max[2], points[i][2]));
        }
        return this;
    }
    clone() {
        return new Box(gl_matrix_1.vec3.clone(this.min), gl_matrix_1.vec3.clone(this.max));
    }
    containsPoint(point) {
        return point[0] < this.min[0] ||
            point[0] > this.max[0] ||
            point[1] < this.min[1] ||
            point[1] > this.max[1] ||
            point[2] < this.min[2] ||
            point[2] > this.max[2]
            ? false
            : true;
    }
    clampPoint(point) {
        point[0] = Math.max(this.min[0], Math.min(this.max[0], point[0]));
        point[1] = Math.max(this.min[1], Math.min(this.max[1], point[1]));
        point[2] = Math.max(this.min[2], Math.min(this.max[2], point[2]));
        return point;
    }
    setFromAttributeArray(array, stride, bytes, matrix) {
        const length = Math.floor(array.length / 3) * 3;
        const byteStride = stride && stride !== bytes ? +stride : 3;
        const min = [Infinity, Infinity, Infinity];
        const max = [-Infinity, -Infinity, -Infinity];
        let x, y, z;
        const point = gl_matrix_1.vec4.create();
        for (let i = 0; i < length; i += byteStride) {
            if (matrix) {
                gl_matrix_1.vec4.transformMat4(point, [array[i], array[i + 1], array[i + 2], 1], matrix);
                x = point[0] / point[3];
                y = point[1] / point[3];
                z = point[2] / point[3];
            }
            else {
                x = array[i];
                y = array[i + 1];
                z = array[i + 2];
            }
            min[0] = Math.min(min[0], x);
            min[1] = Math.min(min[1], y);
            min[2] = Math.min(min[2], z);
            max[0] = Math.max(max[0], x);
            max[1] = Math.max(max[1], y);
            max[2] = Math.max(max[2], z);
        }
        this.min = gl_matrix_1.vec3.fromValues(min[0], min[1], min[2]);
        this.max = gl_matrix_1.vec3.fromValues(max[0], max[1], max[2]);
        return this;
    }
    union(box) {
        if (box.min[0] < this.min[0])
            this.min[0] = box.min[0];
        if (box.min[1] < this.min[1])
            this.min[1] = box.min[1];
        if (box.min[2] < this.min[2])
            this.min[2] = box.min[2];
        if (box.max[0] > this.max[0])
            this.max[0] = box.max[0];
        if (box.max[1] > this.max[1])
            this.max[1] = box.max[1];
        if (box.max[2] > this.max[2])
            this.max[2] = box.max[2];
        return this;
    }
    isEmpty() {
        return (this.min[0] === Infinity &&
            this.min[1] === Infinity &&
            this.min[2] === Infinity &&
            this.max[0] === -Infinity &&
            this.max[1] === -Infinity &&
            this.max[2] === -Infinity);
    }
    reset() {
        gl_matrix_1.vec3.zero(this._boundingSphere.center);
        this._boundingSphere.radius = 0;
        gl_matrix_1.vec3.zero(this._boundingSphereState.min);
        gl_matrix_1.vec3.zero(this._boundingSphereState.max);
        gl_matrix_1.vec3.set(this._min, Infinity, Infinity, Infinity);
        gl_matrix_1.vec3.set(this._max, -Infinity, -Infinity, -Infinity);
    }
}
exports.Box = Box;
//# sourceMappingURL=Box.js.map
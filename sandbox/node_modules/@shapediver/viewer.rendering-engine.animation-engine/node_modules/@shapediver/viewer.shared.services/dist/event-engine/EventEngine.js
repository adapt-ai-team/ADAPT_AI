"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEngine = void 0;
const Logger_1 = require("../logger/Logger");
const UuidGenerator_1 = require("../uuid-generator/UuidGenerator");
const EventTypes_1 = require("./EventTypes");
class EventEngine {
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor() {
        this._logger = Logger_1.Logger.instance;
        this._uuidGenerator = UuidGenerator_1.UuidGenerator.instance;
        this._eventListeners = {};
        for (const type in EventTypes_1.EVENTTYPE) {
            const subEventType = EventTypes_1.EVENTTYPE[type];
            this._eventListeners[type.toLowerCase()] = [];
            for (const subtype in subEventType) {
                this._eventListeners[subEventType[subtype]] = [];
            }
        }
    }
    // #endregion Constructors (1)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (3)
    /**
     * Adds a listener that listenes to the provided type. If no valid type is specified, an error is thrown.
     *
     * @param type the type of the event
     * @param cb the callback that should be called
     * @returns an unique token to be able to remove the listener
     */
    addListener(type, cb) {
        var _a;
        const typeString = this.convertTypeToString(type);
        if (!typeString)
            return "";
        const token = this._uuidGenerator.create();
        (_a = this._eventListeners[typeString]) === null || _a === void 0 ? void 0 : _a.push({ token, cb });
        return token;
    }
    /**
     * Emits the event to all callbacks that listen to the type.
     *
     * @param type the type of the event
     * @param event the event to emit
     */
    emitEvent(type, event) {
        const typeString = this.convertTypeToString(type);
        if (this._eventListeners[typeString] &&
            this._eventListeners[typeString].length !== 0) {
            const cbs = this._eventListeners[typeString].map((el) => el.cb);
            for (let i = 0; i < cbs.length; i++) {
                cbs[i](event);
            }
        }
        if (typeString.includes("."))
            this.emitEvent(typeString.substr(0, typeString.indexOf(".")), event);
    }
    /**
     * Removes a listener with the specified token.
     *
     * @param token the token of the listener
     * @returns result of the targeted operation
     */
    removeListener(token) {
        for (const type in EventTypes_1.EVENTTYPE) {
            const subEventType = EventTypes_1.EVENTTYPE[type];
            const typeLowerCase = type.toLowerCase();
            for (let i = 0; i < this._eventListeners[typeLowerCase].length; i++) {
                if (this._eventListeners[typeLowerCase][i].token === token) {
                    this._eventListeners[typeLowerCase].splice(i, 1);
                    return true;
                }
            }
            for (const subtype in subEventType) {
                for (let i = 0; i <
                    this._eventListeners[subEventType[subtype]].length; i++) {
                    if (this._eventListeners[subEventType[subtype]][i].token === token) {
                        this._eventListeners[subEventType[subtype]].splice(i, 1);
                        return true;
                    }
                }
            }
        }
        return false;
    }
    // #endregion Public Methods (3)
    // #region Private Methods (1)
    convertTypeToString(type) {
        let typeString = "";
        if (typeof type === "string")
            typeString = type;
        for (const mainType in EventTypes_1.EVENTTYPE)
            if (type === EventTypes_1.EVENTTYPE[mainType])
                typeString = mainType.toLowerCase();
        if (!typeString || !this._eventListeners[typeString]) {
            this._logger.warn("EventEngine.convertTypeToString: No valid type provided.");
            return "";
        }
        return typeString;
    }
}
exports.EventEngine = EventEngine;
//# sourceMappingURL=EventEngine.js.map
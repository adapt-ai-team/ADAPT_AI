import { SessionTreeNode } from './SessionTreeNode';
import { ISession } from '../interfaces/ISession';
import { ShapeDiverRequestGltfUploadQueryConversion, ShapeDiverResponseExport, ShapeDiverResponseOutput, ShapeDiverResponseParameter } from '@shapediver/sdk.geometry-api-sdk-v2';
export declare class Session implements ISession {
    private readonly _converter;
    private readonly _exports;
    private readonly _httpClient;
    private readonly _id;
    private readonly _logger;
    private readonly _modelViewUrl;
    private readonly _outputLoader;
    private readonly _outputs;
    private readonly _outputsFreeze;
    private readonly _parameterValues;
    private readonly _parameters;
    private readonly _performanceEvaluator;
    private readonly _sessionEngineId;
    private readonly _ticket;
    private _bearerToken?;
    private _closed;
    private _closeOnFailure;
    private _headers;
    private _initialized;
    private _modelId?;
    private _refreshBearerToken?;
    private _responseDto?;
    private _retryCounter;
    private _sdk;
    private _sessionId?;
    private _viewerSettings?;
    private _dataCache;
    /**
     * Can be use to initialize a session with the ticket and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties: {
        id: string;
        ticket: string;
        modelViewUrl: string;
        buildVersion: string;
        buildDate: string;
        closeOnFailure: () => Promise<void>;
        bearerToken?: string;
        primarySession?: boolean;
    });
    get bearerToken(): string | undefined;
    set bearerToken(value: string | undefined);
    get canUploadGLTF(): boolean;
    get exports(): {
        [key: string]: ShapeDiverResponseExport;
    };
    get id(): string;
    get initialized(): boolean;
    get modelViewUrl(): string;
    get outputs(): {
        [key: string]: ShapeDiverResponseOutput;
    };
    get outputsFreeze(): {
        [key: string]: boolean;
    };
    get parameterValues(): {
        [key: string]: string;
    };
    get parameters(): {
        [key: string]: ShapeDiverResponseParameter;
    };
    set refreshBearerToken(value: () => Promise<string>);
    get ticket(): string;
    get viewerSettings(): object | undefined;
    private handleError;
    close(retry?: boolean): Promise<boolean>;
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(cancelRequest: () => boolean): Promise<SessionTreeNode>;
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues?: {
        [key: string]: string;
    }, retry?: boolean): Promise<void>;
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest?: () => boolean, retry?: boolean): Promise<SessionTreeNode>;
    requestExport(exportId: string, parameters: {
        [key: string]: string;
    }, maxWaitTime: number, retry?: boolean): Promise<ShapeDiverResponseExport>;
    saveDefaultParameters(retry?: boolean): Promise<boolean>;
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    saveSettings(json: any, retry?: boolean): Promise<boolean>;
    uploadFile(parameterId: string, data: File, type: string, retry?: boolean): Promise<string>;
    uploadGLTF(blob: Blob, conversion?: ShapeDiverRequestGltfUploadQueryConversion, retry?: boolean): Promise<string>;
    private checkAvailability;
    private customizeSession;
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    private timeout;
    private updateResponseDto;
}
//# sourceMappingURL=Session.d.ts.map
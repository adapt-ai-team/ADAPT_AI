"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const OutputDelayException_1 = require("./OutputDelayException");
const OutputLoader_1 = require("./OutputLoader");
const SessionTreeNode_1 = require("./SessionTreeNode");
const SessionData_1 = require("./SessionData");
const sdk_geometry_api_sdk_v2_1 = require("@shapediver/sdk.geometry-api-sdk-v2");
class Session {
    // #endregion Properties (22)
    // #region Constructors (1)
    /**
     * Can be use to initialize a session with the ticket and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties) {
        // #region Properties (22)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._exports = {};
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._outputs = {};
        this._outputsFreeze = {};
        this._parameterValues = {};
        this._parameters = {};
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
        this._sessionEngineId = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator).create();
        this._closed = false;
        this._headers = {
            "X-ShapeDiver-Origin": tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo).origin,
            "X-ShapeDiver-SessionEngineId": this._sessionEngineId,
            "X-ShapeDiver-BuildVersion": '',
            "X-ShapeDiver-BuildDate": ''
        };
        this._initialized = false;
        this._retryCounter = 0;
        this._dataCache = {};
        this._id = properties.id;
        this._ticket = properties.ticket;
        this._modelViewUrl = properties.modelViewUrl;
        this._closeOnFailure = properties.closeOnFailure;
        this._bearerToken = properties.bearerToken;
        this._headers['X-ShapeDiver-BuildDate'] = properties.buildDate;
        this._headers['X-ShapeDiver-BuildVersion'] = properties.buildVersion;
        this._outputLoader = new OutputLoader_1.OutputLoader();
        this._sdk = sdk_geometry_api_sdk_v2_1.create(this._modelViewUrl, this._bearerToken);
        this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.REQUEST_HEADERS, this._headers);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (13)
    get bearerToken() {
        return this._bearerToken;
    }
    set bearerToken(value) {
        this._bearerToken = value;
        this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.JWT_TOKEN, value);
    }
    get canUploadGLTF() {
        try {
            this.checkAvailability('gltf-upload');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    get exports() {
        return this._exports;
    }
    get id() {
        return this._id;
    }
    get initialized() {
        return this._initialized;
    }
    get modelViewUrl() {
        return this._modelViewUrl;
    }
    get outputs() {
        return this._outputs;
    }
    get outputsFreeze() {
        return this._outputsFreeze;
    }
    get parameterValues() {
        return this._parameterValues;
    }
    get parameters() {
        return this._parameters;
    }
    set refreshBearerToken(value) {
        this._refreshBearerToken = value;
    }
    get ticket() {
        return this._ticket;
    }
    get viewerSettings() {
        return this._viewerSettings;
    }
    handleError(topic, scope, e, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverResponseError) {
                if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.SESSION_GONE_ERROR) {
                    // case 1: the session is no longer available
                    // we try to re-initialize the session 3 times, if that does not work, we close it
                    this._logger.warn(topic, `The session has been closed, trying to re-initialize.`);
                    if (this._retryCounter < 3) {
                        // we retry this 3 times, the `retry` option in the init function is set to true and passed on 
                        this._retryCounter = retry ? this._retryCounter + 1 : 1;
                        try {
                            this._initialized = false;
                            yield this.init(this.parameterValues, true);
                        }
                        catch (e) {
                            if (e instanceof viewer_shared_services_1.ShapeDiverViewerError || e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverError)
                                throw e;
                            throw this._logger.handleError(topic, scope, e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._logger.handleError(topic, scope, e);
                    }
                }
                else if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.JWT_VALIDATION_ERROR) {
                    // if any of the above errors occur, we try to get a new bearer token
                    // if we get a new one, we retry 3 times (by requiring new bearer tokens every time)
                    if (this._retryCounter < 3) {
                        if (this._refreshBearerToken) {
                            this.bearerToken = yield this._refreshBearerToken();
                            this._retryCounter = retry ? this._retryCounter + 1 : 1;
                            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Re-trying with new bearer token.');
                        }
                        else {
                            // no bearer tokens are supplied, we close the session
                            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'No retry possible, no new bearer token was supplied. Closing Session.');
                            try {
                                yield this._closeOnFailure();
                            }
                            catch (e) { }
                            throw this._logger.handleError(topic, scope, e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Tried to retry the connect multiple times, bearer token still not valid. Closing Session.');
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._logger.handleError(topic, scope, e);
                    }
                }
                else {
                    throw this._logger.handleError(topic, scope, e);
                }
            }
            else {
                throw this._logger.handleError(topic, scope, e);
            }
        });
    }
    // #endregion Public Accessors (13)
    // #region Public Methods (13)
    close(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('close');
            try {
                this._httpClient.removeDataLoading(this._sessionId);
                yield this._sdk.session.close(this._sessionId);
                this._closed = true;
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.close', e, retry);
                return yield this.close(true);
            }
        });
    }
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(cancelRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.customizeSession(this._parameterValues, cancelRequest);
        });
    }
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues, retry = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized === true) {
                const error = new viewer_shared_services_1.ShapeDiverViewerSessionError('Session.init: Session already initialized.');
                throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.init', error);
            }
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                this._responseDto = yield this._sdk.session.init(this._ticket, parameterValues);
                this._performanceEvaluator.endSection('sessionResponse');
                this._viewerSettings = (_a = this._responseDto.viewer) === null || _a === void 0 ? void 0 : _a.config;
                this._sessionId = this._responseDto.sessionId;
                this._modelId = (_b = this._responseDto.model) === null || _b === void 0 ? void 0 : _b.id;
                this._httpClient.addDataLoading(this._sessionId, {
                    getOutput: this._sdk.asset.getOutput.bind(this._sdk.asset),
                    getTexture: this._sdk.asset.getTexture.bind(this._sdk.asset),
                    getExport: this._sdk.asset.getExport.bind(this._sdk.asset),
                    downloadTexture: this._sdk.asset.downloadImage.bind(this._sdk.asset),
                });
                if (!this._sessionId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.init: Initialization of session failed. ResponseDto did not have a sessionId.`);
                if (!this._modelId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.init: Initialization of session failed. ResponseDto did not have a model.id.`);
                this.updateResponseDto(this._responseDto);
                this._initialized = true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.init', e, retry);
                return yield this.init(parameterValues, true);
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest = () => false, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const o = Object.assign({}, this._outputs);
            const of = Object.assign({}, this._outputsFreeze);
            try {
                const node = yield this._outputLoader.loadOutputs(this._responseDto, o, of, cancelRequest);
                node.data.push(new SessionData_1.SessionData(this._responseDto));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.loadOutputs', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                let outputMapping = {};
                for (let output in o)
                    outputMapping[output] = o[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputs(cancelRequest);
                }
                catch (e) {
                    yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.loadOutputs', e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, true);
                }
            }
        });
    }
    requestExport(exportId, parameters, maxWaitTime, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export');
            try {
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, { exports: { id: exportId }, parameters }, maxWaitTime);
                this.updateResponseDto(responseDto);
                return this.exports[exportId];
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.requestExport', e, retry);
                return yield this.requestExport(exportId, parameters, maxWaitTime, true);
            }
        });
    }
    saveDefaultParameters(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('defaultparam', true);
            try {
                yield this._sdk.model.setDefaultParams(this._modelId, this._parameterValues);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.saveDefaultParameters', e, retry);
                return yield this.saveDefaultParameters(true);
            }
        });
    }
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('export-definition', true);
            try {
                yield this._sdk.export.updateDefinitions(this._modelId, exports);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.saveExportProperties', e, retry);
                return yield this.saveExportProperties(exports, true);
            }
        });
    }
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('output-definition', true);
            try {
                yield this._sdk.output.updateDefinitions(this._modelId, outputs);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.saveOutputProperties', e, retry);
                return yield this.saveOutputProperties(outputs, true);
            }
        });
    }
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('parameter-definition', true);
            try {
                yield this._sdk.model.updateParameterDefinitions(this._modelId, parameters);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.saveParameterProperties', e, retry);
                return yield this.saveParameterProperties(parameters, true);
            }
        });
    }
    saveSettings(json, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('configure', true);
            try {
                yield this._sdk.model.updateConfig(this._modelId, json);
                return true;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.saveSettings', e, retry);
                return yield this.saveSettings(json, true);
            }
        });
    }
    uploadFile(parameterId, data, type, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('file-upload');
            try {
                const responseDto = yield this._sdk.file.requestUpload(this._sessionId, {
                    [parameterId]: { size: data.size, format: type }
                });
                if (responseDto && responseDto.asset && responseDto.asset.file && responseDto.asset.file[parameterId]) {
                    const fileAsset = responseDto.asset.file[parameterId];
                    yield this._sdk.utils.upload(fileAsset.href, yield data.arrayBuffer(), type);
                    return fileAsset.id;
                }
                else {
                    const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.uploadFile: Upload reply has not the required format.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.uploadFile', error);
                }
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.uploadFile', e, retry);
                return yield this.uploadFile(parameterId, data, type, true);
            }
        });
    }
    uploadGLTF(blob, conversion = sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.NONE, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('gltf-upload');
            try {
                const responseDto = yield this._sdk.gltf.upload(this._sessionId, yield blob.arrayBuffer(), 'model/gltf-binary', conversion);
                if (!responseDto || !responseDto.gltf || !responseDto.gltf.href) {
                    const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.uploadGLTF: Upload reply has not the required format.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.uploadGLTF', error);
                }
                return responseDto.gltf.href;
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.uploadGLTF', e, retry);
                return yield this.uploadGLTF(blob, conversion, true);
            }
        });
    }
    // #endregion Public Methods (13)
    // #region Private Methods (5)
    checkAvailability(action, checkForModelId = false) {
        var _a;
        if (!this._responseDto) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: responseDto not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (!this._sessionId) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: sessionId not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (checkForModelId && !this._modelId) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: modelId not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.checkAvailability', error);
        }
        if (action && !this._responseDto.actions) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: actions not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.checkAvailability', error);
        }
        const responseDtoAction = (_a = this._responseDto.actions) === null || _a === void 0 ? void 0 : _a.find(a => a.name === action);
        if (action && !responseDtoAction) {
            const error = new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: action ${action} not available.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.checkAvailability', error);
        }
    }
    customizeSession(parameters, cancelRequest, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability('customize');
            try {
                this._performanceEvaluator.startSection('sessionResponse');
                const responseDto = yield this._sdk.utils.submitAndWaitForCustomization(this._sdk, this._sessionId, parameters);
                this._performanceEvaluator.endSection('sessionResponse');
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                this.updateResponseDto(responseDto);
                return this.loadOutputs(cancelRequest);
            }
            catch (e) {
                yield this.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'Session.customizeSession', e, retry);
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                return yield this.customizeSession(parameters, cancelRequest, true);
            }
        });
    }
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    timeout(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => setTimeout(resolve, ms));
        });
    }
    updateResponseDto(responseDto) {
        if (!this._responseDto) {
            this._responseDto = responseDto;
            return;
        }
        // convert parameters
        if (responseDto.parameters) {
            for (let parameterId in responseDto.parameters) {
                this._responseDto.parameters = this._responseDto.parameters || {};
                this._responseDto.parameters[parameterId] = this._responseDto.parameters[parameterId] || responseDto.parameters[parameterId];
            }
        }
        // convert outputs
        if (responseDto.outputs) {
            for (let outputId in responseDto.outputs) {
                this._responseDto.outputs = this._responseDto.outputs || {};
                if ('version' in responseDto.outputs[outputId] || !(this._responseDto.outputs[outputId] && 'version' in this._responseDto.outputs[outputId]))
                    this._responseDto.outputs[outputId] = responseDto.outputs[outputId];
            }
        }
        // convert exports
        if (responseDto.exports) {
            for (let exportId in responseDto.exports) {
                this._responseDto.exports = this._responseDto.exports || {};
                if ('version' in responseDto.exports[exportId] || !(this._responseDto.exports[exportId] && 'version' in this._responseDto.exports[exportId]))
                    this._responseDto.exports[exportId] = responseDto.exports[exportId];
            }
        }
        for (let parameterId in this._responseDto.parameters) {
            if (this.parameters[parameterId])
                continue;
            this.parameters[parameterId] = this._responseDto.parameters[parameterId];
            this.parameters[parameterId].id = parameterId;
        }
        for (let exportId in this._responseDto.exports)
            if (this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.EMAIL || this._responseDto.exports[exportId].type === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.DOWNLOAD) {
                this.exports[exportId] = this._responseDto.exports[exportId];
                this.exports[exportId].id = exportId;
            }
        for (let outputId in this._responseDto.outputs) {
            this.outputs[outputId] = this._responseDto.outputs[outputId];
            this.outputs[outputId].id = outputId;
            if (this.outputsFreeze[outputId] === undefined)
                this.outputsFreeze[outputId] = false;
        }
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const sdk_geometry_api_sdk_v2_1 = require("@shapediver/sdk.geometry-api-sdk-v2");
const axios_1 = __importDefault(require("axios"));
const Converter_1 = require("../converter/Converter");
const Logger_1 = require("../logger/Logger");
const ShapeDiverBackendErrors_1 = require("../logger/ShapeDiverBackendErrors");
const base64_1 = require("../utilities/base64");
class HttpClient {
    // #endregion Properties (7)
    // #region Constructors (1)
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() {
        // #region Properties (7)
        this._logger = Logger_1.Logger.instance;
        this._dataCache = new Map();
        this._enableCaching = true;
        this._excludedQueryParameters = [
            "Expires",
            "Signature",
            "Key-Pair-Id",
        ];
        this._maxCacheSize = 1024 * 1024 * 32;
        this._sessionLoading = {};
    }
    // #endregion Constructors (1)
    // #region Public Static Getters And Setters (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Getters And Setters (1)
    // #region Public Getters And Setters (6)
    get enableCaching() {
        return this._enableCaching;
    }
    set enableCaching(value) {
        this._enableCaching = value;
        if (this._enableCaching === false)
            this._dataCache.clear();
    }
    get excludedQueryParameters() {
        return this._excludedQueryParameters;
    }
    set excludedQueryParameters(value) {
        this._excludedQueryParameters = value;
    }
    get maxCacheSize() {
        return this._maxCacheSize;
    }
    set maxCacheSize(value) {
        this._maxCacheSize = value;
    }
    // #endregion Public Getters And Setters (6)
    // #region Public Methods (5)
    /**
     * Add the data loading options from a session.
     *
     * @param sessionId
     * @param callbacks
     */
    addDataLoading(sessionId, callbacks) {
        this._sessionLoading[sessionId] = callbacks;
    }
    /**
     * Maps the geometry backend error to the corresponding viewer errors:
     * - ShapeDiverResponseError is mapped to ShapeDiverGeometryBackendResponseError
     * - ShapeDiverRequestError is mapped to ShapeDiverGeometryBackendRequestError
     *
     * Other error types are thrown as is.
     *
     * @param e
     */
    convertError(e) {
        if ((0, sdk_geometry_api_sdk_v2_1.isGBResponseError)(e)) {
            throw new ShapeDiverBackendErrors_1.ShapeDiverGeometryBackendResponseError(e.message, e.status, e.error, e.desc);
        }
        else if ((0, sdk_geometry_api_sdk_v2_1.isGBRequestError)(e)) {
            throw new ShapeDiverBackendErrors_1.ShapeDiverGeometryBackendRequestError(e.message, e.desc);
        }
        else if ((0, sdk_geometry_api_sdk_v2_1.isGBError)(e)) {
            throw new ShapeDiverBackendErrors_1.ShapeDiverGeometryBackendError(e.message);
        }
        else {
            throw e;
        }
    }
    /**
     * Get the requested resource either as a download or from the cache.
     * If available, the registered session loading is used for download.
     * Textures are downloaded via a specific endpoint and can be converted in this step as well.
     * Depending on the provided caching options, the requested resource might already be cached.
     *
     * @param href
     * @param config
     * @param textureLoading
     * @param textureConversion
     * @returns
     */
    get(href, config = { responseType: "arraybuffer" }, textureLoading = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataKey = this.hrefToDataKey(href);
            // return element if it exists in cache
            if (this._dataCache.has(dataKey))
                return this.getFromCache(dataKey);
            // try to get sessionId from href
            let sessionId = this.getSessionId(href);
            // if href does not have sessionId, use the first session, if available
            if (!sessionId && Object.keys(this._sessionLoading).length > 0)
                sessionId = Object.keys(this._sessionLoading)[0];
            // get the session loading functions, if available
            let sessionLoading;
            if (sessionId)
                sessionLoading = this._sessionLoading[sessionId];
            let loadingPromise;
            // separation texture vs everything else
            if (textureLoading) {
                // if we have a sessionId and the sessionLoading functions and the image is not a blob or data, we load it via the sdk
                if (sessionLoading !== undefined &&
                    sessionId !== undefined &&
                    !href.startsWith("blob:") &&
                    !href.startsWith("data:")) {
                    // take first session to load a texture that is not session related
                    loadingPromise = new Promise((resolve, reject) => {
                        sessionLoading
                            .downloadTexture(sessionId, href)
                            .then((result) => __awaiter(this, void 0, void 0, function* () {
                            resolve({
                                data: result[0],
                                headers: {
                                    "content-type": result[1],
                                },
                            });
                        }))
                            .catch((e) => reject(e));
                    }).catch((e) => {
                        throw this.convertError(e);
                    });
                }
                else {
                    // we can load blobs and data urls directly
                    // or load it directly if we don't have a session
                    loadingPromise = (0, axios_1.default)(href, Object.assign({ method: "get" }, config))
                        .then((result) => __awaiter(this, void 0, void 0, function* () {
                        return result;
                    }))
                        .catch((e) => {
                        throw this.convertError(e);
                    });
                }
            }
            else {
                if (!sessionLoading) {
                    // if there is no session to load from, we use the fallback option
                    loadingPromise = (0, axios_1.default)(href, Object.assign({ method: "get" }, config)).catch((e) => {
                        throw this.convertError(e);
                    });
                }
                else {
                    // all data links where we could somehow find a session to load it with
                    loadingPromise = new Promise((resolve, reject) => {
                        sessionLoading
                            .getAsset(href)
                            .then((result) => {
                            resolve({
                                data: result[0],
                                headers: {
                                    "content-type": result[1],
                                },
                            });
                        })
                            .catch(() => {
                            // if this fails, we just load it directly
                            const axiosPromise = (0, axios_1.default)(href, Object.assign({ method: "get" }, config));
                            axiosPromise.catch((e) => reject(e));
                            resolve(axiosPromise);
                        });
                    }).catch((e) => {
                        throw this.convertError(e);
                    });
                }
            }
            if (this.enableCaching)
                this.addToCache(dataKey, loadingPromise);
            return loadingPromise;
        });
    }
    /**
     * Get the requested texture either as a download or from the cache.
     * If the texture is not available, undefined is returned.
     *
     * @param href The URL of the texture to load.
     * @returns Either the texture as a buffer and blob or undefined if the texture could not be loaded.
     */
    loadTexture(href) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataKey = this.hrefToDataKey(href);
            // return element if it exists in cache
            if (this._dataCache.has(dataKey))
                return this.getFromCache(dataKey);
            let loadingPromise;
            try {
                loadingPromise = this.get(href, undefined, true).then((response) => __awaiter(this, void 0, void 0, function* () {
                    const buffer = response.data;
                    const arrayBufferView = new Uint8Array(response.data);
                    const blob = new Blob([arrayBufferView], {
                        type: response.headers["content-type"],
                    });
                    if (typeof window !== "undefined") {
                        const image = yield Converter_1.Converter.instance.responseToImage({
                            data: {
                                buffer,
                                blob,
                            },
                            size: response.data.byteLength,
                            headers: response.headers,
                        });
                        return {
                            data: {
                                image,
                                buffer,
                                blob,
                            },
                            size: response.data.byteLength,
                            headers: response.headers,
                        };
                    }
                    else {
                        return {
                            data: {
                                buffer,
                                blob,
                            },
                            size: response.data.byteLength,
                            headers: response.headers,
                        };
                    }
                }));
                const dataKey = this.hrefToDataKey(href);
                // add the result to the cache
                this.addToCache(dataKey, loadingPromise);
            }
            catch (e) {
                // log the error and return undefined
                this._logger.error(`Failed to load texture: ${e}`);
            }
            // return undefined if the texture could not be loaded
            // that way the loading can be continued without the texture
            return loadingPromise;
        });
    }
    /**
     * Add the data loading options from a session.
     *
     * @param sessionId
     */
    removeDataLoading(sessionId) {
        delete this._sessionLoading[sessionId];
    }
    // #endregion Public Methods (5)
    // #region Private Methods (5)
    /**
     * Add
     *
     * @param key
     * @param value
     */
    addToCache(key, value) {
        // Remove items from the cache until the cache size is smaller than the maximum cache size.
        // Only resolved promises are evaluated, as unresolved promises don't add any size.
        let oldestKey = this._dataCache.keys().next().value;
        while (this.calculateCacheSize() >= this._maxCacheSize && oldestKey) {
            // Remove the oldest entry if the cache is full
            this._dataCache.delete(oldestKey);
            oldestKey = this._dataCache.keys().next().value;
        }
        const timestamp = Date.now();
        this._dataCache.set(key, { value, timestamp, resolved: false });
        // once the promise resolves, set resolved and size properties
        value
            .then((promiseResult) => {
            const size = promiseResult.size
                ? promiseResult.size
                : promiseResult.data.byteLength;
            this._dataCache.set(key, {
                value,
                timestamp,
                resolved: true,
                size,
            });
        })
            .catch((e) => {
            throw this.convertError(e);
        });
    }
    /**
     * Calculate the current cache size from all resolved promises.
     *
     * @returns
     */
    calculateCacheSize() {
        let size = 0;
        this._dataCache.forEach((value) => {
            if (value.resolved === true)
                size += value.size;
        });
        return size;
    }
    /**
     * Get the value of an object from the cache.
     *
     * @param key
     * @returns
     */
    getFromCache(key) {
        const cachedObject = this._dataCache.get(key);
        this._dataCache.set(key, {
            value: cachedObject.value,
            timestamp: Date.now(),
            resolved: cachedObject.resolved,
            size: cachedObject.size,
        });
        return cachedObject.value;
    }
    /**
     * Get the session id of the provided href.
     *
     * @param href
     * @returns
     */
    getSessionId(href) {
        // searching for "/session/SESSION_ID/{'output' | 'export' | 'texture'}/ASSET_DATA"
        const parts = href.split("/");
        const sessionPartIndex = parts.indexOf("session");
        // There have to be at exactly 4 parts, including the session
        if (sessionPartIndex !== -1 && parts.length === sessionPartIndex + 4) {
            const sessionId = parts[sessionPartIndex + 1];
            // no such session has been registered, should never happen
            if (!this._sessionLoading[sessionId])
                return;
            return sessionId;
        }
        return;
    }
    /**
     * Convert the provided href to a data cache key.
     * In this conversion the excludedQueryParameters are removed from the href.
     *
     * @param href
     * @returns
     */
    hrefToDataKey(href) {
        const url = new URL(href);
        // Create a URLSearchParams object from the existing query parameters
        const params = new URLSearchParams(url.search);
        for (let i = 0; i < this._excludedQueryParameters.length; i++)
            // Remove specific query parameters
            params.delete(this._excludedQueryParameters[i]);
        // Reconstruct the URL with the modified query parameters
        url.search = params.toString();
        const hrefAsKey = url.toString();
        return (0, base64_1.btoaCustom)(hrefAsKey);
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpClient.js.map
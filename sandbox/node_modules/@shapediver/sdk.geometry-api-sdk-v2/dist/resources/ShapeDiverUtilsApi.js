"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeDiverUtilsApi = void 0;
const sdk_geometry_api_sdk_core_1 = require("@shapediver/sdk.geometry-api-sdk-core");
const utils_1 = require("../utils/utils");
class ShapeDiverUtilsApi extends sdk_geometry_api_sdk_core_1.BaseResourceApi {
    constructor(api) {
        super(api);
    }
    upload(url, data, contentType, filename) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return this.api.put(url, undefined, data, {
                    contentType: contentType,
                    contentDisposition: filename
                        ? (0, utils_1.contentDispositionFromFilename)(filename)
                        : undefined,
                    responseType: sdk_geometry_api_sdk_core_1.ShapeDiverSdkApiResponseType.JSON,
                    disableAuthorization: true,
                    disableCustomHeaders: true,
                });
            }));
        });
    }
    uploadAsset(url, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return this.api.put(url, undefined, data, {
                    contentType: headers.contentType,
                    contentDisposition: headers.contentDisposition,
                    responseType: sdk_geometry_api_sdk_core_1.ShapeDiverSdkApiResponseType.JSON,
                    disableAuthorization: true,
                    disableCustomHeaders: true,
                });
            }));
        });
    }
    download(url, responseType) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () {
                return this.api.get(url, undefined, {
                    contentType: "application/json",
                    responseType: responseType,
                    disableAuthorization: true,
                    disableCustomHeaders: true,
                });
            }));
        });
    }
    submitAndWaitForCustomization(sdk_1, sessionId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (sdk, sessionId, body, maxWaitMsec = -1) {
            const startMsec = Date.now();
            const dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.output.customize(sessionId, body); }));
            const waitMsec = Date.now() - startMsec;
            maxWaitMsec =
                maxWaitMsec < 0 ? maxWaitMsec : Math.max(0, maxWaitMsec - waitMsec);
            return ShapeDiverUtilsApi.waitForCustomizationResult(sdk, sessionId, dto, maxWaitMsec);
        });
    }
    submitAndWaitForExport(sdk_1, sessionId_1, body_1) {
        return __awaiter(this, arguments, void 0, function* (sdk, sessionId, body, maxWaitMsec = -1) {
            const startMsec = Date.now();
            const dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.export.compute(sessionId, body); }));
            const waitMsec = Date.now() - startMsec;
            maxWaitMsec =
                maxWaitMsec < 0 ? maxWaitMsec : Math.max(0, maxWaitMsec - waitMsec);
            return ShapeDiverUtilsApi.waitForExportResult(sdk, sessionId, body, dto, maxWaitMsec);
        });
    }
    static waitForCustomizationResult(sdk_1, sessionId_1, dto_1) {
        return __awaiter(this, arguments, void 0, function* (sdk, sessionId, dto, maxWaitMsec = -1) {
            if (!dto.outputs)
                return dto;
            const outputVersions = {};
            Object.keys(dto.outputs).forEach((id) => (outputVersions[id] = dto.outputs[id].version));
            let delay = ShapeDiverUtilsApi.getMaxOutputDelay(dto);
            const startMsec = Date.now();
            while (delay > 0) {
                if (maxWaitMsec >= 0) {
                    const waitMsec = Date.now() - startMsec;
                    if (waitMsec >= maxWaitMsec) {
                        throw new sdk_geometry_api_sdk_core_1.ShapeDiverError(`Maximum wait time of ${maxWaitMsec} ms reached`);
                    }
                    if (waitMsec + delay > maxWaitMsec) {
                        delay = maxWaitMsec - waitMsec;
                    }
                }
                yield (0, utils_1.sleep)(delay);
                dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.output.getCache(sessionId, outputVersions); }));
                delay = ShapeDiverUtilsApi.getMaxOutputDelay(dto);
            }
            return dto;
        });
    }
    static waitForExportResult(sdk_1, sessionId_1, body_1, dto_1) {
        return __awaiter(this, arguments, void 0, function* (sdk, sessionId, body, dto, maxWaitMsec = -1) {
            let delay = ShapeDiverUtilsApi.getMaxExportDelay(dto, body);
            const startMsec = Date.now();
            while (delay > 0) {
                if (maxWaitMsec >= 0) {
                    const waitMsec = Date.now() - startMsec;
                    if (waitMsec >= maxWaitMsec) {
                        throw new sdk_geometry_api_sdk_core_1.ShapeDiverError(`Maximum wait time of ${maxWaitMsec} ms reached`);
                    }
                    if (waitMsec + delay > maxWaitMsec) {
                        delay = maxWaitMsec - waitMsec;
                    }
                }
                yield (0, utils_1.sleep)(delay);
                dto = yield (0, utils_1.sendRequest)(() => __awaiter(this, void 0, void 0, function* () { return sdk.export.getCache(sessionId, body); }));
                delay = ShapeDiverUtilsApi.getMaxExportDelay(dto, body);
            }
            return dto;
        });
    }
    static getMaxOutputDelay(dto) {
        return Math.max(...Object.values(dto.outputs)
            .map((output) => output)
            .map((output) => { var _a; return (_a = output.delay) !== null && _a !== void 0 ? _a : -1; }));
    }
    static getMaxExportDelay(dto, body) {
        var _a, _b, _c;
        const exports = Array.isArray(body.exports)
            ? body.exports
            : [body.exports.id];
        const outputs = (_a = body.outputs) !== null && _a !== void 0 ? _a : [];
        return Math.max(...Object.values((_b = dto.exports) !== null && _b !== void 0 ? _b : {})
            .filter((e) => exports.includes(e.id))
            .map((e) => e)
            .map((e) => { var _a; return (_a = e.delay) !== null && _a !== void 0 ? _a : -1; }), ...Object.values((_c = dto.outputs) !== null && _c !== void 0 ? _c : {})
            .filter((o) => outputs.includes(o.id))
            .map((o) => o)
            .map((o) => { var _a; return (_a = o.delay) !== null && _a !== void 0 ? _a : -1; }));
    }
}
exports.ShapeDiverUtilsApi = ShapeDiverUtilsApi;
//# sourceMappingURL=ShapeDiverUtilsApi.js.map
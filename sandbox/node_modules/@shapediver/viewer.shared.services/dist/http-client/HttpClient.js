"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const axios_1 = __importDefault(require("axios"));
const tsyringe_1 = require("tsyringe");
const ShapeDiverViewerErrors_1 = require("../logger/ShapeDiverViewerErrors");
let HttpClient = class HttpClient {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor() {
        // #region Properties (2)
        this._dataCache = {};
        this._sessionLoading = {};
        axios_1.default.interceptors.response.use(response => {
            return response;
        }, error => {
            throw new ShapeDiverViewerErrors_1.ShapeDiverViewerConnectionError(error.message, error.response.status, error);
        });
        axios_1.default.interceptors.request.use(response => {
            return response;
        }, error => {
            throw new ShapeDiverViewerErrors_1.ShapeDiverViewerConnectionError(error.message, undefined, error);
        });
    }
    // #endregion Constructors (1)
    // #region Public Methods (7)
    loadingCriterion(href) {
        // searching for "/session/SESSION_ID/{'output' | 'export' | 'texture'}/ASSET_DATA"
        const parts = href.split('/');
        const sessionPartIndex = parts.indexOf('session');
        // There have to be at exactly 4 parts, including the session
        if (sessionPartIndex !== -1 && parts.length === sessionPartIndex + 4) {
            const sessionId = parts[sessionPartIndex + 1];
            // no such session has been registered, should never happen
            if (!this._sessionLoading[sessionId])
                return;
            const type = parts[sessionPartIndex + 2];
            // the type is not supported
            if (type !== 'output' && type !== 'export' && type !== 'texture')
                return;
            const assetData = parts[sessionPartIndex + 3];
            return { sessionId, assetData, type };
        }
        return;
    }
    addDataLoading(sessionId, callbacks) {
        this._sessionLoading[sessionId] = callbacks;
    }
    get(href, config = { responseType: 'arraybuffer' }, textureLoading = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const dataKey = btoa(href);
            if (this._dataCache[dataKey])
                return yield this._dataCache[dataKey];
            const loadingInfo = this.loadingCriterion(href);
            if (loadingInfo) {
                switch (loadingInfo.type) {
                    case 'output':
                        this._dataCache[dataKey] = new Promise(resolve => {
                            this._sessionLoading[loadingInfo.sessionId]
                                .getOutput(loadingInfo.sessionId, loadingInfo.assetData)
                                .then(result => {
                                resolve({
                                    data: result[0],
                                    headers: {
                                        'content-type': result[1]
                                    }
                                });
                            });
                        });
                        break;
                    case 'export':
                        this._dataCache[dataKey] = new Promise(resolve => {
                            this._sessionLoading[loadingInfo.sessionId]
                                .getExport(loadingInfo.sessionId, loadingInfo.assetData)
                                .then(result => {
                                resolve({
                                    data: result[0],
                                    headers: {
                                        'content-type': result[1]
                                    }
                                });
                            });
                        });
                        break;
                    case 'texture':
                        this._dataCache[dataKey] = new Promise(resolve => {
                            this._sessionLoading[loadingInfo.sessionId]
                                .getTexture(loadingInfo.sessionId, loadingInfo.assetData)
                                .then(result => {
                                resolve({
                                    data: result[0],
                                    headers: {
                                        'content-type': result[1]
                                    }
                                });
                            });
                        });
                        break;
                    default:
                        this._dataCache[dataKey] = axios_1.default(href, Object.assign({ method: 'get' }, config));
                }
            }
            else {
                // separation texture vs something else...
                if (textureLoading) {
                    // we can load blobs and data urls directly
                    // if no session is registered, we have to load the texture directly
                    if (href.startsWith('blob:') || href.startsWith('data:') || Object.values(this._sessionLoading).length === 0) {
                        this._dataCache[dataKey] = axios_1.default(href, Object.assign({ method: 'get' }, config));
                    }
                    else {
                        // take first session to load a texture that is not session related
                        const sessionId = Object.keys(this._sessionLoading)[0];
                        this._dataCache[dataKey] = new Promise(resolve => {
                            this._sessionLoading[sessionId].downloadTexture(sessionId, href).then((result) => {
                                resolve({
                                    data: result[0],
                                    headers: {
                                        'content-type': result[1]
                                    }
                                });
                            });
                        });
                    }
                }
                else {
                    this._dataCache[dataKey] = axios_1.default(href, Object.assign({ method: 'get' }, config));
                }
            }
            return this._dataCache[dataKey];
        });
    }
    loadTexture(href) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(href, undefined, true);
        });
    }
    removeDataLoading(sessionId) {
        delete this._sessionLoading[sessionId];
    }
};
HttpClient = __decorate([
    tsyringe_1.singleton(),
    __metadata("design:paramtypes", [])
], HttpClient);
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpClient.js.map
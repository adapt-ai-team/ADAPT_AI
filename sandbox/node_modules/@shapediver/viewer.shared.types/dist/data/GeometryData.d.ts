import { mat4, vec3 } from 'gl-matrix';
import { AbstractTreeNodeData, ITreeNodeData, TreeNode } from '@shapediver/viewer.shared.node-tree';
import { Box } from '@shapediver/viewer.shared.math';
import { AbstractMaterialData } from './material/AbstractMaterialData';
export declare enum PRIMITIVE_MODE {
    POINTS = 0,
    LINES = 1,
    LINE_LOOP = 2,
    LINE_STRIP = 3,
    TRIANGLES = 4,
    TRIANGLE_STRIP = 5,
    TRIANGLE_FAN = 6
}
export declare class AttributeData {
    #private;
    /**
     * Creates an attribute data object.
     *
     * @param _array the array of the data
     * @param _itemSize the size
     * @param _hasOffset notifier if there is an offset
     * @param _offset the offset
     * @param _stride the stride
     * @param _normalized boolean if the data is normalized
     */
    constructor(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, itemSize: number, itemBytes: number, byteOffset: number, elementBytes: number, normalized: boolean, count: number, min?: number[], max?: number[], byteStride?: number, sparse?: boolean, sparseIndices?: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, sparseValues?: Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array, morphAttributeData?: AttributeData[]);
    get array(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array;
    get byteOffset(): number;
    get byteStride(): number | undefined;
    get count(): number;
    get elementBytes(): number;
    get itemBytes(): number;
    get itemSize(): number;
    get max(): number[];
    get min(): number[];
    get morphAttributeData(): AttributeData[];
    get normalized(): boolean;
    get sparse(): boolean | undefined;
    get sparseIndices(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array | undefined;
    get sparseValues(): Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array | undefined;
    /**
     * Clones the attribute data.
     */
    clone(): AttributeData;
}
export declare class PrimitiveData {
    #private;
    /**
     * Creates a primitive data object.
     *
     * @param _attributes the attributes as key-value pairs
     * @param _indices the indices
     */
    constructor(attributes?: {
        [key: string]: AttributeData;
    }, mode?: PRIMITIVE_MODE, indices?: AttributeData | null, material?: AbstractMaterialData | null, attributeMaterial?: AbstractMaterialData | null);
    get attributes(): {
        [key: string]: AttributeData;
    };
    get boundingBox(): Box;
    get indices(): AttributeData | null;
    set indices(value: AttributeData | null);
    get standardMaterial(): AbstractMaterialData | null;
    set standardMaterial(value: AbstractMaterialData | null);
    get material(): AbstractMaterialData | null;
    set material(value: AbstractMaterialData | null);
    get effectMaterials(): {
        material: AbstractMaterialData;
        token: string;
    }[];
    get materialVariants(): {
        material: AbstractMaterialData;
        variant: number;
    }[];
    get attributeMaterial(): AbstractMaterialData | null;
    set attributeMaterial(value: AbstractMaterialData | null);
    get mode(): PRIMITIVE_MODE;
    /**
     * Clones the primitive data.
     */
    clone(): PrimitiveData;
}
export declare class GeometryData extends AbstractTreeNodeData {
    #private;
    /**
     * Creates a geometry data object.
     *
     * @param _primitive the primitive
     * @param _matrix the matrix to apply
     * @param id the id
     */
    constructor(primitive: PrimitiveData, matrix?: mat4, id?: string, morphWeights?: number[], bones?: TreeNode[], boneInverses?: mat4[]);
    get boundingBox(): Box;
    get matrix(): mat4;
    get primitive(): PrimitiveData;
    get renderOrder(): number;
    set renderOrder(value: number);
    get morphWeights(): number[];
    set morphWeights(value: number[]);
    get bones(): TreeNode[];
    set bones(value: TreeNode[]);
    get boneInverses(): mat4[];
    set boneInverses(value: mat4[]);
    /**
     * Clones the scene graph data.
     */
    clone(): ITreeNodeData;
    intersect(origin: vec3, direction: vec3): number | null;
}
//# sourceMappingURL=GeometryData.d.ts.map
import { Box } from '@shapediver/viewer.shared.math';
import { AbstractTreeNodeData, ITreeNodeData } from '@shapediver/viewer.shared.node-tree';
import { vec2, vec3 } from 'gl-matrix';
export interface AnchorDataImage {
    alt: string;
    height: number;
    hidden?: boolean;
    position?: {
        horizontal?: string;
        vertical?: string;
    };
    src: string;
    width: number;
}
export interface AnchorDataText {
    color: string | number | vec3;
    hidden?: boolean;
    position?: {
        horizontal?: string;
        vertical?: string;
    };
    text: string;
    textAlign?: string;
}
export declare abstract class HTMLElementAnchorData extends AbstractTreeNodeData {
    #private;
    protected internalHtmlElement: HTMLDivElement;
    /**
     * Creates a custom data node.
     *
     * @param _data the data as key- value pairs
     * @param id the id
     */
    constructor(properties: {
        location: vec3;
        data: AnchorDataImage | AnchorDataText | any;
        format: 'text' | 'image' | 'custom';
        hideable?: boolean;
        viewers?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    get data(): AnchorDataImage | AnchorDataText | any;
    set data(value: AnchorDataImage | AnchorDataText | any);
    get format(): 'text' | 'image' | 'custom';
    set format(value: 'text' | 'image' | 'custom');
    get hideable(): boolean;
    set hideable(value: boolean);
    get intersectionTarget(): Box | string | string[] | undefined;
    set intersectionTarget(value: Box | string | string[] | undefined);
    get location(): vec3;
    set location(value: vec3);
    get viewers(): string[];
    set viewers(value: string[]);
    createViewerHtmlElement(viewer: string): HTMLDivElement | null;
    getViewerHtmlElement(viewer: string): HTMLDivElement | null;
    abstract create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
    update(properties: {
        anchor: HTMLElementAnchorData;
        htmlElement: HTMLDivElement;
        page: vec2;
        container: vec2;
        client: vec2;
        scale: vec2;
        hidden: boolean;
    }): void;
    /**
     * Clones the scene graph data.
     */
    abstract clone(): ITreeNodeData;
}
export declare class HTMLElementAnchorTextData extends HTMLElementAnchorData {
    constructor(properties: {
        location: vec3;
        data: AnchorDataText;
        hideable?: boolean;
        viewers?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    clone(): ITreeNodeData;
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
}
export declare class HTMLElementAnchorImageData extends HTMLElementAnchorData {
    constructor(properties: {
        location: vec3;
        data: AnchorDataImage;
        hideable?: boolean;
        viewers?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
    });
    clone(): ITreeNodeData;
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
}
export declare class HTMLElementAnchorCustomData extends HTMLElementAnchorData {
    #private;
    constructor(properties: {
        location: vec3;
        data: any;
        hideable?: boolean;
        viewers?: string[];
        intersectionTarget?: Box | string | string[];
        id?: string;
        create: (properties: {
            anchor: HTMLElementAnchorData;
            parent: HTMLDivElement;
        }) => void;
        update: (properties: {
            anchor: HTMLElementAnchorData;
            htmlElement: HTMLDivElement;
            page: vec2;
            container: vec2;
            client: vec2;
            scale: vec2;
            hidden: boolean;
        }) => void;
    });
    create(properties: {
        anchor: HTMLElementAnchorData;
        parent: HTMLDivElement;
    }): void;
    update(properties: {
        anchor: HTMLElementAnchorData;
        htmlElement: HTMLDivElement;
        page: vec2;
        container: vec2;
        client: vec2;
        scale: vec2;
        hidden: boolean;
    }): void;
    clone(): ITreeNodeData;
}
//# sourceMappingURL=HTMLElementAnchorData.d.ts.map
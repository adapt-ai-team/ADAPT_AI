"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTracingManager = void 0;
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
class SceneTracingManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (2)
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    convert3Dto2D(p) {
        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(), width = this._renderingEngine.canvas.width, height = this._renderingEngine.canvas.height;
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera) {
            const error = new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.');
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.SESSION, 'SceneTracingManager.convert3Dto2D', error);
        }
        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, camera.position));
        const tracing = this.trace(camera.position, direction);
        const pos = camera.project(gl_matrix_1.vec3.clone(p));
        pos[0] = (pos[0] * (width / 2)) + (width / 2);
        pos[1] = -(pos[1] * (height / 2)) + (height / 2);
        // take care of correction by device pixel ratio
        pos[0] = pos[0] / devicePixelRatio;
        pos[1] = pos[1] / devicePixelRatio;
        return {
            hidden: tracing.length > 1 && tracing[0].distance > 0 && tracing[0].distance < Infinity && tracing[0].distance < gl_matrix_1.vec3.distance(camera.position, p),
            container: gl_matrix_1.vec2.clone(pos),
            client: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),
            page: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset)
        };
    }
    init() { }
    trace(origin, direction, root = this._tree.root) {
        const tracingData = [];
        const trace = (root) => {
            if (root.excludeViewers.includes(this._renderingEngine.id))
                return;
            if (root.includeViewers.length > 0 && !root.includeViewers.includes(this._renderingEngine.id))
                return;
            for (let i = 0; i < root.data.length; i++)
                if (root.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const dist = root.data[i].intersect(origin, direction);
                    if (dist)
                        tracingData.push({ distance: dist, data: root.data[i] });
                }
            for (let i = 0; i < root.children.length; i++)
                trace(root.children[i]);
        };
        trace(root);
        tracingData.sort((a, b) => {
            return a.distance - b.distance;
        });
        return tracingData;
    }
}
exports.SceneTracingManager = SceneTracingManager;
//# sourceMappingURL=SceneTracingManager.js.map
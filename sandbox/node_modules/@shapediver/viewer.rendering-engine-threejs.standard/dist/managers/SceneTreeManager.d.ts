import * as THREE from 'three';
import { ISDObject, ITreeNodeData, TreeNode } from '@shapediver/viewer.shared.node-tree';
import { Box } from '@shapediver/viewer.shared.math';
import { LightEngine } from '@shapediver/viewer.rendering-engine.light-engine';
import { SDNode } from '../types/SDNode';
import { RenderingEngine } from '../RenderingEngine';
import { IManager } from '../interfaces/IManager';
export declare class SceneTreeManager implements IManager {
    private readonly _renderingEngine;
    private readonly _converter;
    private readonly _eventEngine;
    private readonly _inputValidator;
    private readonly _logger;
    private readonly _scene;
    private readonly _stateEngine;
    private readonly _tree;
    private _boundingBox;
    private _boundingBoxSensitiveData;
    private _currentSDTFOverview;
    private _mainNode;
    constructor(_renderingEngine: RenderingEngine);
    get boundingBox(): Box;
    get scene(): THREE.Scene;
    init(): void;
    isEmpty(): boolean;
    private getBone;
    /**
     * Convert the data of the scene graph node into the format of the implementation.
     *
     * @param data the data element
     * @param obj the corresponding type node
     */
    updateData(node: TreeNode, obj: SDNode, data: ITreeNodeData): void;
    updateNodeTransformations(node?: TreeNode, obj?: SDNode): void;
    updateMorphWeights(node?: TreeNode, obj?: SDNode): void;
    updateNodeData(node: TreeNode, obj: ISDObject): void;
    updateNodeHierarchy(node?: TreeNode, obj?: ISDObject): void;
    /**
     * Update the current node via the scene graph node.
     * Convert the data if needed.
     *
     * @param node the scene graph node
     * @param obj the current type object
     */
    updateNode(node: TreeNode, obj: ISDObject): void;
    updateSceneTree(root: TreeNode, lightEngine: LightEngine): void;
    private collectSDTFItemData;
    private createSDTFOverview;
    private injectAttributeData;
    private removeData;
}
//# sourceMappingURL=SceneTreeManager.d.ts.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryLoader = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const SDData_1 = require("../types/SDData");
class GeometryLoader {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (3)
        this._counter = 0;
        this._geometryCache = {};
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
    }
    // #endregion Constructors (1)
    // #region Public Methods (5)
    emptyGeometryCache() {
        this._geometryCache = {};
    }
    init() { }
    /**
     * Create a geometry object with the provided geometry data.
     *
     * @param geometry the geometry data
     * @returns the geometry object
     */
    load(geometry, parent, skeleton) {
        if (this._geometryCache[geometry.id + '_' + geometry.version]) {
            let materialData;
            if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERERTYPE.ATTRIBUTES) {
                materialData = geometry.primitive.attributeMaterial;
            }
            else if (geometry.primitive.effectMaterials.length > 0) {
                materialData = geometry.primitive.effectMaterials[geometry.primitive.effectMaterials.length - 1].material;
            }
            else {
                materialData = geometry.primitive.material;
            }
            const threeGeometry = this._geometryCache[geometry.id + '_' + geometry.version].threeGeometry.clone();
            const materialSettings = {
                mode: geometry.primitive.mode,
                useVertexTangents: threeGeometry.attributes.tangent !== undefined,
                useVertexColors: threeGeometry.attributes.color !== undefined && this._renderingEngine.type !== viewer_rendering_engine_rendering_engine_1.RENDERERTYPE.ATTRIBUTES,
                useFlatShading: threeGeometry.attributes.normal === undefined,
                useMorphTargets: Object.keys(threeGeometry.morphAttributes).length > 0,
                useMorphNormals: Object.keys(threeGeometry.morphAttributes).length > 0 && threeGeometry.morphAttributes.normal !== undefined
            };
            const material = this._renderingEngine.materialLoader.load(materialData, materialSettings);
            const obj = this._geometryCache[geometry.id + '_' + geometry.version].obj.clone();
            obj.traverse(o => {
                if (o instanceof THREE.Points ||
                    o instanceof THREE.LineSegments ||
                    o instanceof THREE.LineLoop ||
                    o instanceof THREE.Line ||
                    o instanceof THREE.Mesh)
                    o.material = material;
            });
            parent.add(obj);
        }
        else {
            const threeGeometry = this.loadGeometry(geometry.primitive);
            let materialData;
            if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERERTYPE.ATTRIBUTES) {
                materialData = geometry.primitive.attributeMaterial;
            }
            else if (geometry.primitive.effectMaterials.length > 0) {
                materialData = geometry.primitive.effectMaterials[geometry.primitive.effectMaterials.length - 1].material;
            }
            else {
                materialData = geometry.primitive.material;
            }
            const materialSettings = {
                mode: geometry.primitive.mode,
                useVertexTangents: threeGeometry.attributes.tangent !== undefined,
                useVertexColors: threeGeometry.attributes.color !== undefined && this._renderingEngine.type !== viewer_rendering_engine_rendering_engine_1.RENDERERTYPE.ATTRIBUTES,
                useFlatShading: threeGeometry.attributes.normal === undefined,
                useMorphTargets: Object.keys(threeGeometry.morphAttributes).length > 0,
                useMorphNormals: Object.keys(threeGeometry.morphAttributes).length > 0 && threeGeometry.morphAttributes.normal !== undefined
            };
            const material = this._renderingEngine.materialLoader.load(materialData, materialSettings);
            const obj = new SDData_1.SDData(geometry.id, geometry.version);
            this.createMesh(obj, geometry, threeGeometry, material, materialSettings, skeleton);
            parent.add(obj);
        }
        return geometry.boundingBox.clone().applyMatrix(geometry.matrix);
    }
    loadGeometry(primitive) {
        let geometry = new THREE.BufferGeometry();
        for (let attributeId in primitive.attributes) {
            const buffer = this.loadAttribute(primitive.attributes[attributeId], attributeId);
            const attributeName = this.getAttributeName(attributeId);
            if (attributeId === 'NORMAL')
                if (this.checkNormals(primitive, attributeId, buffer, geometry))
                    continue;
            geometry.setAttribute(attributeName, buffer);
            if (primitive.indices)
                geometry.setIndex(new THREE.BufferAttribute(primitive.indices.array, primitive.indices.itemSize));
            const morphAttributeData = primitive.attributes[attributeId].morphAttributeData;
            if (morphAttributeData.length > 0) {
                geometry.morphTargetsRelative = true;
                const buffers = [];
                for (let i = 0; i < morphAttributeData.length; i++)
                    buffers.push(this.loadAttribute(morphAttributeData[i], attributeId));
                geometry.morphAttributes[attributeName] = buffers;
            }
            // we copy the uv coordinates into the second set of uv coordinates if there are none
            // this allows for the usage of AO and light maps that share this coordinate set
            const attributeIdUV2 = 'TEXCOORD_1', attributeNameUV2 = 'uv2';
            if (attributeName === 'uv' && !primitive.attributes[attributeIdUV2]) {
                geometry.setAttribute(attributeNameUV2, buffer);
                const morphAttributeData = primitive.attributes[attributeId].morphAttributeData;
                if (morphAttributeData.length > 0) {
                    geometry.morphTargetsRelative = true;
                    const buffers = [];
                    for (let i = 0; i < morphAttributeData.length; i++)
                        buffers.push(this.loadAttribute(morphAttributeData[i], attributeId));
                    geometry.morphAttributes[attributeNameUV2] = buffers;
                }
            }
        }
        return geometry;
    }
    removeFromGeometryCache(id) {
        if (this._geometryCache[id])
            delete this._geometryCache[id];
    }
    // #endregion Public Methods (5)
    // #region Private Methods (5)
    checkNormals(primitive, attributeId, buffer, geometry) {
        let blnNormalsOk = false;
        for (let index = 0; index < 10; ++index) {
            if (Math.abs(buffer.array[index * 3]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
            if (Math.abs(buffer.array[index * 3 + 1]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
            if (Math.abs(buffer.array[index * 3 + 2]) > 0.001) {
                blnNormalsOk = true;
                break;
            }
        }
        if (!blnNormalsOk) {
            geometry.computeVertexNormals();
            const computedNormalAttribute = geometry.getAttribute('normal');
            // store the computed normals in the attribute data
            primitive.attributes[attributeId] = new viewer_shared_types_1.AttributeData(new Float32Array(computedNormalAttribute.array), computedNormalAttribute.itemSize, 0, 0, 3, computedNormalAttribute.normalized, computedNormalAttribute.array.length / 3);
            return true;
        }
        return false;
    }
    convertToTriangleMode(geometry, drawMode) {
        let index = geometry.getIndex();
        // generate index if not present
        if (index === null) {
            const indices = [];
            const position = geometry.getAttribute('position');
            if (position !== undefined) {
                for (let i = 0; i < position.count; i++)
                    indices.push(i);
                geometry.setIndex(indices);
                index = geometry.getIndex();
            }
            else {
                const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.convertToTriangleMode: Undefined position attribute. Processing not possible.`);
                throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.convertToTriangleMode`, error);
            }
        }
        if (index === null) {
            const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.convertToTriangleMode: Undefined index. Processing not possible.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.convertToTriangleMode`, error);
        }
        const numberOfTriangles = index.count - 2;
        const newIndices = [];
        if (drawMode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            for (let i = 1; i <= numberOfTriangles; i++) {
                newIndices.push(index.getX(0));
                newIndices.push(index.getX(i));
                newIndices.push(index.getX(i + 1));
            }
        }
        else {
            for (let i = 0; i < numberOfTriangles; i++) {
                if (i % 2 === 0) {
                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i + 2));
                }
                else {
                    newIndices.push(index.getX(i + 2));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i));
                }
            }
        }
        if ((newIndices.length / 3) !== numberOfTriangles) {
            const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.convertToTriangleMode: Unable to generate correct amount of triangle.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.convertToTriangleMode`, error);
        }
        const newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        return newGeometry;
    }
    createMesh(obj, geometry, threeGeometry, material, materialSettings, skeleton) {
        if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.POINTS) {
            obj.add(new THREE.Points(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINES) {
            obj.add(new THREE.LineSegments(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP) {
            obj.add(new THREE.LineLoop(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP) {
            obj.add(new THREE.Line(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            let bufferGeometry = threeGeometry;
            if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN)
                bufferGeometry = this.convertToTriangleMode(bufferGeometry, geometry.primitive.mode);
            if (skeleton) {
                const skinnedMesh = new THREE.SkinnedMesh(bufferGeometry, material);
                skinnedMesh.bind(skeleton, skinnedMesh.matrixWorld);
                if (bufferGeometry.attributes.skinWeight.normalized)
                    skinnedMesh.normalizeSkinWeights();
                obj.add(skinnedMesh);
            }
            else {
                if (material.opacity < 1 || material.alphaMap) {
                    const side = material.side;
                    if (side === THREE.DoubleSide) {
                        const materialBack = material.clone();
                        materialBack.side = THREE.BackSide;
                        obj.add(new THREE.Mesh(bufferGeometry, materialBack));
                        const materialFront = material.clone();
                        materialFront.side = THREE.FrontSide;
                        obj.add(new THREE.Mesh(bufferGeometry, materialFront));
                    }
                    else {
                        obj.add(new THREE.Mesh(bufferGeometry, material));
                    }
                }
                else {
                    obj.add(new THREE.Mesh(bufferGeometry, material));
                }
            }
            obj.children.forEach(m => m.castShadow = true);
            obj.children.forEach(m => m.receiveShadow = true);
        }
        else {
            const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.load: Unrecognized primitive mode ${geometry.primitive.mode}.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.load`, error);
        }
        obj.children.forEach(m => {
            m.geometry.boundingBox = new THREE.Box3(new THREE.Vector3(geometry.boundingBox.min[0], geometry.boundingBox.min[1], geometry.boundingBox.min[2]), new THREE.Vector3(geometry.boundingBox.max[0], geometry.boundingBox.max[1], geometry.boundingBox.max[2]));
            m.geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(geometry.boundingBox.boundingSphere.center[0], geometry.boundingBox.boundingSphere.center[1], geometry.boundingBox.boundingSphere.center[2]), geometry.boundingBox.boundingSphere.radius);
            m.geometry.userData = {
                SDid: geometry.id,
                SDversion: geometry.version
            };
            m.renderOrder = geometry.renderOrder;
            m.morphTargetInfluences = geometry.morphWeights;
            obj.add(m);
        });
        this._geometryCache[geometry.id + '_' + geometry.version] = { obj, threeGeometry, materialSettings };
    }
    getAttributeName(attributeId) {
        switch (attributeId) {
            case 'POSITION':
                return 'position';
            case 'NORMAL':
                return 'normal';
            case 'TEXCOORD_0':
            case 'TEXCOORD0':
            case 'TEXCOORD':
            case 'UV':
                return 'uv';
            case 'TEXCOORD_1':
                return 'uv2';
            case 'COLOR_0':
            case 'COLOR0':
            case 'COLOR':
                return 'color';
            case 'WEIGHT':
            case 'WEIGHTS_0':
                return 'skinWeight';
            case 'JOINT':
            case 'JOINTS_0':
                return 'skinIndex';
            case 'TANGENT':
                return 'tangent';
            default:
                this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.loadGeometry: Unrecognized attribute id ${attributeId}.`);
        }
        return '';
    }
    loadAttribute(bufferAttribute, attributeId) {
        let buffer;
        if (bufferAttribute.byteStride && bufferAttribute.byteStride !== bufferAttribute.itemBytes) {
            // Integer parameters to IB/IBA are in array elements, not bytes.
            const ib = new THREE.InterleavedBuffer(bufferAttribute.array, bufferAttribute.byteStride / bufferAttribute.elementBytes);
            buffer = new THREE.InterleavedBufferAttribute(ib, bufferAttribute.itemSize, (bufferAttribute.byteOffset % bufferAttribute.byteStride) / bufferAttribute.elementBytes, bufferAttribute.normalized);
        }
        else {
            buffer = new THREE.BufferAttribute(bufferAttribute.array, bufferAttribute.itemSize, (attributeId === 'COLOR_0' || attributeId === 'COLOR0' || attributeId === 'COLOR') ? true : bufferAttribute.normalized);
        }
        if (bufferAttribute.sparse) {
            if (bufferAttribute.array !== null) {
                // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                buffer = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
            }
            for (let i = 0, il = bufferAttribute.sparseIndices.length; i < il; i++) {
                const index = bufferAttribute.sparseIndices[i];
                buffer.setX(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize]);
                if (bufferAttribute.itemSize >= 2)
                    buffer.setY(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 1]);
                if (bufferAttribute.itemSize >= 3)
                    buffer.setZ(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 2]);
                if (bufferAttribute.itemSize >= 4)
                    buffer.setW(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 3]);
                if (bufferAttribute.itemSize >= 5) {
                    const error = new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`GeometryLoader.loadGeometry: Unsupported itemSize in sparse BufferAttribute.`);
                    throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.DATA_PROCESSING, `GeometryLoader.loadGeometry`, error);
                }
            }
        }
        return buffer;
    }
}
exports.GeometryLoader = GeometryLoader;
//# sourceMappingURL=GeometryLoader.js.map
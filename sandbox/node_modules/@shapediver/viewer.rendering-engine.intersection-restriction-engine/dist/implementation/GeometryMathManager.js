"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GeometryMathManager_settings, _GeometryMathManager_viewport;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryMathManager = void 0;
const gl_matrix_1 = require("gl-matrix");
class GeometryMathManager {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(viewport, settings) {
        // #region Properties (2)
        _GeometryMathManager_settings.set(this, void 0);
        _GeometryMathManager_viewport.set(this, void 0);
        __classPrivateFieldSet(this, _GeometryMathManager_viewport, viewport, "f");
        __classPrivateFieldSet(this, _GeometryMathManager_settings, settings, "f");
    }
    // #endregion Constructors (1)
    // #region Public Methods (9)
    /**
     * Check which distances of lines to ray
     *
     * @param ray
     * @returns
     */
    checkLineDistances(ray, positionArray, indicesArrayLines) {
        // if there are no line array indices, return
        if (!indicesArrayLines)
            return;
        /**
         * Calculate line distances to ray
         */
        const distances = [];
        for (let i = 0; i < indicesArrayLines.length; i += 2) {
            const firstIndex = indicesArrayLines.at(i);
            const secondIndex = indicesArrayLines.at(i + 1);
            const lineStart = gl_matrix_1.vec3.fromValues(positionArray.at(firstIndex * 3), positionArray.at(firstIndex * 3 + 1), positionArray.at(firstIndex * 3 + 2));
            const lineEnd = gl_matrix_1.vec3.fromValues(positionArray.at(secondIndex * 3), positionArray.at(secondIndex * 3 + 1), positionArray.at(secondIndex * 3 + 2));
            const { closestPointOnRay, closestPointOnLine } = this.closestPointsRayLine(ray, lineStart, lineEnd);
            if (this.screenSpaceDistanceCheck(closestPointOnRay, closestPointOnLine, __classPrivateFieldGet(this, _GeometryMathManager_settings, "f").points.size_0 *
                __classPrivateFieldGet(this, _GeometryMathManager_settings, "f").distanceMultiplicationFactor).check === false)
                continue;
            distances.push({
                index: [firstIndex, secondIndex],
                distance: gl_matrix_1.vec3.distance(closestPointOnRay, closestPointOnLine),
            });
        }
        // if there are no distances, return
        if (distances.length === 0)
            return;
        return distances.sort((a, b) => a.distance - b.distance);
    }
    /**
     * Check which distances of points to ray
     *
     * @param ray
     * @returns
     */
    checkPointDistances(ray, positionArray) {
        /**
         * Calculate point distances to ray
         */
        const distances = [];
        for (let i = 0; i < positionArray.length; i += 3) {
            const point = gl_matrix_1.vec3.fromValues(positionArray.at(i), positionArray.at(i + 1), positionArray.at(i + 2));
            // distance from point to ray
            const closestPoint = this.closestPoint(ray, point);
            if (this.screenSpaceDistanceCheck(point, closestPoint, __classPrivateFieldGet(this, _GeometryMathManager_settings, "f").points.size_0 *
                __classPrivateFieldGet(this, _GeometryMathManager_settings, "f").distanceMultiplicationFactor).check === false)
                continue;
            distances.push({
                index: i / 3,
                distance: gl_matrix_1.vec3.distance(point, closestPoint),
            });
        }
        // if there are no distances, return
        if (distances.length === 0)
            return;
        // sort distances
        return distances.sort((a, b) => a.distance - b.distance);
    }
    close() { }
    /**
     * Calculate the closest point on a ray to a point
     *
     * @param ray
     * @param point
     * @returns
     */
    closestPoint(ray, point) {
        // distance from point to ray
        const dot = gl_matrix_1.vec3.dot(ray.direction, gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), point, ray.origin));
        // closest point on ray to point
        return gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(dot, dot, dot)));
    }
    /**
     * Calculate the closest point on a line to a point
     *
     * @param start
     * @param end
     * @param point
     */
    closestPointOnLine(start, end, point) {
        const lineDir = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), end, start);
        // Vector from linePoint to point
        const v = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), point, start);
        // Line direction dot product with itself
        const dirDotDir = gl_matrix_1.vec3.dot(lineDir, lineDir);
        // If the direction vector is a zero vector, return the line point as closest point
        if (dirDotDir === 0)
            return start;
        // Projection factor t
        const t = gl_matrix_1.vec3.dot(v, lineDir) / dirDotDir;
        // Closest point on the line
        const closestPoint = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), start, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), lineDir, t));
        return closestPoint;
    }
    /**
     * Calculate the closest point on a plane to a point
     *
     * @param point
     * @param planeNormal
     * @param planeOrigin
     * @returns
     */
    closestPointOnPlane(planeOrigin, planeNormal, point) {
        // Calculate the vector from the plane origin to the point
        const toPoint = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), point, planeOrigin);
        // Project the vector onto the plane normal
        const projectionLength = gl_matrix_1.vec3.dot(toPoint, planeNormal);
        const projectionVector = gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), planeNormal, projectionLength);
        // Subtract the projection vector from the original point to get the projected point
        return gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), point, projectionVector);
    }
    /**
     * Calculate the distance between a ray and a line segment
     *
     * @param ray
     * @param lineStart
     * @param lineEnd
     * @returns
     */
    closestPointsRayLine(ray, lineStart, lineEnd) {
        // direction of line
        const lineDirection = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), lineEnd, lineStart));
        // cross product of ray direction and line direction
        const crossProduct = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, lineDirection);
        // length of cross product
        const crossProductLength = gl_matrix_1.vec3.length(crossProduct);
        if (crossProductLength < 0.0001) {
            // ray and line are parallel, calculate the distance differently
            const closestPointOnRay = ray.origin;
            const closestPointOnLine = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), lineStart, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), lineDirection, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), ray.origin, lineStart), lineDirection)));
            return {
                closestPointOnRay,
                closestPointOnLine,
            };
        }
        const t = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), lineStart, ray.origin);
        const u = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, lineDirection);
        const v = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, ray.direction);
        const tValue = gl_matrix_1.vec3.dot(u, crossProduct) / Math.pow(crossProductLength, 2);
        const uValue = gl_matrix_1.vec3.dot(v, crossProduct) / Math.pow(crossProductLength, 2);
        const closestPointOnRay = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), ray.direction, tValue));
        // restrict the closest point on line to the line segment
        let closestPointOnLine;
        if (uValue < 0) {
            closestPointOnLine = lineStart;
        }
        else if (uValue > gl_matrix_1.vec3.distance(lineStart, lineEnd)) {
            closestPointOnLine = lineEnd;
        }
        else {
            closestPointOnLine = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), lineStart, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), lineDirection, uValue));
        }
        return {
            closestPointOnRay,
            closestPointOnLine,
        };
    }
    /**
     * Calculate the distance between two rays
     *
     * @param ray1
     * @param ray2
     * @returns
     */
    closestPointsRayRay(ray1, ray2) {
        // cross product of ray1 direction and ray2 direction
        const crossProduct = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray1.direction, ray2.direction);
        // length of cross product
        const crossProductLength = gl_matrix_1.vec3.length(crossProduct);
        if (crossProductLength < 0.0001) {
            // ray1 and ray2 are parallel, calculate the distance differently
            const closestPointOnRay1 = ray1.origin;
            const closestPointOnRay2 = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray2.origin, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), ray2.direction, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), ray1.origin, ray2.origin), ray2.direction)));
            return {
                closestPointOnRay1,
                closestPointOnRay2,
            };
        }
        const t = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), ray2.origin, ray1.origin);
        const u = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, ray2.direction);
        const v = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, ray1.direction);
        const tValue = gl_matrix_1.vec3.dot(u, crossProduct) / Math.pow(crossProductLength, 2);
        const uValue = gl_matrix_1.vec3.dot(v, crossProduct) / Math.pow(crossProductLength, 2);
        const closestPointOnRay1 = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray1.origin, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), ray1.direction, tValue));
        const closestPointOnRay2 = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray2.origin, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), ray2.direction, uValue));
        return {
            closestPointOnRay1,
            closestPointOnRay2,
        };
    }
    screenSpaceDistanceCheck(point1, point2, threshold) {
        const camera = __classPrivateFieldGet(this, _GeometryMathManager_viewport, "f").camera;
        // Project points to NDC
        const screenPos1 = camera.project(gl_matrix_1.vec3.clone(point1));
        const screenPos2 = camera.project(gl_matrix_1.vec3.clone(point2));
        const width = __classPrivateFieldGet(this, _GeometryMathManager_viewport, "f").canvas.width;
        const height = __classPrivateFieldGet(this, _GeometryMathManager_viewport, "f").canvas.height;
        const x1 = screenPos1[0] * (width / 2) + width / 2;
        const y1 = -(screenPos1[1] * (height / 2) + height / 2);
        const x2 = screenPos2[0] * (width / 2) + width / 2;
        const y2 = -(screenPos2[1] * (height / 2) + height / 2);
        const distanceSquared = Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2);
        /**
         * Logic: The actual calculation would be
         * distance * 2 < threshold
         * the multiplication by 2 is to account for the fact that the distance is from the center of the point
         *
         * However, we work with the squared distance to avoid the sqrt operation
         * Therefore we square all values:
         * distanceSquared * 4 < threshold ** 2
         */
        return {
            distanceSquared: distanceSquared,
            check: distanceSquared * 4 < Math.pow(threshold, 2),
        };
    }
}
exports.GeometryMathManager = GeometryMathManager;
_GeometryMathManager_settings = new WeakMap(), _GeometryMathManager_viewport = new WeakMap();
//# sourceMappingURL=GeometryMathManager.js.map
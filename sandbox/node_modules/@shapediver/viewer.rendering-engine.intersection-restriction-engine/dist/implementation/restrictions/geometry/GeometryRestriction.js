"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GeometryRestriction_eventEngine, _GeometryRestriction_rayCasterParams, _GeometryRestriction_raycaster, _GeometryRestriction_viewport, _GeometryRestriction_geometryMathManager, _GeometryRestriction_lineIntersectionPercentage, _GeometryRestriction_nodes, _GeometryRestriction_pointIntersectionPercentage, _GeometryRestriction_sceneBoundingSphereRadius, _GeometryRestriction_settings, _GeometryRestriction_snapRestrictions, _GeometryRestriction_snapToEdges, _GeometryRestriction_snapToEdgesRadius, _GeometryRestriction_snapToFaces, _GeometryRestriction_snapToVertices, _GeometryRestriction_snapToVerticesRadius, _GeometryRestriction_visualizationObject, _GeometryRestriction_wireframe, _GeometryRestriction_wireframeColor;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryRestriction = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
const THREE = __importStar(require("three"));
const AbstractRestriction_1 = require("../AbstractRestriction");
// #endregion Type aliases (1)
// #region Classes (1)
class GeometryRestriction extends AbstractRestriction_1.AbstractRestriction {
    // #endregion Properties (17)
    // #region Constructors (1)
    constructor(viewport, geometryMathManager, parentNode, id, settings, properties) {
        var _a, _b, _c, _d, _e;
        super(viewport, parentNode, id, properties);
        // #region Properties (17)
        _GeometryRestriction_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _GeometryRestriction_rayCasterParams.set(this, {
            Line: { threshold: 1 },
            Line2: { threshold: 1 },
            Points: { threshold: 1 },
            Mesh: {},
            LOD: {},
            Sprite: {},
        });
        _GeometryRestriction_raycaster.set(this, new THREE.Raycaster());
        _GeometryRestriction_viewport.set(this, void 0);
        _GeometryRestriction_geometryMathManager.set(this, void 0);
        _GeometryRestriction_lineIntersectionPercentage.set(this, 0.025);
        _GeometryRestriction_nodes.set(this, []);
        _GeometryRestriction_pointIntersectionPercentage.set(this, 0.025);
        _GeometryRestriction_sceneBoundingSphereRadius.set(this, 0);
        _GeometryRestriction_settings.set(this, void 0);
        _GeometryRestriction_snapRestrictions.set(this, {});
        _GeometryRestriction_snapToEdges.set(this, true);
        _GeometryRestriction_snapToEdgesRadius.set(this, void 0);
        _GeometryRestriction_snapToFaces.set(this, true);
        _GeometryRestriction_snapToVertices.set(this, true);
        _GeometryRestriction_snapToVerticesRadius.set(this, void 0);
        _GeometryRestriction_visualizationObject.set(this, new THREE.Object3D());
        _GeometryRestriction_wireframe.set(this, void 0);
        _GeometryRestriction_wireframeColor.set(this, void 0);
        __classPrivateFieldSet(this, _GeometryRestriction_viewport, viewport, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_settings, settings, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_geometryMathManager, geometryMathManager, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_wireframe, (_a = properties.wireframe) !== null && _a !== void 0 ? _a : true, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_wireframeColor, (_b = properties.wireframeColor) !== null && _b !== void 0 ? _b : __classPrivateFieldGet(this, _GeometryRestriction_settings, "f").points.color_1, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_snapToVertices, (_c = properties.snapToVertices) !== null && _c !== void 0 ? _c : true, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_snapToEdges, (_d = properties.snapToEdges) !== null && _d !== void 0 ? _d : true, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_snapToFaces, (_e = properties.snapToFaces) !== null && _e !== void 0 ? _e : true, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_snapToVerticesRadius, properties.snapToVerticesRadius, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_snapToEdgesRadius, properties.snapToEdgesRadius, "f");
        __classPrivateFieldSet(this, _GeometryRestriction_sceneBoundingSphereRadius, viewer_1.sceneTree.root.boundingBox.boundingSphere.radius, "f");
        this.updateIntersectionThresholds();
        __classPrivateFieldGet(this, _GeometryRestriction_eventEngine, "f").addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const event = e;
            if (event.viewportId === __classPrivateFieldGet(this, _GeometryRestriction_viewport, "f").id) {
                const boundingBox = new viewer_shared_math_1.Box(event.boundingBox.min, event.boundingBox.max);
                __classPrivateFieldSet(this, _GeometryRestriction_sceneBoundingSphereRadius, boundingBox.boundingSphere.radius, "f");
                this.updateIntersectionThresholds();
            }
        });
        this.updateNodes(properties.nodes);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (8)
    get nodes() {
        return __classPrivateFieldGet(this, _GeometryRestriction_nodes, "f");
    }
    get snapRestrictions() {
        return __classPrivateFieldGet(this, _GeometryRestriction_snapRestrictions, "f");
    }
    get snapToEdges() {
        return __classPrivateFieldGet(this, _GeometryRestriction_snapToEdges, "f");
    }
    set snapToEdges(value) {
        __classPrivateFieldSet(this, _GeometryRestriction_snapToEdges, value, "f");
    }
    get snapToFaces() {
        return __classPrivateFieldGet(this, _GeometryRestriction_snapToFaces, "f");
    }
    set snapToFaces(value) {
        __classPrivateFieldSet(this, _GeometryRestriction_snapToFaces, value, "f");
    }
    get snapToVertices() {
        return __classPrivateFieldGet(this, _GeometryRestriction_snapToVertices, "f");
    }
    set snapToVertices(value) {
        __classPrivateFieldSet(this, _GeometryRestriction_snapToVertices, value, "f");
    }
    // #endregion Public Getters And Setters (8)
    // #region Public Methods (3)
    rayTrace(ray, metaData) {
        if (this.enabled === false)
            return;
        if (__classPrivateFieldGet(this, _GeometryRestriction_snapToVertices, "f") === false &&
            __classPrivateFieldGet(this, _GeometryRestriction_snapToEdges, "f") === false &&
            __classPrivateFieldGet(this, _GeometryRestriction_snapToFaces, "f") === false)
            return;
        // assign raycaster parameters
        __classPrivateFieldGet(this, _GeometryRestriction_raycaster, "f").params = __classPrivateFieldGet(this, _GeometryRestriction_rayCasterParams, "f");
        __classPrivateFieldGet(this, _GeometryRestriction_raycaster, "f").ray.direction.set(ray.direction[0], ray.direction[1], ray.direction[2]);
        __classPrivateFieldGet(this, _GeometryRestriction_raycaster, "f").ray.origin.set(ray.origin[0], ray.origin[1], ray.origin[2]);
        // intersect all nodes
        let intersections = [];
        __classPrivateFieldGet(this, _GeometryRestriction_nodes, "f").forEach((node) => {
            const threeJsObject = node.convertedObject[__classPrivateFieldGet(this, _GeometryRestriction_viewport, "f").id];
            if (threeJsObject) {
                const currentIntersections = __classPrivateFieldGet(this, _GeometryRestriction_raycaster, "f").intersectObject(threeJsObject);
                intersections = intersections.concat(currentIntersections);
            }
        });
        // sort
        intersections.sort((a, b) => a.distance - b.distance);
        // return first intersection
        if (intersections.length > 0) {
            const object = intersections[0].object;
            let geometryRestrictionIntersectionData;
            // search the three.js object hierarchy for the converted object
            let tempObject = object;
            while (tempObject.parent) {
                const intersectedNode = __classPrivateFieldGet(this, _GeometryRestriction_nodes, "f").find((node) => node.id === tempObject.SDid &&
                    node.version === tempObject.SDversion);
                if (intersectedNode) {
                    // from this node, we can get the geometry data
                    intersectedNode.traverseData((d) => {
                        if (d instanceof viewer_shared_types_1.GeometryData &&
                            d.id === object.parent.SDid &&
                            d.version === object.parent.SDversion) {
                            geometryRestrictionIntersectionData = {
                                node: intersectedNode,
                                geometryData: d,
                            };
                        }
                    });
                    break;
                }
                tempObject = tempObject.parent;
            }
            const geometry = object.geometry;
            const positionAttribute = geometry.getAttribute("position");
            if (object instanceof THREE.Points &&
                intersections[0].index !== undefined) {
                if (!__classPrivateFieldGet(this, _GeometryRestriction_snapToVertices, "f"))
                    return;
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positionAttribute, intersections[0].index);
                object.localToWorld(vertex);
                return this.constructRestrictionResult(gl_matrix_1.vec3.fromValues(vertex.x, vertex.y, vertex.z), intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
            }
            const intersectionPoint = intersections[0].point;
            const intersectionPointVec3 = gl_matrix_1.vec3.fromValues(intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
            if (!intersections[0].face)
                return this.constructRestrictionResult(intersectionPointVec3, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
            if (__classPrivateFieldGet(this, _GeometryRestriction_snapToVertices, "f") === true || __classPrivateFieldGet(this, _GeometryRestriction_snapToEdges, "f") === true) {
                const vertexA = new THREE.Vector3();
                vertexA.fromBufferAttribute(positionAttribute, intersections[0].face.a);
                object.localToWorld(vertexA);
                const vertexAVec3 = gl_matrix_1.vec3.fromValues(vertexA.x, vertexA.y, vertexA.z);
                const vertexB = new THREE.Vector3();
                vertexB.fromBufferAttribute(positionAttribute, intersections[0].face.b);
                object.localToWorld(vertexB);
                const vertexBVec3 = gl_matrix_1.vec3.fromValues(vertexB.x, vertexB.y, vertexB.z);
                const vertexC = new THREE.Vector3();
                vertexC.fromBufferAttribute(positionAttribute, intersections[0].face.c);
                object.localToWorld(vertexC);
                const vertexCVec3 = gl_matrix_1.vec3.fromValues(vertexC.x, vertexC.y, vertexC.z);
                if (__classPrivateFieldGet(this, _GeometryRestriction_snapToVertices, "f") === true) {
                    const distanceA = this.checkDistance(intersectionPointVec3, vertexAVec3, __classPrivateFieldGet(this, _GeometryRestriction_snapToVerticesRadius, "f"));
                    const distanceB = this.checkDistance(intersectionPointVec3, vertexBVec3, __classPrivateFieldGet(this, _GeometryRestriction_snapToVerticesRadius, "f"));
                    const distanceC = this.checkDistance(intersectionPointVec3, vertexCVec3, __classPrivateFieldGet(this, _GeometryRestriction_snapToVerticesRadius, "f"));
                    // part 1 - check if the intersection point is close to a vertex
                    if (distanceA.check &&
                        distanceA.distanceSquared < distanceB.distanceSquared &&
                        distanceA.distanceSquared < distanceC.distanceSquared) {
                        return this.constructRestrictionResult(vertexAVec3, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                    else if (distanceB.check &&
                        distanceB.distanceSquared < distanceA.distanceSquared &&
                        distanceB.distanceSquared < distanceC.distanceSquared) {
                        return this.constructRestrictionResult(vertexBVec3, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                    else if (distanceC.check &&
                        distanceC.distanceSquared < distanceA.distanceSquared &&
                        distanceC.distanceSquared < distanceB.distanceSquared) {
                        return this.constructRestrictionResult(vertexCVec3, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                }
                if (__classPrivateFieldGet(this, _GeometryRestriction_snapToEdges, "f") === true) {
                    // part 2 - check if the intersection point is close to an edge
                    // create the closest points on the edges
                    const closestPointOnEdgeAB = __classPrivateFieldGet(this, _GeometryRestriction_geometryMathManager, "f").closestPointOnLine(vertexAVec3, vertexBVec3, intersectionPointVec3);
                    const closestPointOnEdgeBC = __classPrivateFieldGet(this, _GeometryRestriction_geometryMathManager, "f").closestPointOnLine(vertexBVec3, vertexCVec3, intersectionPointVec3);
                    const closestPointOnEdgeCA = __classPrivateFieldGet(this, _GeometryRestriction_geometryMathManager, "f").closestPointOnLine(vertexCVec3, vertexAVec3, intersectionPointVec3);
                    // create the distances
                    const distanceAB = this.checkDistance(intersectionPointVec3, closestPointOnEdgeAB, __classPrivateFieldGet(this, _GeometryRestriction_snapToEdgesRadius, "f"));
                    const distanceBC = this.checkDistance(intersectionPointVec3, closestPointOnEdgeBC, __classPrivateFieldGet(this, _GeometryRestriction_snapToEdgesRadius, "f"));
                    const distanceCA = this.checkDistance(intersectionPointVec3, closestPointOnEdgeCA, __classPrivateFieldGet(this, _GeometryRestriction_snapToEdgesRadius, "f"));
                    // check if the intersection point is close to an edge
                    if (distanceAB.check &&
                        distanceAB.distanceSquared <
                            distanceBC.distanceSquared &&
                        distanceAB.distanceSquared < distanceCA.distanceSquared) {
                        return this.constructRestrictionResult(closestPointOnEdgeAB, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                    else if (distanceBC.check &&
                        distanceBC.distanceSquared <
                            distanceAB.distanceSquared &&
                        distanceBC.distanceSquared < distanceCA.distanceSquared) {
                        return this.constructRestrictionResult(closestPointOnEdgeBC, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                    else if (distanceCA.check &&
                        distanceCA.distanceSquared <
                            distanceAB.distanceSquared &&
                        distanceCA.distanceSquared < distanceBC.distanceSquared) {
                        return this.constructRestrictionResult(closestPointOnEdgeCA, intersections[0].distance, intersections[0].pointOnLine, geometryRestrictionIntersectionData);
                    }
                }
            }
            if (__classPrivateFieldGet(this, _GeometryRestriction_snapToFaces, "f") === true) {
                // part 3 - face intersection
                return this.constructRestrictionResult(gl_matrix_1.vec3.fromValues(intersectionPoint.x, intersectionPoint.y, intersectionPoint.z), intersections[0].distance, undefined, geometryRestrictionIntersectionData);
            }
        }
        return;
    }
    updateNodes(nodes) {
        __classPrivateFieldSet(this, _GeometryRestriction_nodes, nodes, "f");
        if (__classPrivateFieldGet(this, _GeometryRestriction_wireframe, "f")) {
            __classPrivateFieldGet(this, _GeometryRestriction_visualizationObject, "f").traverse((object) => {
                if (object instanceof THREE.LineSegments) {
                    object.geometry.dispose();
                    object.material.dispose();
                }
            });
            this._object3D.remove(__classPrivateFieldGet(this, _GeometryRestriction_visualizationObject, "f"));
            __classPrivateFieldSet(this, _GeometryRestriction_visualizationObject, new THREE.Object3D(), "f");
            __classPrivateFieldGet(this, _GeometryRestriction_nodes, "f").forEach((node) => {
                const threeJsObject = node.convertedObject[__classPrivateFieldGet(this, _GeometryRestriction_viewport, "f").id];
                if (threeJsObject) {
                    threeJsObject.updateMatrixWorld(true);
                    threeJsObject.traverse((object) => {
                        if (object instanceof THREE.Mesh) {
                            const wireframe = new THREE.WireframeGeometry(object.geometry);
                            const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({
                                color: new THREE.Color(__classPrivateFieldGet(this, _GeometryRestriction_wireframeColor, "f")),
                            }));
                            line.applyMatrix4(object.matrixWorld);
                            __classPrivateFieldGet(this, _GeometryRestriction_visualizationObject, "f").add(line);
                        }
                    });
                }
            });
            this._object3D.add(__classPrivateFieldGet(this, _GeometryRestriction_visualizationObject, "f"));
        }
    }
    // #endregion Public Methods (3)
    // #region Protected Methods (1)
    visibilityChanged() { }
    // #endregion Protected Methods (1)
    // #region Private Methods (1)
    updateIntersectionThresholds() {
        __classPrivateFieldGet(this, _GeometryRestriction_rayCasterParams, "f").Points.threshold =
            __classPrivateFieldGet(this, _GeometryRestriction_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _GeometryRestriction_pointIntersectionPercentage, "f");
        __classPrivateFieldGet(this, _GeometryRestriction_rayCasterParams, "f").Line.threshold =
            __classPrivateFieldGet(this, _GeometryRestriction_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _GeometryRestriction_lineIntersectionPercentage, "f");
        __classPrivateFieldGet(this, _GeometryRestriction_rayCasterParams, "f").Line2.threshold =
            __classPrivateFieldGet(this, _GeometryRestriction_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _GeometryRestriction_lineIntersectionPercentage, "f");
    }
    constructRestrictionResult(targetPoint, distanceOriginToClosestIntersectionPoint, closestPointOnRay, geometryRestrictionIntersectionData) {
        const closestPointOnRayVec3 = closestPointOnRay
            ? gl_matrix_1.vec3.fromValues(closestPointOnRay.x, closestPointOnRay.y, closestPointOnRay.z)
            : targetPoint;
        return {
            closestIntersectionPoint: closestPointOnRay
                ? gl_matrix_1.vec3.fromValues(closestPointOnRay.x, closestPointOnRay.y, closestPointOnRay.z)
                : targetPoint,
            distanceOriginToClosestIntersectionPointSquared: distanceOriginToClosestIntersectionPoint *
                distanceOriginToClosestIntersectionPoint,
            targetPoint,
            distanceClosestPointToTargetPointSquared: closestPointOnRayVec3 !== targetPoint
                ? gl_matrix_1.vec3.sqrDist(closestPointOnRayVec3, targetPoint)
                : 0,
            restriction: this,
            restrictionIntersectionData: geometryRestrictionIntersectionData,
        };
    }
    /**
     * We check the distance between two points.
     * If a radius is given, we check if the distance is smaller than the radius.
     * If no radius is given, we move to the screen space distance check.
     *
     * @param point1
     * @param point2
     * @param radius
     * @returns
     */
    checkDistance(point1, point2, radius) {
        if (radius !== undefined) {
            const distance = gl_matrix_1.vec3.sqrDist(point1, point2);
            return {
                distanceSquared: distance * distance,
                check: distance < radius,
            };
        }
        else {
            return __classPrivateFieldGet(this, _GeometryRestriction_geometryMathManager, "f").screenSpaceDistanceCheck(point1, point2, __classPrivateFieldGet(this, _GeometryRestriction_settings, "f").points.size_0 *
                __classPrivateFieldGet(this, _GeometryRestriction_settings, "f").distanceMultiplicationFactor);
        }
    }
}
exports.GeometryRestriction = GeometryRestriction;
_GeometryRestriction_eventEngine = new WeakMap(), _GeometryRestriction_rayCasterParams = new WeakMap(), _GeometryRestriction_raycaster = new WeakMap(), _GeometryRestriction_viewport = new WeakMap(), _GeometryRestriction_geometryMathManager = new WeakMap(), _GeometryRestriction_lineIntersectionPercentage = new WeakMap(), _GeometryRestriction_nodes = new WeakMap(), _GeometryRestriction_pointIntersectionPercentage = new WeakMap(), _GeometryRestriction_sceneBoundingSphereRadius = new WeakMap(), _GeometryRestriction_settings = new WeakMap(), _GeometryRestriction_snapRestrictions = new WeakMap(), _GeometryRestriction_snapToEdges = new WeakMap(), _GeometryRestriction_snapToEdgesRadius = new WeakMap(), _GeometryRestriction_snapToFaces = new WeakMap(), _GeometryRestriction_snapToVertices = new WeakMap(), _GeometryRestriction_snapToVerticesRadius = new WeakMap(), _GeometryRestriction_visualizationObject = new WeakMap(), _GeometryRestriction_wireframe = new WeakMap(), _GeometryRestriction_wireframeColor = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=GeometryRestriction.js.map
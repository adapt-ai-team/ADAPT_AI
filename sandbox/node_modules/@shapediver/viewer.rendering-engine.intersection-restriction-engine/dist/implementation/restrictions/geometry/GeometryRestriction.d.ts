import { IViewportApi } from "@shapediver/viewer";
import { ITreeNode } from "@shapediver/viewer.shared.node-tree";
import { IGeometryData, IRay } from "@shapediver/viewer.shared.types";
import { IRestriction, RestrictionMetaData, RestrictionPropertiesBase, RestrictionResult } from "../../../interfaces/IRestriction";
import { ISnapRestriction } from "../../../interfaces/ISnapRestriction";
import { IVisualizationSettings } from "../../../interfaces/IVisualizationSettings";
import { GeometryMathManager } from "../../GeometryMathManager";
import { AbstractRestriction } from "../AbstractRestriction";
export interface GeometryRestrictionProperties extends RestrictionPropertiesBase {
    /**
     * The nodes to restrict the interaction to.
     */
    nodes: ITreeNode[];
    /**
     * If the geometry should be displayed as wireframe.
     */
    wireframe?: boolean;
    /**
     * The color of the wireframe.
     */
    wireframeColor?: string;
    /**
     * If the restriction should snap to vertices. (default: true)
     */
    snapToVertices?: boolean;
    /**
     * The radius in which the restriction should snap to vertices. (default: 2.5% of the scene bounding sphere radius in screen space)
     */
    snapToVerticesRadius?: number;
    /**
     * If the restriction should snap to edges. (default: true)
     */
    snapToEdges?: boolean;
    /**
     * The radius in which the restriction should snap to edges. (default: 2.5% of the scene bounding sphere radius in screen space)
     */
    snapToEdgesRadius?: number;
    /**
     * If the restriction should snap to faces. (default: true)
     */
    snapToFaces?: boolean;
}
/**
 * The data of the intersection of the geometry restriction.
 * This data is forwarded for internal use.
 */
export interface GeometryRestrictionIntersectionData {
    node: ITreeNode;
    geometryData: IGeometryData;
}
export declare class GeometryRestriction extends AbstractRestriction implements IRestriction {
    #private;
    constructor(viewport: IViewportApi, geometryMathManager: GeometryMathManager, parentNode: ITreeNode, id: string, settings: IVisualizationSettings, properties: GeometryRestrictionProperties);
    get nodes(): ITreeNode[];
    get snapRestrictions(): {
        [key: string]: ISnapRestriction;
    };
    get snapToEdges(): boolean;
    set snapToEdges(value: boolean);
    get snapToFaces(): boolean;
    set snapToFaces(value: boolean);
    get snapToVertices(): boolean;
    set snapToVertices(value: boolean);
    rayTrace(ray: IRay, metaData?: RestrictionMetaData): RestrictionResult | undefined;
    updateNodes(nodes: ITreeNode[]): void;
    protected visibilityChanged(): void;
    private updateIntersectionThresholds;
    private constructRestrictionResult;
    /**
     * We check the distance between two points.
     * If a radius is given, we check if the distance is smaller than the radius.
     * If no radius is given, we move to the screen space distance check.
     *
     * @param point1
     * @param point2
     * @param radius
     * @returns
     */
    private checkDistance;
}
//# sourceMappingURL=GeometryRestriction.d.ts.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateDragMatrix = void 0;
const gl_matrix_1 = require("gl-matrix");
const calculateDragMatrix = (snapPoint, snapRotation, dragOrigin, dragAnchors = [], closestPoint) => {
    if (dragAnchors.length > 0) {
        const results = [];
        for (let i = 0; i < dragAnchors.length; i++) {
            const matrix = calculateMatrix(dragAnchors[i].position, dragAnchors[i].rotation || {
                axis: gl_matrix_1.vec3.fromValues(0, 0, 1),
                angle: 0,
            }, snapPoint, snapRotation);
            const point = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), dragOrigin, matrix);
            results.push({ matrix, point, dragAnchor: dragAnchors[i] });
        }
        results.sort((a, b) => gl_matrix_1.vec3.distance(a.point, closestPoint) -
            gl_matrix_1.vec3.distance(b.point, closestPoint));
        return results[0];
    }
    else {
        return {
            matrix: calculateMatrix(dragOrigin, { axis: gl_matrix_1.vec3.fromValues(0, 0, 1), angle: 0 }, snapPoint, snapRotation),
            point: dragOrigin,
        };
    }
};
exports.calculateDragMatrix = calculateDragMatrix;
const calculateMatrix = (dragPoint, dragRotation, snapPoint, snapRotation) => {
    const rotationMatrix = gl_matrix_1.mat4.create();
    // apply inverted anchor matrix
    const dragMatrix = gl_matrix_1.mat4.fromRotation(gl_matrix_1.mat4.create(), dragRotation.angle, dragRotation.axis);
    let invertedDragMatrix = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), dragMatrix);
    if (!invertedDragMatrix)
        invertedDragMatrix = gl_matrix_1.mat4.create();
    gl_matrix_1.mat4.multiply(rotationMatrix, rotationMatrix, invertedDragMatrix);
    // apply snap matrix
    const snapMatrix = gl_matrix_1.mat4.fromRotation(gl_matrix_1.mat4.create(), snapRotation.angle, snapRotation.axis);
    gl_matrix_1.mat4.multiply(rotationMatrix, rotationMatrix, snapMatrix);
    // the dragAnchor in the rotated space
    const dragPointTransformed = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), dragPoint, rotationMatrix);
    // distance between snap point and transformed anchor
    const dragTranslation = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), snapPoint, dragPointTransformed);
    // transformation of the difference
    let invertedRotationMatrix = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), rotationMatrix);
    if (!invertedRotationMatrix)
        invertedRotationMatrix = gl_matrix_1.mat4.create();
    gl_matrix_1.vec3.transformMat4(dragTranslation, dragTranslation, invertedRotationMatrix);
    const translationMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), dragTranslation);
    return gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), rotationMatrix, translationMatrix);
};
//# sourceMappingURL=RestrictionsHelper.js.map
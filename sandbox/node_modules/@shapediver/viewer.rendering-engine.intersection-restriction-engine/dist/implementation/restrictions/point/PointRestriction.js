"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PointRestriction_viewport, _PointRestriction_point, _PointRestriction_radius, _PointRestriction_snapRestrictions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointRestriction = void 0;
const gl_matrix_1 = require("gl-matrix");
const AbstractRestriction_1 = require("../AbstractRestriction");
// #endregion Type aliases (1)
// #region Classes (1)
class PointRestriction extends AbstractRestriction_1.AbstractRestriction {
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(viewport, geometryMathManager, parentNode, id, settings, properties) {
        super(viewport, parentNode, id, properties);
        // #region Properties (4)
        _PointRestriction_viewport.set(this, void 0);
        _PointRestriction_point.set(this, void 0);
        _PointRestriction_radius.set(this, void 0);
        _PointRestriction_snapRestrictions.set(this, {});
        __classPrivateFieldSet(this, _PointRestriction_viewport, viewport, "f");
        __classPrivateFieldSet(this, _PointRestriction_point, properties.point, "f");
        __classPrivateFieldSet(this, _PointRestriction_radius, properties.radius || 0, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get point() {
        return __classPrivateFieldGet(this, _PointRestriction_point, "f");
    }
    get radius() {
        return __classPrivateFieldGet(this, _PointRestriction_radius, "f");
    }
    get snapRestrictions() {
        return __classPrivateFieldGet(this, _PointRestriction_snapRestrictions, "f");
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (1)
    isWithinRadius(point) {
        return (gl_matrix_1.vec3.squaredDistance(point, __classPrivateFieldGet(this, _PointRestriction_point, "f")) <=
            __classPrivateFieldGet(this, _PointRestriction_radius, "f") * __classPrivateFieldGet(this, _PointRestriction_radius, "f"));
    }
    rayTrace(ray, metaData) {
        const closestPointVector = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _PointRestriction_point, "f"), ray.origin);
        const t = Math.max(0, gl_matrix_1.vec3.dot(closestPointVector, ray.direction));
        const closestPoint = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.scaleAndAdd(closestPoint, ray.origin, ray.direction, t);
        const distance = gl_matrix_1.vec3.squaredDistance(closestPoint, __classPrivateFieldGet(this, _PointRestriction_point, "f"));
        if (distance < __classPrivateFieldGet(this, _PointRestriction_radius, "f") * __classPrivateFieldGet(this, _PointRestriction_radius, "f")) {
            // check if origin is inside the sphere
            const distanceOrigin = gl_matrix_1.vec3.squaredDistance(ray.origin, __classPrivateFieldGet(this, _PointRestriction_point, "f"));
            if (distanceOrigin < __classPrivateFieldGet(this, _PointRestriction_radius, "f") * __classPrivateFieldGet(this, _PointRestriction_radius, "f")) {
                return {
                    closestIntersectionPoint: closestPoint,
                    distanceOriginToClosestIntersectionPointSquared: distanceOrigin,
                    targetPoint: __classPrivateFieldGet(this, _PointRestriction_point, "f"),
                    distanceClosestPointToTargetPointSquared: distance,
                    restriction: this,
                };
            }
            // now we calculate the closest point on the sphere to the ray
            const offset = Math.sqrt(__classPrivateFieldGet(this, _PointRestriction_radius, "f") * __classPrivateFieldGet(this, _PointRestriction_radius, "f") - distance);
            // Compute the entry distance
            const entry = t - offset;
            const closestIntersectionPoint = gl_matrix_1.vec3.scaleAndAdd(gl_matrix_1.vec3.create(), ray.origin, ray.direction, entry);
            return {
                closestIntersectionPoint: closestIntersectionPoint,
                distanceOriginToClosestIntersectionPointSquared: entry * entry,
                targetPoint: __classPrivateFieldGet(this, _PointRestriction_point, "f"),
                distanceClosestPointToTargetPointSquared: distance,
                restriction: this,
            };
        }
        return;
    }
    // #endregion Public Methods (1)
    // #region Protected Methods (1)
    visibilityChanged() { }
}
exports.PointRestriction = PointRestriction;
_PointRestriction_viewport = new WeakMap(), _PointRestriction_point = new WeakMap(), _PointRestriction_radius = new WeakMap(), _PointRestriction_snapRestrictions = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=PointRestriction.js.map
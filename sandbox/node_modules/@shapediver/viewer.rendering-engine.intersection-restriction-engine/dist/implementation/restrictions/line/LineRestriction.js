"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineRestriction_viewport, _LineRestriction_dragLineLength, _LineRestriction_dragRay, _LineRestriction_point1, _LineRestriction_point1Restriction, _LineRestriction_point2, _LineRestriction_point2Restriction, _LineRestriction_radius, _LineRestriction_snapRestrictions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineRestriction = void 0;
const gl_matrix_1 = require("gl-matrix");
const IRestriction_1 = require("../../../interfaces/IRestriction");
const AbstractRestriction_1 = require("../AbstractRestriction");
const PointRestriction_1 = require("../point/PointRestriction");
// #endregion Type aliases (1)
// #region Classes (1)
class LineRestriction extends AbstractRestriction_1.AbstractRestriction {
    // #endregion Properties (7)
    // #region Constructors (1)
    constructor(viewport, geometryMathManager, parentNode, id, settings, properties) {
        super(viewport, parentNode, id, properties);
        // #region Properties (7)
        _LineRestriction_viewport.set(this, void 0);
        _LineRestriction_dragLineLength.set(this, void 0);
        _LineRestriction_dragRay.set(this, void 0);
        _LineRestriction_point1.set(this, void 0);
        _LineRestriction_point1Restriction.set(this, void 0);
        _LineRestriction_point2.set(this, void 0);
        _LineRestriction_point2Restriction.set(this, void 0);
        _LineRestriction_radius.set(this, void 0);
        _LineRestriction_snapRestrictions.set(this, {});
        __classPrivateFieldSet(this, _LineRestriction_viewport, viewport, "f");
        __classPrivateFieldSet(this, _LineRestriction_point1, properties.point1, "f");
        __classPrivateFieldSet(this, _LineRestriction_point2, properties.point2, "f");
        __classPrivateFieldSet(this, _LineRestriction_radius, properties.radius || 0, "f");
        if (properties.point1Radius !== undefined) {
            __classPrivateFieldSet(this, _LineRestriction_point1Restriction, new PointRestriction_1.PointRestriction(viewport, geometryMathManager, parentNode, id, settings, {
                type: IRestriction_1.RESTRICTION_TYPE.POINT,
                point: properties.point1,
                radius: properties.point1Radius,
            }), "f");
        }
        if (properties.point2Radius !== undefined) {
            __classPrivateFieldSet(this, _LineRestriction_point2Restriction, new PointRestriction_1.PointRestriction(viewport, geometryMathManager, parentNode, id, settings, {
                type: IRestriction_1.RESTRICTION_TYPE.POINT,
                point: properties.point2,
                radius: properties.point2Radius,
            }), "f");
        }
        const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_point2, "f"), __classPrivateFieldGet(this, _LineRestriction_point1, "f"));
        __classPrivateFieldSet(this, _LineRestriction_dragLineLength, gl_matrix_1.vec3.length(direction), "f");
        __classPrivateFieldSet(this, _LineRestriction_dragRay, {
            origin: __classPrivateFieldGet(this, _LineRestriction_point1, "f"),
            direction: gl_matrix_1.vec3.divide(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(__classPrivateFieldGet(this, _LineRestriction_dragLineLength, "f"), __classPrivateFieldGet(this, _LineRestriction_dragLineLength, "f"), __classPrivateFieldGet(this, _LineRestriction_dragLineLength, "f"))),
        }, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (5)
    get point1() {
        return __classPrivateFieldGet(this, _LineRestriction_point1, "f");
    }
    get point1Restriction() {
        return __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f");
    }
    get point2() {
        return __classPrivateFieldGet(this, _LineRestriction_point2, "f");
    }
    get point2Restriction() {
        return __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f");
    }
    get radius() {
        return __classPrivateFieldGet(this, _LineRestriction_radius, "f");
    }
    get snapRestrictions() {
        return __classPrivateFieldGet(this, _LineRestriction_snapRestrictions, "f");
    }
    // #endregion Public Getters And Setters (5)
    // #region Public Methods (1)
    isWithinRadius(point) {
        var _a, _b;
        // Check distance from point to the start of the cylinder
        const distance = gl_matrix_1.vec3.squaredDistance(point, __classPrivateFieldGet(this, _LineRestriction_point1, "f"));
        const squaredRadius1 = ((_a = __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f")) === null || _a === void 0 ? void 0 : _a.radius)
            ? __classPrivateFieldGet(this, _LineRestriction_radius, "f") > __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f").radius
                ? __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f")
                : __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f").radius *
                    __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f").radius
            : __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f");
        if (distance < squaredRadius1) {
            return true;
        }
        // Check distance from point to the end of the cylinder
        const distance2 = gl_matrix_1.vec3.squaredDistance(point, __classPrivateFieldGet(this, _LineRestriction_point2, "f"));
        const squaredRadius2 = ((_b = __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f")) === null || _b === void 0 ? void 0 : _b.radius)
            ? __classPrivateFieldGet(this, _LineRestriction_radius, "f") > __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f").radius
                ? __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f")
                : __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f").radius *
                    __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f").radius
            : __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f");
        if (distance2 < squaredRadius2) {
            return true;
        }
        // Calculate the closest point on the line segment (between point1 and point2)
        const lineDir = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_point2, "f"), __classPrivateFieldGet(this, _LineRestriction_point1, "f")); // Direction of the line segment
        const lineLengthSquared = gl_matrix_1.vec3.squaredLength(lineDir);
        // Project the point onto the line (scaled projection)
        const projection = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), point, __classPrivateFieldGet(this, _LineRestriction_point1, "f")), lineDir) /
            lineLengthSquared;
        // Clamp the projection value to ensure it's within the line segment
        const clampedProjection = Math.max(0, Math.min(1, projection));
        // Calculate the closest point on the segment
        const closestPointOnLine = gl_matrix_1.vec3.scaleAndAdd(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_point1, "f"), lineDir, clampedProjection);
        // Check if the point is within the radius of the line
        const distance3 = gl_matrix_1.vec3.squaredDistance(point, closestPointOnLine);
        if (distance3 < __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f")) {
            return true;
        }
        // If all checks fail, return false
        return false;
    }
    rayTrace(ray, metaData) {
        const planeNormal = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").direction);
        const Na = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, planeNormal));
        const Nb = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").direction, planeNormal));
        const da = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").origin, ray.origin), Nb) / gl_matrix_1.vec3.dot(ray.direction, Nb);
        const db = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), ray.origin, __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").origin), Na) / gl_matrix_1.vec3.dot(__classPrivateFieldGet(this, _LineRestriction_dragRay, "f").direction, Na);
        let pointA = gl_matrix_1.vec3.create();
        if (da < 0) {
            gl_matrix_1.vec3.copy(pointA, ray.origin);
        }
        else {
            pointA = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(da, da, da)));
        }
        let pointB = gl_matrix_1.vec3.create();
        if (db < 0) {
            gl_matrix_1.vec3.copy(pointB, __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").origin);
        }
        else if (db < __classPrivateFieldGet(this, _LineRestriction_dragLineLength, "f")) {
            pointB = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _LineRestriction_dragRay, "f").direction, gl_matrix_1.vec3.fromValues(db, db, db)));
        }
        else {
            gl_matrix_1.vec3.copy(pointB, __classPrivateFieldGet(this, _LineRestriction_point2, "f"));
        }
        // first, check the simple cases
        // if there the restrictions for the points are set, we need to check them
        const result1 = __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f")
            ? __classPrivateFieldGet(this, _LineRestriction_point1Restriction, "f").rayTrace(ray)
            : undefined;
        const result2 = __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f")
            ? __classPrivateFieldGet(this, _LineRestriction_point2Restriction, "f").rayTrace(ray)
            : undefined;
        // return the closest result
        if (result1 || result2) {
            if (result1 && result2) {
                if (result1.distanceOriginToClosestIntersectionPointSquared <
                    result2.distanceOriginToClosestIntersectionPointSquared) {
                    return {
                        closestIntersectionPoint: result1.closestIntersectionPoint,
                        distanceOriginToClosestIntersectionPointSquared: result1.distanceOriginToClosestIntersectionPointSquared,
                        targetPoint: result1.targetPoint,
                        distanceClosestPointToTargetPointSquared: result1.distanceClosestPointToTargetPointSquared,
                        restriction: this,
                    };
                }
                return {
                    closestIntersectionPoint: result2.closestIntersectionPoint,
                    distanceOriginToClosestIntersectionPointSquared: result2.distanceOriginToClosestIntersectionPointSquared,
                    targetPoint: result2.targetPoint,
                    distanceClosestPointToTargetPointSquared: result2.distanceClosestPointToTargetPointSquared,
                    restriction: this,
                };
            }
            const result = (result1 || result2);
            return {
                closestIntersectionPoint: result.closestIntersectionPoint,
                distanceOriginToClosestIntersectionPointSquared: result.distanceOriginToClosestIntersectionPointSquared,
                targetPoint: result.targetPoint,
                distanceClosestPointToTargetPointSquared: result.distanceClosestPointToTargetPointSquared,
                restriction: this,
            };
        }
        const distance = gl_matrix_1.vec3.squaredDistance(pointA, pointB);
        if (distance < __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f")) {
            // check if origin is inside the cylinder
            const distanceOrigin = gl_matrix_1.vec3.squaredDistance(ray.origin, pointB);
            if (distanceOrigin < __classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f")) {
                return {
                    closestIntersectionPoint: pointA,
                    distanceOriginToClosestIntersectionPointSquared: gl_matrix_1.vec3.sqrDist(ray.origin, pointA),
                    targetPoint: pointB,
                    distanceClosestPointToTargetPointSquared: distance,
                    restriction: this,
                };
            }
            // now we calculate the closest point on the cylinder to the ray
            const offset = Math.sqrt(__classPrivateFieldGet(this, _LineRestriction_radius, "f") * __classPrivateFieldGet(this, _LineRestriction_radius, "f") - distance);
            // Compute the entry distance
            const entry = da - offset;
            const closestIntersectionPoint = gl_matrix_1.vec3.scaleAndAdd(gl_matrix_1.vec3.create(), ray.origin, ray.direction, entry);
            return {
                closestIntersectionPoint,
                distanceOriginToClosestIntersectionPointSquared: entry * entry,
                targetPoint: pointB,
                distanceClosestPointToTargetPointSquared: distance,
                restriction: this,
            };
        }
        return;
    }
    // #endregion Public Methods (1)
    // #region Protected Methods (1)
    visibilityChanged() { }
}
exports.LineRestriction = LineRestriction;
_LineRestriction_viewport = new WeakMap(), _LineRestriction_dragLineLength = new WeakMap(), _LineRestriction_dragRay = new WeakMap(), _LineRestriction_point1 = new WeakMap(), _LineRestriction_point1Restriction = new WeakMap(), _LineRestriction_point2 = new WeakMap(), _LineRestriction_point2Restriction = new WeakMap(), _LineRestriction_radius = new WeakMap(), _LineRestriction_snapRestrictions = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=LineRestriction.js.map
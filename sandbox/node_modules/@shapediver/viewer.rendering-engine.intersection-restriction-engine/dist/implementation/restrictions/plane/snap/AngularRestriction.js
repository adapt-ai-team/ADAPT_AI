"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AngularRestriction_activationKey, _AngularRestriction_geometryMathManager, _AngularRestriction_planeRestriction, _AngularRestriction_active, _AngularRestriction_activePolarGrids, _AngularRestriction_angleStep, _AngularRestriction_angleStepEditable, _AngularRestriction_angles, _AngularRestriction_labelNext, _AngularRestriction_labelPrevious, _AngularRestriction_priority, _AngularRestriction_settings;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AngularRestriction = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_rendering_engine_rendering_engine_threejs_1 = require("@shapediver/viewer.rendering-engine.rendering-engine-threejs");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const IRestriction_1 = require("../../../../interfaces/IRestriction");
const AbstractSnapRestriction_1 = require("../../AbstractSnapRestriction");
// #endregion Type aliases (1)
// #region Classes (1)
class AngularRestriction extends AbstractSnapRestriction_1.AbstractSnapRestriction {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(viewport, geometryMathManager, parentNode, planeRestriction, settings, properties) {
        var _a, _b, _c;
        super(viewport, parentNode, "angular");
        // #region Properties (12)
        _AngularRestriction_activationKey.set(this, void 0);
        _AngularRestriction_geometryMathManager.set(this, void 0);
        _AngularRestriction_planeRestriction.set(this, void 0);
        _AngularRestriction_active.set(this, false);
        _AngularRestriction_activePolarGrids.set(this, {
            next: false,
            previous: false,
        });
        _AngularRestriction_angleStep.set(this, void 0);
        _AngularRestriction_angleStepEditable.set(this, true);
        _AngularRestriction_angles.set(this, []);
        _AngularRestriction_labelNext.set(this, void 0);
        _AngularRestriction_labelPrevious.set(this, void 0);
        _AngularRestriction_priority.set(this, 0);
        _AngularRestriction_settings.set(this, void 0);
        __classPrivateFieldSet(this, _AngularRestriction_geometryMathManager, geometryMathManager, "f");
        __classPrivateFieldSet(this, _AngularRestriction_settings, settings, "f");
        __classPrivateFieldSet(this, _AngularRestriction_planeRestriction, planeRestriction, "f");
        __classPrivateFieldSet(this, _AngularRestriction_activationKey, (properties === null || properties === void 0 ? void 0 : properties.activationKey) || "a", "f");
        this.enabled = (_a = properties === null || properties === void 0 ? void 0 : properties.enabled) !== null && _a !== void 0 ? _a : false;
        this._enabledEditable = (_b = properties === null || properties === void 0 ? void 0 : properties.enabledEditable) !== null && _b !== void 0 ? _b : true;
        __classPrivateFieldSet(this, _AngularRestriction_angleStep, (properties === null || properties === void 0 ? void 0 : properties.angleStep) || Math.PI / 12, "f");
        __classPrivateFieldSet(this, _AngularRestriction_angleStepEditable, (_c = properties === null || properties === void 0 ? void 0 : properties.angleStepEditable) !== null && _c !== void 0 ? _c : true, "f");
        __classPrivateFieldSet(this, _AngularRestriction_priority, (properties === null || properties === void 0 ? void 0 : properties.priority) || 0, "f");
        // calculate the angles
        this.calculateAngles();
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (8)
    get active() {
        return __classPrivateFieldGet(this, _AngularRestriction_active, "f");
    }
    set active(value) {
        __classPrivateFieldSet(this, _AngularRestriction_active, value, "f");
        if (value === false) {
            if (__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f"))
                __classPrivateFieldGet(this, _AngularRestriction_labelNext, "f").visible = false;
            if (__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f"))
                __classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f").visible = false;
        }
        else {
            if (__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f") && __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").next)
                __classPrivateFieldGet(this, _AngularRestriction_labelNext, "f").visible = true;
            if (__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f") && __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").previous)
                __classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f").visible = true;
        }
    }
    get angleStep() {
        return __classPrivateFieldGet(this, _AngularRestriction_angleStep, "f");
    }
    set angleStep(value) {
        if (__classPrivateFieldGet(this, _AngularRestriction_angleStepEditable, "f") === false)
            return;
        __classPrivateFieldSet(this, _AngularRestriction_angleStep, value, "f");
        this.calculateAngles();
    }
    get angleStepEditable() {
        return __classPrivateFieldGet(this, _AngularRestriction_angleStepEditable, "f");
    }
    get enabledEditable() {
        return this._enabledEditable;
    }
    get priority() {
        return __classPrivateFieldGet(this, _AngularRestriction_priority, "f");
    }
    set priority(value) {
        __classPrivateFieldSet(this, _AngularRestriction_priority, value, "f");
    }
    // #endregion Public Getters And Setters (8)
    // #region Public Methods (2)
    snap(ray, point, distance, metaData) {
        var _a;
        if (!(0, IRestriction_1.isDrawingRestriction)(metaData))
            return;
        // check if the activation key is pressed
        const isKeyToggled = ((_a = metaData === null || metaData === void 0 ? void 0 : metaData.toggledKeys) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
            (metaData === null || metaData === void 0 ? void 0 : metaData.toggledKeys[0]) === __classPrivateFieldGet(this, _AngularRestriction_activationKey, "f");
        // if the restriction is not enabled OR the activation key is set and the key is not pressed, return
        if (this.enabled === false && !isKeyToggled)
            return;
        if (__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f"))
            __classPrivateFieldGet(this, _AngularRestriction_labelNext, "f").visible = false;
        if (__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f"))
            __classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f").visible = false;
        __classPrivateFieldSet(this, _AngularRestriction_activePolarGrids, {
            next: false,
            previous: false,
        }, "f");
        const positionArray = metaData === null || metaData === void 0 ? void 0 : metaData.positionArray;
        if (!positionArray)
            return;
        let previousIndex, nextIndex;
        if (metaData !== undefined && metaData.index !== undefined) {
            previousIndex = this.getPreviousIndex(metaData.index, positionArray);
            nextIndex = this.getNextIndex(metaData.index, positionArray);
        }
        else {
            // if no index was provided, it is a new point
            previousIndex = positionArray.length / 3 - 1;
            nextIndex = 0;
        }
        const previousPreviousIndex = this.getPreviousIndex(previousIndex, positionArray);
        const nextNextIndex = this.getNextIndex(nextIndex, positionArray);
        if (positionArray.length / 3 < 2)
            return;
        /**
         * Explanation of the algorithm:
         * 1. Project the point onto the XY-Plane
         * 2. Find the next point and the previous point
         * 3. Project the next and previous point onto the XY-Plane
         * 4. Calculate the angle between the point and the next and previous point
         * 5. Determine which if the angles are in the range to snap to
         *    a. If both are in the range, snap to the intersection of the two lines
         *    b. If only one is in the range, snap to the intersection of the line and the plane
         *    c. If none is in the range, return
         * 6. Reverse the projection to the original coordinate system
         */
        // get the next and previous point from the position array
        const nextPointFromData = gl_matrix_1.vec3.fromValues(positionArray.at(nextIndex * 3), positionArray.at(nextIndex * 3 + 1), positionArray.at(nextIndex * 3 + 2));
        const nextNextPointFromData = gl_matrix_1.vec3.fromValues(positionArray.at(nextNextIndex * 3), positionArray.at(nextNextIndex * 3 + 1), positionArray.at(nextNextIndex * 3 + 2));
        const previousPointFromData = gl_matrix_1.vec3.fromValues(positionArray.at(previousIndex * 3), positionArray.at(previousIndex * 3 + 1), positionArray.at(previousIndex * 3 + 2));
        const previousPreviousPointFromData = gl_matrix_1.vec3.fromValues(positionArray.at(previousPreviousIndex * 3), positionArray.at(previousPreviousIndex * 3 + 1), positionArray.at(previousPreviousIndex * 3 + 2));
        // project them onto the same plane as the point
        const nextPointProjected = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), nextPointFromData, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), nextPointFromData, point), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal)));
        const nextNextPointProjected = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), nextNextPointFromData, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), nextNextPointFromData, point), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal)));
        const previousPointProjected = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), previousPointFromData, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), previousPointFromData, point), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal)));
        const previousPreviousPointProjected = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), previousPreviousPointFromData, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal, gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), previousPreviousPointFromData, point), __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").normal)));
        // project the point onto the XY-Plane
        const pointProjected = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), point, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationToXYPlaneMatrix);
        gl_matrix_1.vec3.transformMat4(nextPointProjected, nextPointProjected, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationToXYPlaneMatrix);
        gl_matrix_1.vec3.transformMat4(nextNextPointProjected, nextNextPointProjected, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationToXYPlaneMatrix);
        gl_matrix_1.vec3.transformMat4(previousPointProjected, previousPointProjected, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationToXYPlaneMatrix);
        gl_matrix_1.vec3.transformMat4(previousPreviousPointProjected, previousPreviousPointProjected, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationToXYPlaneMatrix);
        // calculate the angle between the next and previous point and the point to restrict on the axis
        const { angularDifference: angularDifferenceNext, crossProduct: crossProductNext, closestAngle: closestAngleNext, } = this.getAngularDifference({ start: nextPointProjected, end: nextNextPointProjected }, { start: nextPointProjected, end: pointProjected });
        const { angularDifference: angularDifferencePrevious, crossProduct: crossProductPrevious, closestAngle: closestAnglePrevious, } = this.getAngularDifference({
            start: previousPointProjected,
            end: previousPreviousPointProjected,
        }, { start: previousPointProjected, end: pointProjected });
        // calculate the distances in screen space so we can check how close it is
        const resultPointNextAngle = gl_matrix_1.vec3.rotateZ(gl_matrix_1.vec3.create(), pointProjected, nextPointProjected, crossProductNext[2] < 0
            ? -angularDifferenceNext
            : angularDifferenceNext);
        const screenSpaceDistanceCheckNextAngle = __classPrivateFieldGet(this, _AngularRestriction_geometryMathManager, "f").screenSpaceDistanceCheck(resultPointNextAngle, pointProjected, __classPrivateFieldGet(this, _AngularRestriction_settings, "f").points.size_0 *
            __classPrivateFieldGet(this, _AngularRestriction_settings, "f").distanceMultiplicationFactor);
        const resultPointPreviousAngle = gl_matrix_1.vec3.rotateZ(gl_matrix_1.vec3.create(), pointProjected, previousPointProjected, crossProductPrevious[2] < 0
            ? -angularDifferencePrevious
            : angularDifferencePrevious);
        const screenSpaceDistanceCheckPreviousAngle = __classPrivateFieldGet(this, _AngularRestriction_geometryMathManager, "f").screenSpaceDistanceCheck(resultPointPreviousAngle, pointProjected, __classPrivateFieldGet(this, _AngularRestriction_settings, "f").points.size_0 *
            __classPrivateFieldGet(this, _AngularRestriction_settings, "f").distanceMultiplicationFactor);
        if (screenSpaceDistanceCheckNextAngle.check === false &&
            screenSpaceDistanceCheckPreviousAngle.check === false)
            return;
        // snap to clear defined point if both distances are smaller than threshold
        if (positionArray.length > 6 &&
            screenSpaceDistanceCheckNextAngle.check === true &&
            screenSpaceDistanceCheckPreviousAngle.check === true) {
            const rayDirectionNext = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), resultPointNextAngle, nextPointProjected));
            const rayDirectionPrevious = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), resultPointPreviousAngle, previousPointProjected));
            const crossProduct = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), rayDirectionNext, rayDirectionPrevious);
            const crossProductLength = gl_matrix_1.vec3.length(crossProduct);
            if (crossProductLength < 0.001) {
                gl_matrix_1.vec3.transformMat4(resultPointNextAngle, resultPointNextAngle, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationFromXYPlaneMatrix);
                return {
                    targetPoint: resultPointNextAngle,
                    distanceClosestPointToTargetPointSquared: gl_matrix_1.vec3.sqrDist(resultPointNextAngle, point),
                    closestIntersectionPoint: point,
                    distanceOriginToClosestIntersectionPointSquared: distance,
                    restriction: __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f"),
                    snapRestriction: this,
                };
            }
            const t = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), previousPointProjected, nextPointProjected);
            const u = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, rayDirectionPrevious);
            const v = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), t, rayDirectionNext);
            const tValue = gl_matrix_1.vec3.dot(u, crossProduct) / Math.pow(crossProductLength, 2);
            const uValue = gl_matrix_1.vec3.dot(v, crossProduct) / Math.pow(crossProductLength, 2);
            if (tValue < 0 || uValue < 0) {
                gl_matrix_1.vec3.transformMat4(resultPointNextAngle, resultPointNextAngle, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationFromXYPlaneMatrix);
                return {
                    targetPoint: resultPointNextAngle,
                    distanceClosestPointToTargetPointSquared: gl_matrix_1.vec3.sqrDist(resultPointNextAngle, point),
                    closestIntersectionPoint: point,
                    distanceOriginToClosestIntersectionPointSquared: distance,
                    restriction: __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f"),
                    snapRestriction: this,
                };
            }
            const intersection = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), nextPointProjected, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), rayDirectionNext, tValue));
            __classPrivateFieldSet(this, _AngularRestriction_labelNext, this.createGrid(__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f"), nextPointFromData, closestAngleNext), "f");
            __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").next = true;
            __classPrivateFieldSet(this, _AngularRestriction_labelPrevious, this.createGrid(__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f"), previousPointFromData, closestAnglePrevious), "f");
            __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").previous = true;
            // reverse the projection to the original coordinate system
            gl_matrix_1.vec3.transformMat4(intersection, intersection, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationFromXYPlaneMatrix);
            return {
                targetPoint: intersection,
                distanceClosestPointToTargetPointSquared: gl_matrix_1.vec3.sqrDist(intersection, point),
                closestIntersectionPoint: point,
                distanceOriginToClosestIntersectionPointSquared: distance,
                restriction: __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f"),
                snapRestriction: this,
            };
        }
        // check which distance to the projection is smaller
        if (screenSpaceDistanceCheckNextAngle.distanceSquared <
            screenSpaceDistanceCheckPreviousAngle.distanceSquared) {
            __classPrivateFieldSet(this, _AngularRestriction_labelNext, this.createGrid(__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f"), nextPointFromData, closestAngleNext), "f");
            __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").next = true;
            // reverse the projection to the original coordinate system
            gl_matrix_1.vec3.transformMat4(resultPointNextAngle, resultPointNextAngle, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationFromXYPlaneMatrix);
            return {
                targetPoint: resultPointNextAngle,
                distanceClosestPointToTargetPointSquared: gl_matrix_1.vec3.sqrDist(resultPointNextAngle, point),
                closestIntersectionPoint: point,
                distanceOriginToClosestIntersectionPointSquared: distance,
                restriction: __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f"),
                snapRestriction: this,
            };
        }
        else {
            __classPrivateFieldSet(this, _AngularRestriction_labelPrevious, this.createGrid(__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f"), previousPointFromData, closestAnglePrevious), "f");
            __classPrivateFieldGet(this, _AngularRestriction_activePolarGrids, "f").previous = true;
            // reverse the projection to the original coordinate system
            gl_matrix_1.vec3.transformMat4(resultPointPreviousAngle, resultPointPreviousAngle, __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f").transformationFromXYPlaneMatrix);
            return {
                targetPoint: resultPointPreviousAngle,
                distanceClosestPointToTargetPointSquared: gl_matrix_1.vec3.sqrDist(resultPointPreviousAngle, point),
                closestIntersectionPoint: point,
                distanceOriginToClosestIntersectionPointSquared: distance,
                restriction: __classPrivateFieldGet(this, _AngularRestriction_planeRestriction, "f"),
                snapRestriction: this,
            };
        }
    }
    updatePlaneDefinition() { }
    // #endregion Public Methods (2)
    // #region Protected Methods (1)
    visibilityChanged(visible) {
        if (visible === false) {
            if (__classPrivateFieldGet(this, _AngularRestriction_labelNext, "f"))
                __classPrivateFieldGet(this, _AngularRestriction_labelNext, "f").visible = false;
            if (__classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f"))
                __classPrivateFieldGet(this, _AngularRestriction_labelPrevious, "f").visible = false;
        }
    }
    // #endregion Protected Methods (1)
    // #region Private Methods (5)
    calculateAngles() {
        __classPrivateFieldSet(this, _AngularRestriction_angles, [], "f");
        for (let i = 0; i <= Math.PI + 0.0001; i += __classPrivateFieldGet(this, _AngularRestriction_angleStep, "f")) {
            __classPrivateFieldGet(this, _AngularRestriction_angles, "f").push(i);
        }
    }
    createGrid(label, position, angle) {
        if (label)
            this._object3D.remove(label);
        let radius = viewer_1.sceneTree.root.boundingBox.boundingSphere.radius / 100;
        if (radius === Infinity)
            radius = 1;
        const text = document.createElement("div");
        text.className = "label";
        label = new viewer_rendering_engine_rendering_engine_threejs_1.CSS2DObject(text);
        // remove the old style, if there is one
        document.head.querySelectorAll("style").forEach((style) => {
            var _a;
            if ((_a = style.textContent) === null || _a === void 0 ? void 0 : _a.includes(label.uuid))
                document.head.removeChild(style);
        });
        const parent = document.createElement("div");
        parent.className = `angular-label-parent-${label.uuid}`;
        const child = document.createElement("div");
        child.className = `angular-label-${label.uuid}`;
        const style = document.createElement("style");
        style.textContent = `
            .angular-label-${label.uuid} {
                display: flex;
                justify-content: center;
                align-items: center;
                width: 32px;
                height: 32px;
                color: white;
                background-color: ${__classPrivateFieldGet(this, _AngularRestriction_settings, "f").points.color_1};
                border-radius: 50%;
                font-size: 16px;
                text-align: center;
            }

            .angular-label-parent-${label.uuid} {
                display: flex;
                justify-content: center;
                align-items: center;
                width: 40px; /* 32px + 2 * 4px border width */
                height: 40px; /* 32px + 2 * 4px border width */
                border-radius: 50%;
                background: conic-gradient(
                    ${__classPrivateFieldGet(this, _AngularRestriction_settings, "f").points.color_2} 0% ${(angle / Math.PI) * 100}%,
                    ${__classPrivateFieldGet(this, _AngularRestriction_settings, "f").points.color_1} ${(angle / Math.PI) * 100}% 100%
                );
            }
        `;
        document.head.appendChild(style);
        parent.appendChild(child);
        child.textContent = `${(0, viewer_shared_services_1.numberCleaner)((angle / Math.PI) * 180)}°`;
        text.appendChild(parent);
        label.position.set(position[0], position[1], position[2]);
        label.visible = false;
        this._object3D.add(label);
        return label;
    }
    getAngularDifference(line, referenceLine) {
        const lineDirection = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), line.end, line.start));
        const referenceLineDirection = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), referenceLine.end, referenceLine.start));
        // calculate the angle between the lineDirection and the referenceLineDirection
        const angleReference = gl_matrix_1.vec3.angle(lineDirection, referenceLineDirection);
        const crossProduct = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), lineDirection, referenceLineDirection);
        // find the angle that is closest to the angle of the previous point
        let closestAngle = __classPrivateFieldGet(this, _AngularRestriction_angles, "f")[0];
        for (let i = 0; i < __classPrivateFieldGet(this, _AngularRestriction_angles, "f").length; i++) {
            const angle = __classPrivateFieldGet(this, _AngularRestriction_angles, "f")[i];
            if (Math.abs(angleReference - angle) <
                Math.abs(angleReference - closestAngle))
                closestAngle = angle;
        }
        // move the point to the closest angle
        const angularDifference = closestAngle - angleReference;
        return {
            angularDifference,
            crossProduct,
            closestAngle,
        };
    }
    getNextIndex(index, positionArray) {
        return index + 1 > positionArray.length / 3 - 1 ? 0 : index + 1;
    }
    getPreviousIndex(index, positionArray) {
        return index - 1 < 0 ? positionArray.length / 3 - 1 : index - 1;
    }
}
exports.AngularRestriction = AngularRestriction;
_AngularRestriction_activationKey = new WeakMap(), _AngularRestriction_geometryMathManager = new WeakMap(), _AngularRestriction_planeRestriction = new WeakMap(), _AngularRestriction_active = new WeakMap(), _AngularRestriction_activePolarGrids = new WeakMap(), _AngularRestriction_angleStep = new WeakMap(), _AngularRestriction_angleStepEditable = new WeakMap(), _AngularRestriction_angles = new WeakMap(), _AngularRestriction_labelNext = new WeakMap(), _AngularRestriction_labelPrevious = new WeakMap(), _AngularRestriction_priority = new WeakMap(), _AngularRestriction_settings = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=AngularRestriction.js.map
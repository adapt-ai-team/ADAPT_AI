"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PlaneRestriction_properties, _PlaneRestriction_viewport, _PlaneRestriction_angularRestriction, _PlaneRestriction_axisRestriction, _PlaneRestriction_cameraId, _PlaneRestriction_gridRestriction, _PlaneRestriction_normal, _PlaneRestriction_origin, _PlaneRestriction_plane, _PlaneRestriction_snapRestrictions, _PlaneRestriction_transformationFromXYPlaneMatrix, _PlaneRestriction_transformationToXYPlaneMatrix, _PlaneRestriction_vectorU, _PlaneRestriction_vectorV;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaneRestriction = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const gl_matrix_1 = require("gl-matrix");
const IRestriction_1 = require("../../../interfaces/IRestriction");
const AbstractRestriction_1 = require("../AbstractRestriction");
const AngularRestriction_1 = require("./snap/AngularRestriction");
const AxisRestriction_1 = require("./snap/AxisRestriction");
const GridRestriction_1 = require("./snap/GridRestriction");
// #endregion Type aliases (1)
// #region Classes (1)
class PlaneRestriction extends AbstractRestriction_1.AbstractRestriction {
    // #endregion Properties (14)
    // #region Constructors (1)
    constructor(viewport, geometryMathManager, parentNode, id, settings, properties) {
        super(viewport, parentNode, id, properties);
        // #region Properties (14)
        _PlaneRestriction_properties.set(this, void 0);
        _PlaneRestriction_viewport.set(this, void 0);
        _PlaneRestriction_angularRestriction.set(this, void 0);
        _PlaneRestriction_axisRestriction.set(this, void 0);
        _PlaneRestriction_cameraId.set(this, "");
        _PlaneRestriction_gridRestriction.set(this, void 0);
        _PlaneRestriction_normal.set(this, gl_matrix_1.vec3.create());
        _PlaneRestriction_origin.set(this, gl_matrix_1.vec3.create());
        _PlaneRestriction_plane.set(this, new viewer_shared_math_1.Plane());
        _PlaneRestriction_snapRestrictions.set(this, void 0);
        _PlaneRestriction_transformationFromXYPlaneMatrix.set(this, gl_matrix_1.mat4.create());
        _PlaneRestriction_transformationToXYPlaneMatrix.set(this, gl_matrix_1.mat4.create());
        _PlaneRestriction_vectorU.set(this, gl_matrix_1.vec3.create());
        _PlaneRestriction_vectorV.set(this, gl_matrix_1.vec3.create());
        __classPrivateFieldSet(this, _PlaneRestriction_viewport, viewport, "f");
        __classPrivateFieldSet(this, _PlaneRestriction_cameraId, __classPrivateFieldGet(this, _PlaneRestriction_viewport, "f").camera.id, "f");
        __classPrivateFieldSet(this, _PlaneRestriction_properties, properties, "f");
        __classPrivateFieldSet(this, _PlaneRestriction_gridRestriction, new GridRestriction_1.GridRestriction(viewport, geometryMathManager, parentNode, this, __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").gridSnapRestriction), "f");
        __classPrivateFieldSet(this, _PlaneRestriction_angularRestriction, new AngularRestriction_1.AngularRestriction(viewport, geometryMathManager, parentNode, this, settings, __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").angularSnapRestriction), "f");
        __classPrivateFieldSet(this, _PlaneRestriction_axisRestriction, new AxisRestriction_1.AxisRestriction(viewport, geometryMathManager, parentNode, this, __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").axisSnapRestriction), "f");
        this.updatePlaneDefinition();
        __classPrivateFieldSet(this, _PlaneRestriction_snapRestrictions, {
            grid: __classPrivateFieldGet(this, _PlaneRestriction_gridRestriction, "f"),
            angular: __classPrivateFieldGet(this, _PlaneRestriction_angularRestriction, "f"),
            axis: __classPrivateFieldGet(this, _PlaneRestriction_axisRestriction, "f"),
        }, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (14)
    get angularRestriction() {
        return __classPrivateFieldGet(this, _PlaneRestriction_angularRestriction, "f");
    }
    get axisRestriction() {
        return __classPrivateFieldGet(this, _PlaneRestriction_axisRestriction, "f");
    }
    get gridRestriction() {
        return __classPrivateFieldGet(this, _PlaneRestriction_gridRestriction, "f");
    }
    get normal() {
        return __classPrivateFieldGet(this, _PlaneRestriction_normal, "f");
    }
    get origin() {
        return __classPrivateFieldGet(this, _PlaneRestriction_origin, "f");
    }
    set origin(value) {
        __classPrivateFieldSet(this, _PlaneRestriction_origin, value, "f");
        this.updatePlaneDefinition();
    }
    get snapRestrictions() {
        return __classPrivateFieldGet(this, _PlaneRestriction_snapRestrictions, "f");
    }
    get transformationFromXYPlaneMatrix() {
        return __classPrivateFieldGet(this, _PlaneRestriction_transformationFromXYPlaneMatrix, "f");
    }
    get transformationToXYPlaneMatrix() {
        return __classPrivateFieldGet(this, _PlaneRestriction_transformationToXYPlaneMatrix, "f");
    }
    get vectorU() {
        return __classPrivateFieldGet(this, _PlaneRestriction_vectorU, "f");
    }
    set vectorU(value) {
        __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_u = value;
        this.updatePlaneDefinition();
    }
    get vectorV() {
        return __classPrivateFieldGet(this, _PlaneRestriction_vectorV, "f");
    }
    set vectorV(value) {
        __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_v = value;
        this.updatePlaneDefinition();
    }
    // #endregion Public Getters And Setters (14)
    // #region Public Methods (1)
    rayTrace(ray, metaData) {
        if (this.enabled === false)
            return;
        if ((0, IRestriction_1.isDrawingRestriction)(metaData)) {
            if (__classPrivateFieldGet(this, _PlaneRestriction_cameraId, "f") !== __classPrivateFieldGet(this, _PlaneRestriction_viewport, "f").camera.id)
                this.updatePlaneDefinition();
            let origin = __classPrivateFieldGet(this, _PlaneRestriction_origin, "f");
            if (metaData.startPoint)
                origin = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _PlaneRestriction_origin, "f"), gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _PlaneRestriction_normal, "f"), gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _PlaneRestriction_origin, "f"), metaData.startPoint), __classPrivateFieldGet(this, _PlaneRestriction_normal, "f"))));
            // find intersection of ray and plane
            const t = (gl_matrix_1.vec3.dot(origin, __classPrivateFieldGet(this, _PlaneRestriction_normal, "f")) -
                gl_matrix_1.vec3.dot(ray.origin, __classPrivateFieldGet(this, _PlaneRestriction_normal, "f"))) /
                gl_matrix_1.vec3.dot(ray.direction, __classPrivateFieldGet(this, _PlaneRestriction_normal, "f"));
            const intersection = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(t, t, t)));
            return this.snap(ray, intersection, t, metaData);
        }
        else if ((0, IRestriction_1.isDraggingRestriction)(metaData)) {
            const distance = __classPrivateFieldGet(this, _PlaneRestriction_plane, "f").intersect(ray.origin, ray.direction);
            if (distance && distance > 0) {
                const intersection = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(distance, distance, distance)), ray.origin);
                return this.snap(ray, intersection, distance, metaData);
            }
        }
    }
    // #endregion Public Methods (1)
    // #region Protected Methods (1)
    visibilityChanged() { }
    // #endregion Protected Methods (1)
    // #region Private Methods (4)
    createDefaultPlane(camera) {
        if (camera.type === viewer_1.CAMERA_TYPE.PERSPECTIVE ||
            (camera.type === viewer_1.CAMERA_TYPE.ORTHOGRAPHIC &&
                camera.direction ===
                    viewer_1.ORTHOGRAPHIC_CAMERA_DIRECTION.CUSTOM)) {
            __classPrivateFieldSet(this, _PlaneRestriction_vectorU, gl_matrix_1.vec3.fromValues(1, 0, 0), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_vectorV, gl_matrix_1.vec3.fromValues(0, 1, 0), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_normal, gl_matrix_1.vec3.fromValues(0, 0, 1), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_origin, gl_matrix_1.vec3.fromValues(0, 0, 0), "f");
        }
        else {
            const orthographicCamera = camera;
            const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), orthographicCamera.target, orthographicCamera.position));
            const up = orthographicCamera.direction ===
                viewer_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP ||
                orthographicCamera.direction ===
                    viewer_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM
                ? gl_matrix_1.vec3.fromValues(0, 1, 0)
                : gl_matrix_1.vec3.fromValues(0, 0, 1);
            __classPrivateFieldSet(this, _PlaneRestriction_origin, gl_matrix_1.vec3.fromValues(0, 0, 0), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_normal, gl_matrix_1.vec3.negate(gl_matrix_1.vec3.create(), direction), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_vectorU, gl_matrix_1.vec3.clone(up), "f");
            __classPrivateFieldSet(this, _PlaneRestriction_vectorV, gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _PlaneRestriction_normal, "f"), __classPrivateFieldGet(this, _PlaneRestriction_vectorU, "f"))), "f");
        }
    }
    createTransformationMatrices() {
        // Calculate the transformation matrix for the rotation
        const rotationMatrix = gl_matrix_1.mat4.fromValues(__classPrivateFieldGet(this, _PlaneRestriction_vectorU, "f")[0], __classPrivateFieldGet(this, _PlaneRestriction_vectorV, "f")[0], __classPrivateFieldGet(this, _PlaneRestriction_normal, "f")[0], 0, __classPrivateFieldGet(this, _PlaneRestriction_vectorU, "f")[1], __classPrivateFieldGet(this, _PlaneRestriction_vectorV, "f")[1], __classPrivateFieldGet(this, _PlaneRestriction_normal, "f")[1], 0, __classPrivateFieldGet(this, _PlaneRestriction_vectorU, "f")[2], __classPrivateFieldGet(this, _PlaneRestriction_vectorV, "f")[2], __classPrivateFieldGet(this, _PlaneRestriction_normal, "f")[2], 0, 0, 0, 0, 1);
        let rotationMatrixInverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), rotationMatrix);
        if (!rotationMatrixInverse)
            rotationMatrixInverse = gl_matrix_1.mat4.create();
        const pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(__classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[0], __classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[1], __classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[2]));
        const pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-__classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[0], -__classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[1], -__classPrivateFieldGet(this, _PlaneRestriction_origin, "f")[2]));
        gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _PlaneRestriction_transformationToXYPlaneMatrix, "f"), pivotMatrix, rotationMatrix);
        gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _PlaneRestriction_transformationToXYPlaneMatrix, "f"), __classPrivateFieldGet(this, _PlaneRestriction_transformationToXYPlaneMatrix, "f"), pivotMatrixInverse);
        gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _PlaneRestriction_transformationFromXYPlaneMatrix, "f"), pivotMatrix, rotationMatrixInverse);
        gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _PlaneRestriction_transformationFromXYPlaneMatrix, "f"), __classPrivateFieldGet(this, _PlaneRestriction_transformationFromXYPlaneMatrix, "f"), pivotMatrixInverse);
    }
    snap(ray, point, distance, metaData) {
        if (this.enabled === false)
            return;
        if (__classPrivateFieldGet(this, _PlaneRestriction_cameraId, "f") !== __classPrivateFieldGet(this, _PlaneRestriction_viewport, "f").camera.id)
            this.updatePlaneDefinition();
        const sortedSnapRestrictions = Object.values(__classPrivateFieldGet(this, _PlaneRestriction_snapRestrictions, "f")).sort((a, b) => b.priority - a.priority);
        // group snap restrictions by priority
        const groupedSnapRestrictions = {};
        for (const snapRestriction of sortedSnapRestrictions) {
            if (!groupedSnapRestrictions[snapRestriction.priority])
                groupedSnapRestrictions[snapRestriction.priority] = [];
            groupedSnapRestrictions[snapRestriction.priority].push(snapRestriction);
        }
        // call snap method for each group
        for (const snapRestrictions of Object.values(groupedSnapRestrictions)) {
            const results = [];
            for (const snapRestriction of snapRestrictions) {
                results.push(snapRestriction.snap(ray, point, distance, metaData));
            }
            const indexedResults = results.map((value, index) => ({
                index,
                value,
            }));
            // find the result that is closest to the point and set the snap restriction to active
            indexedResults.sort((a, b) => {
                if (!a.value)
                    return 1;
                if (!b.value)
                    return -1;
                return (gl_matrix_1.vec3.squaredDistance(point, a.value.targetPoint) -
                    gl_matrix_1.vec3.squaredDistance(point, b.value.targetPoint));
            });
            for (const snapRestriction of snapRestrictions) {
                snapRestriction.active = false;
            }
            // if a snap restriction returned a result, return it
            if (indexedResults[0].value !== undefined) {
                snapRestrictions[indexedResults[0].index].active = true;
                return indexedResults[0].value;
            }
        }
        return {
            closestIntersectionPoint: point,
            distanceOriginToClosestIntersectionPointSquared: gl_matrix_1.vec3.sqrDist(ray.origin, point),
            targetPoint: point,
            distanceClosestPointToTargetPointSquared: 0,
            restriction: this,
        };
    }
    updatePlaneDefinition() {
        const camera = __classPrivateFieldGet(this, _PlaneRestriction_viewport, "f").camera;
        __classPrivateFieldSet(this, _PlaneRestriction_cameraId, camera.id, "f");
        const origin = __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").origin
            ? gl_matrix_1.vec3.clone(__classPrivateFieldGet(this, _PlaneRestriction_properties, "f").origin)
            : gl_matrix_1.vec3.fromValues(0, 0, 0);
        const vectorU = __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_u
            ? gl_matrix_1.vec3.clone(__classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_u)
            : undefined;
        const vectorV = __classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_v
            ? gl_matrix_1.vec3.clone(__classPrivateFieldGet(this, _PlaneRestriction_properties, "f").vector_v)
            : undefined;
        const planeDefined = origin && vectorU && vectorV;
        let normal = gl_matrix_1.vec3.fromValues(0, 0, 1);
        if (planeDefined) {
            gl_matrix_1.vec3.normalize(vectorU, vectorU);
            gl_matrix_1.vec3.normalize(vectorV, vectorV);
            normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), vectorU, vectorV));
            if (gl_matrix_1.vec3.dot(vectorU, vectorV) !== 0)
                gl_matrix_1.vec3.normalize(vectorV, gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), normal, vectorU));
            if (camera.type === viewer_1.CAMERA_TYPE.ORTHOGRAPHIC) {
                const cameraApi = camera;
                const cameraDirection = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), cameraApi.target, cameraApi.position));
                // if the dot product of the camera direction and the normal tells us that they are parallel
                // the plane is perpendicular to the camera direction
                if (Math.abs(gl_matrix_1.vec3.dot(cameraDirection, normal)) < 0.0001) {
                    this.createDefaultPlane(camera);
                }
                else {
                    __classPrivateFieldSet(this, _PlaneRestriction_vectorU, vectorU, "f");
                    __classPrivateFieldSet(this, _PlaneRestriction_vectorV, vectorV, "f");
                    __classPrivateFieldSet(this, _PlaneRestriction_normal, normal, "f");
                    __classPrivateFieldSet(this, _PlaneRestriction_origin, origin, "f");
                }
            }
            else {
                __classPrivateFieldSet(this, _PlaneRestriction_vectorU, vectorU, "f");
                __classPrivateFieldSet(this, _PlaneRestriction_vectorV, vectorV, "f");
                __classPrivateFieldSet(this, _PlaneRestriction_normal, normal, "f");
                __classPrivateFieldSet(this, _PlaneRestriction_origin, origin, "f");
            }
        }
        else {
            this.createDefaultPlane(camera);
        }
        __classPrivateFieldSet(this, _PlaneRestriction_plane, new viewer_shared_math_1.Plane().setFromNormalAndCoplanarPoint(__classPrivateFieldGet(this, _PlaneRestriction_normal, "f"), __classPrivateFieldGet(this, _PlaneRestriction_origin, "f")), "f");
        this.createTransformationMatrices();
        __classPrivateFieldGet(this, _PlaneRestriction_gridRestriction, "f").updatePlaneDefinition();
        __classPrivateFieldGet(this, _PlaneRestriction_angularRestriction, "f").updatePlaneDefinition();
        __classPrivateFieldGet(this, _PlaneRestriction_axisRestriction, "f").updatePlaneDefinition();
    }
}
exports.PlaneRestriction = PlaneRestriction;
_PlaneRestriction_properties = new WeakMap(), _PlaneRestriction_viewport = new WeakMap(), _PlaneRestriction_angularRestriction = new WeakMap(), _PlaneRestriction_axisRestriction = new WeakMap(), _PlaneRestriction_cameraId = new WeakMap(), _PlaneRestriction_gridRestriction = new WeakMap(), _PlaneRestriction_normal = new WeakMap(), _PlaneRestriction_origin = new WeakMap(), _PlaneRestriction_plane = new WeakMap(), _PlaneRestriction_snapRestrictions = new WeakMap(), _PlaneRestriction_transformationFromXYPlaneMatrix = new WeakMap(), _PlaneRestriction_transformationToXYPlaneMatrix = new WeakMap(), _PlaneRestriction_vectorU = new WeakMap(), _PlaneRestriction_vectorV = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=PlaneRestriction.js.map
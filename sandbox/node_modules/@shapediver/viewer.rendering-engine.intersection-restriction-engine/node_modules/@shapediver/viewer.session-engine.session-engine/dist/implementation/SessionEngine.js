"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SessionEngine_customizationBusyModes, _SessionEngine_customizationProcess, _SessionEngine_parameterHistory, _SessionEngine_parameterHistoryCall, _SessionEngine_parameterHistoryForward;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionEngine = void 0;
const sdk_geometry_api_sdk_v2_1 = require("@shapediver/sdk.geometry-api-sdk-v2");
const viewer_settings_1 = require("@shapediver/viewer.settings");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const DrawingParameter_1 = require("./dto/DrawingParameter");
const Export_1 = require("./dto/Export");
const FileParameter_1 = require("./dto/FileParameter");
const DraggingParameter_1 = require("./dto/interaction/DraggingParameter");
const GumballParameter_1 = require("./dto/interaction/GumballParameter");
const SelectionParameter_1 = require("./dto/interaction/SelectionParameter");
const Output_1 = require("./dto/Output");
const Parameter_1 = require("./dto/Parameter");
const OutputDelayException_1 = require("./OutputDelayException");
const OutputLoader_1 = require("./OutputLoader");
const SessionData_1 = require("./SessionData");
const SessionTreeNode_1 = require("./SessionTreeNode");
/* eslint-disable @typescript-eslint/no-empty-function */
class SessionEngine {
    // #endregion Properties (50)
    // #region Constructors (1)
    /**
     * Can be use to initialize a session with the ticket/guid and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties) {
        // #region Properties (50)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._exports = {};
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._outputs = {};
        this._outputsFreeze = {};
        this._parameterValues = {};
        this._parameters = {};
        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;
        this._sceneTree = viewer_shared_node_tree_1.Tree.instance;
        this._sessionEngineId = viewer_shared_services_1.UuidGenerator.instance.create();
        this._settingsEngine = new viewer_shared_services_1.SettingsEngine();
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        _SessionEngine_customizationBusyModes.set(this, []);
        _SessionEngine_customizationProcess.set(this, void 0);
        _SessionEngine_parameterHistory.set(this, []);
        _SessionEngine_parameterHistoryCall.set(this, false);
        _SessionEngine_parameterHistoryForward.set(this, []);
        this._allowOutputLoading = true;
        this._automaticSceneUpdate = true;
        this._closeOnFailure = () => __awaiter(this, void 0, void 0, function* () { });
        this._closed = false;
        this._customizeOnParameterChange = false;
        this._dataCache = {};
        this._excludeViewports = [];
        this._headers = {
            "X-ShapeDiver-Origin": viewer_shared_services_1.SystemInfo.instance.origin,
            "X-ShapeDiver-SessionEngineId": this._sessionEngineId,
            "X-ShapeDiver-BuildVersion": "",
            "X-ShapeDiver-BuildDate": "",
        };
        this._initialized = false;
        this._loadSdtf = false;
        this._retryCounter = 0;
        this._updateCallback = null;
        this._viewerSettingsVersion = viewer_settings_1.latestVersion;
        this._viewerSettingsVersionBackend = viewer_settings_1.latestVersion;
        this._id = properties.id;
        this._node = new viewer_shared_node_tree_1.TreeNode(properties.id);
        this._guid = properties.guid;
        this._ticket = properties.ticket;
        this._modelViewUrl = properties.modelViewUrl;
        this._excludeViewports = properties.excludeViewports || [];
        this._jwtToken = properties.jwtToken;
        this._allowOutputLoading = properties.allowOutputLoading;
        this._loadSdtf = properties.loadSdtf;
        this._modelStateId = properties.modelStateId;
        this._modelStateValidationMode = properties.modelStateValidationMode;
        this._throwOnCustomizationError =
            properties.throwOnCustomizationError !== undefined
                ? properties.throwOnCustomizationError
                : false;
        this._headers["X-ShapeDiver-BuildDate"] = properties.buildDate;
        this._headers["X-ShapeDiver-BuildVersion"] = properties.buildVersion;
        this._outputLoader = new OutputLoader_1.OutputLoader(this);
        try {
            this._sdk = (0, sdk_geometry_api_sdk_v2_1.create)(this._modelViewUrl, this._jwtToken);
            this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.REQUEST_HEADERS, this._headers);
        }
        catch (e) {
            throw this._httpClient.convertError(e);
        }
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (28)
    get automaticSceneUpdate() {
        return this._automaticSceneUpdate;
    }
    set automaticSceneUpdate(value) {
        this._automaticSceneUpdate = value;
        value && this._closed === false
            ? this.addToSceneTree(this._node)
            : this.removeFromSceneTree(this._node);
    }
    get canUploadGLTF() {
        try {
            this.checkAvailability("gltf-upload");
            return true;
        }
        catch (e) {
            return false;
        }
    }
    get customizeOnParameterChange() {
        return this._customizeOnParameterChange;
    }
    set customizeOnParameterChange(value) {
        this._customizeOnParameterChange = value;
    }
    get excludeViewports() {
        return this._excludeViewports;
    }
    set excludeViewports(value) {
        this._excludeViewports = JSON.parse(JSON.stringify(value));
        this._node.excludeViewports = JSON.parse(JSON.stringify(value));
    }
    get exports() {
        return this._exports;
    }
    get guid() {
        return this._guid;
    }
    get hasStoredSettings() {
        return this._settingsEngine.hasStoredSettings;
    }
    get id() {
        return this._id;
    }
    get initialized() {
        return this._initialized;
    }
    get jwtToken() {
        return this._jwtToken;
    }
    get loadSdtf() {
        return this._loadSdtf;
    }
    set loadSdtf(value) {
        this._loadSdtf = value;
        if (this._initialized === true && this._loadSdtf === true) {
            (() => __awaiter(this, void 0, void 0, function* () {
                this._outputLoader.reloadSdtf = true;
                yield this.updateOutputs();
                this._outputLoader.reloadSdtf = false;
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_SDTF_DELAYED_LOADED, { sessionId: this.id });
            }))();
        }
    }
    get modelState() {
        return this._modelState;
    }
    get modelViewUrl() {
        return this._modelViewUrl;
    }
    get node() {
        return this._node;
    }
    get outputs() {
        return this._outputs;
    }
    get outputsFreeze() {
        return this._outputsFreeze;
    }
    get parameterValues() {
        return this._parameterValues;
    }
    get parameters() {
        return this._parameters;
    }
    get refreshJwtToken() {
        return this._refreshJwtToken;
    }
    set refreshJwtToken(value) {
        this._refreshJwtToken = value;
    }
    get settingsEngine() {
        return this._settingsEngine;
    }
    get ticket() {
        return this._ticket;
    }
    get updateCallback() {
        return this._updateCallback;
    }
    set updateCallback(value) {
        this._updateCallback = value;
    }
    get viewerSettings() {
        return this._viewerSettings;
    }
    // #endregion Public Getters And Setters (28)
    // #region Public Methods (31)
    applySettings(response, sections) {
        sections = sections || {};
        if (sections.session === undefined) {
            sections.session = {
                parameter: { displayname: false, order: false, hidden: false },
                export: { displayname: false, order: false, hidden: false },
            };
        }
        if (sections.session.parameter === undefined)
            sections.session.parameter = {
                displayname: false,
                order: false,
                hidden: false,
                value: false,
            };
        if (sections.session.export === undefined)
            sections.session.export = {
                displayname: false,
                order: false,
                hidden: false,
            };
        if (sections.viewport === undefined)
            sections.viewport = {
                ar: false,
                scene: false,
                camera: false,
                light: false,
                environment: false,
                general: false,
                postprocessing: false,
            };
        let config;
        if (response.viewer !== undefined) {
            config = response.viewer.config;
        }
        else {
            throw new viewer_shared_services_1.ShapeDiverViewerSettingsError("Session.applySettings: No config object available.");
        }
        try {
            (0, viewer_settings_1.validate)(config);
        }
        catch (e) {
            throw new viewer_shared_services_1.ShapeDiverViewerSettingsError("Session.applySettings: Was not able to validate config object.");
        }
        const settings = (0, viewer_settings_1.convert)(config, viewer_settings_1.latestVersion);
        const exportMappingUid = {};
        if (sections.session.export.displayname ||
            sections.session.export.order ||
            sections.session.export.hidden)
            if (response.exports)
                for (const exportId in response.exports)
                    if (response.exports[exportId].uid !== undefined)
                        exportMappingUid[response.exports[exportId].uid] =
                            exportId;
        const currentSettings = this._settingsEngine.settings;
        // apply parameter settings
        if (sections.session.parameter.displayname ||
            sections.session.parameter.order ||
            sections.session.parameter.hidden ||
            sections.session.parameter.value) {
            for (const p in this.parameters) {
                if (settings.session[p]) {
                    if (sections.session.parameter.displayname)
                        this.parameters[p].displayname =
                            settings.session[p].displayname;
                    if (sections.session.parameter.order)
                        this.parameters[p].order = settings.session[p].order;
                    if (sections.session.parameter.hidden)
                        this.parameters[p].hidden =
                            settings.session[p].hidden || false;
                }
                if (response.parameters &&
                    response.parameters[p] &&
                    !(this.parameters[p] instanceof FileParameter_1.FileParameter ||
                        this.parameters[p].type.startsWith("s"))) {
                    if (sections.session.parameter.value)
                        this.parameters[p].value =
                            response.parameters[p].defval !== undefined
                                ? response.parameters[p].defval
                                : this.parameters[p].value;
                }
            }
        }
        // apply export settings
        if (sections.session.export.displayname ||
            sections.session.export.order ||
            sections.session.export.hidden) {
            for (const p in this.exports) {
                let idForSettings = "";
                if (settings.session[p]) {
                    idForSettings = p;
                }
                else {
                    const uid = this.exports[p].uid;
                    if (!uid)
                        continue;
                    if (!exportMappingUid[uid])
                        continue;
                    idForSettings = exportMappingUid[uid];
                }
                if (settings.session[idForSettings]) {
                    if (sections.session.export.displayname)
                        this.exports[p].displayname =
                            settings.session[idForSettings].displayname;
                    if (sections.session.export.order)
                        this.exports[p].order =
                            settings.session[idForSettings].order;
                    if (sections.session.export.hidden)
                        this.exports[p].hidden =
                            settings.session[idForSettings].hidden || false;
                }
            }
        }
        // apply ar settings
        if (sections.viewport.ar) {
            currentSettings.ar = settings.ar;
            currentSettings.general.transformation =
                settings.general.transformation;
        }
        // apply camera settings
        if (sections.viewport.camera)
            currentSettings.camera = settings.camera;
        // apply light settings
        if (sections.viewport.light)
            currentSettings.light = settings.light;
        // apply scene settings
        if (sections.viewport.scene) {
            currentSettings.environmentGeometry.gridColor =
                settings.environmentGeometry.gridColor;
            currentSettings.environmentGeometry.gridVisibility =
                settings.environmentGeometry.gridVisibility;
            currentSettings.environmentGeometry.groundPlaneColor =
                settings.environmentGeometry.groundPlaneColor;
            currentSettings.environmentGeometry.groundPlaneVisibility =
                settings.environmentGeometry.groundPlaneVisibility;
            currentSettings.environmentGeometry.groundPlaneShadowColor =
                settings.environmentGeometry.groundPlaneShadowColor;
            currentSettings.environmentGeometry.groundPlaneShadowVisibility =
                settings.environmentGeometry.groundPlaneShadowVisibility;
            currentSettings.environmentGeometry.contactShadowVisibility =
                settings.environmentGeometry.contactShadowVisibility;
            currentSettings.environmentGeometry.contactShadowHeight =
                settings.environmentGeometry.contactShadowHeight;
            currentSettings.environmentGeometry.contactShadowBlur =
                settings.environmentGeometry.contactShadowBlur;
            currentSettings.environmentGeometry.contactShadowOpacity =
                settings.environmentGeometry.contactShadowOpacity;
            currentSettings.environmentGeometry.contactShadowDarkness =
                settings.environmentGeometry.contactShadowDarkness;
            currentSettings.rendering.shadows = settings.rendering.shadows;
            currentSettings.rendering.softShadows =
                settings.rendering.softShadows;
            currentSettings.rendering.automaticColorAdjustment =
                settings.rendering.automaticColorAdjustment;
            currentSettings.rendering.textureEncoding =
                settings.rendering.textureEncoding;
            currentSettings.rendering.outputEncoding =
                settings.rendering.outputEncoding;
            currentSettings.rendering.physicallyCorrectLights =
                settings.rendering.physicallyCorrectLights;
            currentSettings.rendering.toneMapping =
                settings.rendering.toneMapping;
            currentSettings.rendering.toneMappingExposure =
                settings.rendering.toneMappingExposure;
        }
        if (sections.viewport.general) {
            currentSettings.general.commitParameters =
                settings.general.commitParameters;
            currentSettings.general.pointSize = settings.general.pointSize;
            currentSettings.material.defaultMaterialColor =
                settings.material.defaultMaterialColor;
            currentSettings.material.materialOverrideType =
                settings.material.materialOverrideType;
        }
        // apply postprocessing settings
        if (sections.viewport.postprocessing)
            currentSettings.postprocessing = settings.postprocessing;
        // apply environment settings
        if (sections.viewport.environment) {
            currentSettings.environment.clearAlpha =
                settings.environment.clearAlpha;
            currentSettings.environment.clearColor =
                settings.environment.clearColor;
            currentSettings.environment.map = settings.environment.map;
            currentSettings.environment.mapAsBackground =
                settings.environment.mapAsBackground;
            currentSettings.environment.rotation =
                settings.environment.rotation;
            currentSettings.environment.blurriness =
                settings.environment.blurriness;
            currentSettings.environment.intensity =
                settings.environment.intensity;
        }
    }
    canGoBack() {
        // the first entry is always the one from the init call
        // all additional entries can be undone
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length > 1;
    }
    canGoForward() {
        return __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").length > 0;
    }
    cancelCustomization() {
        if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f"))
            this.removeBusyMode(__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f"));
        for (const busyId of __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f")) {
            for (const r in this._stateEngine.viewportEngines) {
                if (this._stateEngine.viewportEngines[r] &&
                    this._stateEngine.viewportEngines[r].busy.includes(busyId))
                    this._stateEngine.viewportEngines[r].busy.splice(this._stateEngine.viewportEngines[r].busy.indexOf(busyId), 1);
            }
        }
        __classPrivateFieldSet(this, _SessionEngine_customizationBusyModes, [], "f");
        __classPrivateFieldSet(this, _SessionEngine_customizationProcess, undefined, "f");
    }
    close(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("close");
            try {
                this._httpClient.removeDataLoading(this._sessionId);
                yield this._sdk.session.close(this._sessionId);
                if (this._automaticSceneUpdate)
                    this.removeFromSceneTree(this._node);
                this._closed = true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.close(true);
            }
        });
    }
    createModelState(parameterValues = {}, omitSessionParameterValues = false, image, data, arScene, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                const promises = [];
                // process the parameters
                const parameterSet = {};
                promises.push(this.uploadFileParameters(parameterValues).then(() => {
                    // create a set of the current validated parameter values
                    for (const parameterId in this.parameters) {
                        // if the parameter has not been set, we do not include it in the parameter set if the omitSessionParameterValues flag is set
                        if (!(omitSessionParameterValues === true &&
                            parameterValues[parameterId] === undefined)) {
                            parameterSet[parameterId] = (" " +
                                this.parameters[parameterId].stringify(parameterValues[parameterId])).slice(1);
                        }
                    }
                }));
                // process the image input
                let imageData;
                let imageArrayBuffer;
                if (image) {
                    promises.push(this.processImageInput(image).then((result) => {
                        imageData = result === null || result === void 0 ? void 0 : result.imageData;
                        imageArrayBuffer = result === null || result === void 0 ? void 0 : result.arrayBuffer;
                    }));
                }
                // process the arScene input
                let arSceneId;
                if (arScene) {
                    promises.push(this._converter
                        .convertToArrayBuffer(arScene)
                        .then((arSceneArrayBuffer) => this._sdk.gltf.upload(this._sessionId, arSceneArrayBuffer, "model/gltf-binary", sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.SCENE))
                        .then((arSceneResponseDto) => {
                        var _a;
                        arSceneId = (_a = arSceneResponseDto.gltf) === null || _a === void 0 ? void 0 : _a.sceneId;
                    }));
                }
                // wait for all promises to resolve
                yield Promise.all(promises);
                // create the model state
                const response = yield this._sdk.modelState.create(this._sessionId, {
                    parameters: parameterSet,
                    data: data,
                    image: imageData,
                    arSceneId: arSceneId,
                });
                if (imageData && imageArrayBuffer)
                    yield this._sdk.utils.uploadAsset(response.asset.modelState.href, imageArrayBuffer, response.asset.modelState.headers);
                return response.modelState.id;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.createModelState(parameterValues, omitSessionParameterValues, image, data, arScene, true);
            }
        });
    }
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(force = false, waitForViewportUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const customizationId = this._uuidGenerator.create();
            try {
                // we check if something changed
                if (force === false) {
                    let changes = false;
                    for (const parameterId in this.parameters)
                        if (this.parameters[parameterId].sessionValue !==
                            this.parameters[parameterId].value)
                            changes = true;
                    if (changes === false)
                        return this.node;
                }
                const eventStart = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 0,
                    data: { sessionId: this.id },
                    status: "Customizing session",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                const oldNode = this.node;
                __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
                this._logger.debugLow(`Session(${this.id}).customize: Customizing session.`);
                this.addBusyMode(customizationId);
                const eventFileUpload = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 0.1,
                    data: { sessionId: this.id },
                    status: "Uploading file parameters",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventFileUpload);
                // upload file parameters
                yield this.uploadFileParameters();
                // OPTION TO SKIP - PART 1b
                const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                if (cancelResult)
                    return cancelResult;
                const parameterSet = {};
                // create a set of the current validated parameter values
                for (const parameterId in this.parameters) {
                    parameterSet[parameterId] = {
                        value: this.parameters[parameterId].value,
                        valueString: this.parameters[parameterId].stringify(),
                    };
                }
                // update the session engine parameter values if everything succeeded
                for (const parameterId in this.parameters)
                    this.parameterValues[parameterId] =
                        parameterSet[parameterId].valueString;
                this._logger.info(`Session(${this.id}).customize: Customizing session with parameters ${JSON.stringify(this.parameterValues)}.`);
                const eventRequest = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 0.1,
                    data: { sessionId: this.id },
                    status: "Sending customization request",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
                const oldOutputVersions = this._outputLoader.getCurrentOutputVersions();
                const newNode = yield this.customizeInternal(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId, {
                    eventId,
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    progressRange: {
                        min: 0.1,
                        max: 0.9,
                    },
                    data: { sessionId: this.id },
                });
                // OPTION TO SKIP - PART 2
                const cancelResult2 = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                if (cancelResult2)
                    return cancelResult2;
                this._warningCreator(this._responseDto.outputs, this._responseDto.exports, this._throwOnCustomizationError);
                const newOutputVersions = this._outputLoader.getCurrentOutputVersions();
                const eventSceneUpdate = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 0.9,
                    data: { sessionId: this.id },
                    status: "Updating scene",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
                // call the update callbacks
                if (waitForViewportUpdate === false) {
                    for (const outputId in this.outputs) {
                        if (oldOutputVersions[outputId] !==
                            newOutputVersions[outputId]) {
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                                outputId: outputId,
                                outputVersion: newOutputVersions[outputId],
                                newNode: newNode.children.find((c) => c.name === outputId),
                                oldNode: oldNode.children.find((c) => c.name === outputId),
                            });
                        }
                    }
                    yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                    const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                    if (cancelResult)
                        return cancelResult;
                }
                // if this is not a call by the goBack or goForward functions, add the parameter values to the history and delete the forward history
                if (!__classPrivateFieldGet(this, _SessionEngine_parameterHistoryCall, "f")) {
                    __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
                    __classPrivateFieldSet(this, _SessionEngine_parameterHistoryForward, [], "f");
                }
                if (this.automaticSceneUpdate)
                    this.removeFromSceneTree(this.node);
                this._node = newNode;
                if (this.automaticSceneUpdate && this._closed === false)
                    this.addToSceneTree(this.node);
                this._logger.debug(`Session(${this.id}).customize: Customization request finished, updating geometry.`);
                // set the session values to the current ones in all parameters
                for (const parameterId in this.parameters)
                    this.parameters[parameterId].sessionValue =
                        parameterSet[parameterId].value;
                // set the output content to what has been updated
                for (const outputId in this.outputs)
                    this.outputs[outputId].updateOutput(newNode.children.find((c) => c.name === outputId), oldNode.children.find((c) => c.name === outputId));
                // set the export definitions
                for (const exportId in this.exports)
                    this.exports[exportId].updateExport();
                this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                this.removeBusyMode(customizationId);
                this._logger.debug(`Session(${this.id}).customize: Session customized.`);
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CUSTOMIZED, {
                    sessionId: this.id,
                });
                const eventEnd = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 1,
                    data: { sessionId: this.id },
                    status: "Session customized",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                // update the viewports
                if (waitForViewportUpdate) {
                    for (const r in this._stateEngine.viewportEngines)
                        if (this._stateEngine.viewportEngines[r] &&
                            !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                            this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).customize`);
                    for (const outputId in this.outputs) {
                        if (oldOutputVersions[outputId] !==
                            newOutputVersions[outputId]) {
                            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                                outputId: outputId,
                                outputVersion: newOutputVersions[outputId],
                                newNode: newNode.children.find((c) => c.name === outputId),
                                oldNode: oldNode.children.find((c) => c.name === outputId),
                            });
                        }
                    }
                    // call the update callbacks
                    yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                    const cancelResult = this.cancelProcess(customizationId, eventId, viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION, 1, { sessionId: this.id });
                    if (cancelResult)
                        return cancelResult;
                }
                if (!waitForViewportUpdate) {
                    setTimeout(() => {
                        for (const r in this._stateEngine.viewportEngines)
                            if (this._stateEngine.viewportEngines[r] &&
                                !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                                this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).customize`);
                    }, 0);
                }
                return this.node;
            }
            catch (e) {
                const eventCancel = {
                    type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                    id: eventId,
                    progress: 1,
                    data: { sessionId: this.id },
                    status: "Session customization failed",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
                this.removeBusyMode(customizationId);
                throw this._httpClient.convertError(e);
            }
        });
    }
    customizeParallel(parameterValues, loadOutputs = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = this._uuidGenerator.create();
            const eventStart = {
                type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                id: eventId,
                progress: 0,
                data: { sessionId: this.id },
                status: "Customizing session",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
            // upload file parameters
            yield this.uploadFileParameters(parameterValues);
            const parameterSet = {};
            // create a set of the current validated parameter values
            for (const parameterId in this.parameters)
                parameterSet[parameterId] = (" " +
                    this.parameters[parameterId].stringify(parameterValues[parameterId])).slice(1);
            const result = yield this.customizeSession(parameterSet, () => false, {
                eventId,
                type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                progressRange: {
                    min: 0.0,
                    max: 1,
                },
                data: { sessionId: this.id },
            }, true, loadOutputs);
            if (result instanceof SessionTreeNode_1.SessionTreeNode)
                result.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
            const eventEnd = {
                type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                id: eventId,
                progress: 1,
                data: { sessionId: this.id },
                status: "Session customized",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
            return result;
        });
    }
    customizeWithModelState(modelState, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                // get the model state if it is not already a response
                let response;
                if (typeof modelState === "string") {
                    response = yield this._sdk.modelState.get(modelState);
                }
                else {
                    response = modelState;
                }
                if (!response.modelState)
                    return new viewer_shared_node_tree_1.TreeNode();
                // read out the parameter values from the model state
                for (const parameterId in response.modelState.parameters)
                    this.parameters[parameterId].value =
                        response.modelState.parameters[parameterId];
                return this.customize();
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.customizeWithModelState(modelState, true);
            }
        });
    }
    getFileInfo(parameterId, fileId, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            try {
                return yield this._sdk.file.info(this._sessionId, parameterId, fileId);
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.getFileInfo(parameterId, fileId, true);
            }
        });
    }
    goBack() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoBack()) {
                this._logger.debug(`Session(${this.id}).goBack: Cannot go further back.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the current parameter set and store it in the forward history later on
            const currentParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").pop();
            // adjust the parameters according to the last parameter set
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f")[__classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").length - 1];
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value =
                    lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current (not anymore current) parameter set to the forward history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").push(currentParameterSet);
            return node;
        });
    }
    goForward() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.canGoForward()) {
                this._logger.debug(`Session(${this.id}).goForward: Cannot go further forward.`);
                return new viewer_shared_node_tree_1.TreeNode();
            }
            // get the last undone parameter set and apply the values to the parameters
            const lastParameterSet = __classPrivateFieldGet(this, _SessionEngine_parameterHistoryForward, "f").pop();
            for (const parameterId in lastParameterSet)
                this.parameters[parameterId].value =
                    lastParameterSet[parameterId].value;
            // call the customization function with the parameterHistoryCall value set to true
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, true, "f");
            const node = yield this.customize();
            __classPrivateFieldSet(this, _SessionEngine_parameterHistoryCall, false, "f");
            // add the current parameter set to the history
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(lastParameterSet);
            return node;
        });
    }
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues, retry = false) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized === true)
                throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.init: Session already initialized.");
            try {
                this._performanceEvaluator.startSection("sessionResponse");
                const parameterSet = {};
                // the slice here is done as a way for deep copying the string values
                for (const parameterNameOrId in parameterValues)
                    parameterSet[parameterNameOrId] = (" " + parameterValues[parameterNameOrId]).slice(1);
                if (this._ticket) {
                    this._responseDto = yield this._sdk.session.init(this._ticket, parameterSet, this._modelStateId, this._modelStateValidationMode);
                }
                else if (this._guid) {
                    this._responseDto = yield this._sdk.session.initForModel(this._guid, parameterSet, this._modelStateId, this._modelStateValidationMode);
                }
                else {
                    // we should never get here
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.init: Initialization of session failed. Neither a ticket nor a guid are available.");
                }
                this._performanceEvaluator.endSection("sessionResponse");
                this._viewerSettings = (_a = this._responseDto.viewer) === null || _a === void 0 ? void 0 : _a.config;
                this._viewerSettingsVersionBackend =
                    this._responseDto.viewerSettingsVersion || viewer_settings_1.latestVersion;
                this._sessionId = this._responseDto.sessionId;
                this._modelId = (_b = this._responseDto.model) === null || _b === void 0 ? void 0 : _b.id;
                this._modelState = this._responseDto.modelState;
                this._httpClient.addDataLoading(this._sessionId, {
                    getAsset: this._sdk.asset.getAsset.bind(this._sdk.asset),
                    downloadTexture: this._sdk.asset.downloadImage.bind(this._sdk.asset),
                });
                this._settingsEngine.loadSettings(this._viewerSettings);
                if (!this._sessionId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.init: Initialization of session failed. ResponseDto did not have a sessionId.");
                if (!this._modelId)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.init: Initialization of session failed. ResponseDto did not have a model.id.");
                this.updateResponseDto(this._responseDto, parameterSet);
                this._initialized = true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.init(parameterValues, true);
            }
        });
    }
    loadCachedOutputsParallel(outputMapping, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            // if there is already task event info, use it
            // this happens after a retry
            const eventId = taskEventInfo
                ? taskEventInfo.eventId
                : this._uuidGenerator.create();
            const eventType = taskEventInfo
                ? taskEventInfo.type
                : viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_LOADING;
            const eventData = taskEventInfo
                ? taskEventInfo.data
                : { sessionId: this.id };
            taskEventInfo = taskEventInfo
                ? taskEventInfo
                : {
                    eventId,
                    type: eventType,
                    progressRange: {
                        min: 0,
                        max: 1,
                    },
                    data: eventData,
                };
            try {
                // send start event if this function was called initially
                if (!taskEventInfo) {
                    const eventStart = {
                        type: eventType,
                        id: eventId,
                        progress: 0,
                        data: eventData,
                        status: "Loading cached outputs",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                }
                // get the cached outputs
                const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                // create atomic output api objects for them
                const outputs = {};
                for (const outputId in responseDto.outputs) {
                    responseDto.outputs[outputId].id = outputId;
                    outputs[outputId] = new Output_1.Output(responseDto.outputs[outputId], this);
                }
                // process the output data
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || "model", outputs, {}, taskEventInfo, false);
                // send the end event once done
                const eventEnd = {
                    type: eventType,
                    id: eventId,
                    progress: 1,
                    data: eventData,
                    status: "Loaded cached outputs",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                // create a mapping with a dictionary for the id of the outputs
                const outputNodeMapping = {};
                for (const outputId in outputMapping)
                    outputNodeMapping[outputId] = node.children.find((n) => n.name === outputId);
                return outputNodeMapping;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.loadCachedOutputsParallel(outputMapping, taskEventInfo, true);
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest = () => false, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const o = Object.assign({}, this._outputs);
            const of = Object.assign({}, this._outputsFreeze);
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || "model", o, of, taskEventInfo);
                node.data.push(new SessionData_1.SessionData(this._responseDto));
                if (cancelRequest())
                    return node;
                node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, taskEventInfo, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                const outputMapping = {};
                for (const output in o)
                    outputMapping[output] = o[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputs(cancelRequest, taskEventInfo);
                }
                catch (e) {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputs(cancelRequest, taskEventInfo, true);
                }
            }
        });
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputsParallel(responseDto, cancelRequest = () => false, taskEventInfo, retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            const outputs = {};
            const outputsFreeze = {};
            for (const outputId in responseDto.outputs) {
                responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    outputsFreeze[outputId] = false;
                outputs[outputId] = new Output_1.Output(responseDto.outputs[outputId], this);
            }
            try {
                const node = yield this._outputLoader.loadOutputs(((_a = this._responseDto.model) === null || _a === void 0 ? void 0 : _a.name) || "model", outputs, outputsFreeze, taskEventInfo, true, true);
                node.data.push(new SessionData_1.SessionData(responseDto));
                return node;
            }
            catch (e) {
                if (e instanceof OutputDelayException_1.OutputDelayException) {
                    yield this.timeout(e.delay);
                }
                else {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo, true);
                }
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                const outputMapping = {};
                for (const output in outputs)
                    outputMapping[output] = outputs[output].version;
                try {
                    const responseDto = yield this._sdk.output.getCache(this._sessionId, outputMapping);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    this.updateResponseDto(responseDto);
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo);
                }
                catch (e) {
                    yield this.handleError(e, retry);
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    return yield this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo, true);
                }
            }
        });
    }
    requestExport(exportId, parameters, maxWaitTime, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("export");
            try {
                yield this.uploadFileParameters(parameters);
                const requestParameterSet = this.cleanExportParameters(parameters);
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, { exports: { id: exportId }, parameters: requestParameterSet }, maxWaitTime);
                this.updateResponseDto(responseDto);
                return this.exports[exportId];
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.requestExport(exportId, parameters, maxWaitTime, true);
            }
        });
    }
    requestExports(body, loadOutputs = false, maxWaitMsec, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let processId;
            const eventId = this._uuidGenerator.create();
            // if the outputs are loaded, we treat this as a customization by sending the same events
            const treatInternallyAsCustomization = loadOutputs === true && this._allowOutputLoading === true;
            this.checkAvailability("export");
            try {
                if (treatInternallyAsCustomization) {
                    const eventStart = {
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        id: eventId,
                        progress: 0,
                        data: { sessionId: this.id },
                        status: "Customizing session",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
                }
                // activate the busy mode if outputs are loaded
                if (loadOutputs === true &&
                    this._allowOutputLoading === true &&
                    body.outputs &&
                    Object.keys(body.outputs).length > 0) {
                    processId = this._uuidGenerator.create();
                    this.addBusyMode(processId);
                }
                if (treatInternallyAsCustomization) {
                    const eventFileUpload = {
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        id: eventId,
                        progress: 0.1,
                        data: { sessionId: this.id },
                        status: "Uploading file parameters",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventFileUpload);
                }
                yield this.uploadFileParameters(body.parameters);
                const requestParameterSet = this.cleanExportParameters(body.parameters);
                if (treatInternallyAsCustomization) {
                    const eventRequest = {
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        id: eventId,
                        progress: 0.1,
                        data: { sessionId: this.id },
                        status: "Sending customization request",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
                }
                const responseDto = yield this._sdk.utils.submitAndWaitForExport(this._sdk, this._sessionId, {
                    exports: body.exports,
                    parameters: requestParameterSet,
                    outputs: body.outputs,
                    max_wait_time: body.max_wait_time,
                }, maxWaitMsec);
                this.updateResponseDto(responseDto);
                if (treatInternallyAsCustomization) {
                    yield this.updateOutputs({
                        eventId,
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        progressRange: {
                            min: 0.1,
                            max: 0.9,
                        },
                        data: { sessionId: this.id },
                    });
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SESSION.SESSION_CUSTOMIZED, { sessionId: this.id });
                    const eventEnd = {
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        id: eventId,
                        progress: 1,
                        data: { sessionId: this.id },
                        status: "Session customized",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
                }
                if (processId)
                    this.removeBusyMode(processId);
                return responseDto;
            }
            catch (e) {
                if (treatInternallyAsCustomization) {
                    const eventCancel = {
                        type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                        id: eventId,
                        progress: 1,
                        data: { sessionId: this.id },
                        status: "Session customization failed",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
                }
                if (processId)
                    this.removeBusyMode(processId);
                yield this.handleError(e, retry);
                return yield this.requestExports(body, loadOutputs, maxWaitMsec, true);
            }
        });
    }
    resetSettings(sections) {
        if (!this._responseDto)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.resetSettings: responseDto not available.");
        sections = sections || {};
        if (sections.session === undefined) {
            sections.session = {
                parameter: { displayname: true, order: true, hidden: true },
                export: { displayname: true, order: true, hidden: true },
            };
        }
        if (sections.session.parameter === undefined)
            sections.session.parameter = {
                displayname: true,
                order: true,
                hidden: true,
                value: true,
            };
        if (sections.session.export === undefined)
            sections.session.export = {
                displayname: true,
                order: true,
                hidden: true,
            };
        if (sections.viewport === undefined)
            sections.viewport = {
                ar: true,
                scene: true,
                camera: true,
                light: true,
                environment: true,
                general: true,
                postprocessing: true,
            };
        return this.applySettings(this._responseDto, sections);
    }
    saveDefaultParameterValues() {
        return __awaiter(this, void 0, void 0, function* () {
            this._logger.debugLow(`Session(${this.id}).saveDefaultParameters: Saving default parameters.`);
            const response = yield this.saveDefaultParameters();
            if (response) {
                this._logger.debug(`Session(${this.id}).saveDefaultParameters: Saved default parameters.`);
            }
            else {
                throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session(${this.id}).saveDefaultParameters: Could not save default parameters.`);
            }
            return response;
        });
    }
    saveDefaultParameters(retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("defaultparam", true);
            try {
                yield this._sdk.model.setDefaultParams(this._modelId, this._parameterValues);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveDefaultParameters(true);
            }
        });
    }
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("export-definition", true);
            try {
                yield this._sdk.export.updateDefinitions(this._modelId, exports);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveExportProperties(exports, true);
            }
        });
    }
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("output-definition", true);
            try {
                yield this._sdk.output.updateDefinitions(this._modelId, outputs);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveOutputProperties(outputs, true);
            }
        });
    }
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("parameter-definition", true);
            try {
                yield this._sdk.model.updateParameterDefinitions(this._modelId, parameters);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveParameterProperties(parameters, true);
            }
        });
    }
    saveSettings(json, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("configure", true);
            try {
                (0, viewer_settings_1.validate)(json, this._viewerSettingsVersion);
                // if viewer settings version is higher than backend settings version
                // convert to backend settings version
                if (+this._viewerSettingsVersion >
                    +this._viewerSettingsVersionBackend)
                    json = (0, viewer_settings_1.convert)(json, this._viewerSettingsVersionBackend);
            }
            catch (e) {
                throw new viewer_shared_services_1.ShapeDiverViewerSettingsError("Session.saveSettings: Settings could not be validated. " +
                    e.message, e);
            }
            try {
                yield this._sdk.model.updateConfig(this._modelId, json);
                return true;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.saveSettings(json, true);
            }
        });
    }
    saveUiProperties(saveInSettings = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this._logger.debugLow(`Session(${this.id}).saveSessionProperties: Saving session properties.`);
            // settings saving
            this._saveSessionSettings();
            let properties = {};
            for (const p in this.parameters) {
                properties[p] = {
                    displayname: this.parameters[p].displayname !== undefined
                        ? this.parameters[p].displayname
                        : "",
                    hidden: this.parameters[p].hidden !== undefined
                        ? this.parameters[p].hidden
                        : false,
                    order: this.parameters[p].order !== undefined
                        ? this.parameters[p].order
                        : 0,
                    tooltip: this.parameters[p].tooltip !== undefined
                        ? this.parameters[p].tooltip
                        : "",
                };
            }
            const responseP = Object.values(properties).length !== 0
                ? yield this.saveParameterProperties(properties)
                : true;
            properties = {};
            for (const e in this.exports) {
                properties[e] = {
                    displayname: this.exports[e].displayname !== undefined
                        ? this.exports[e].displayname
                        : "",
                    hidden: this.exports[e].hidden !== undefined
                        ? this.exports[e].hidden
                        : false,
                    order: this.exports[e].order !== undefined
                        ? this.exports[e].order
                        : 0,
                    tooltip: this.exports[e].tooltip !== undefined
                        ? this.exports[e].tooltip
                        : "",
                };
            }
            const responseE = Object.values(properties).length !== 0
                ? yield this.saveExportProperties(properties)
                : true;
            properties = {};
            for (const o in this.outputs) {
                properties[o] = {
                    displayname: this.outputs[o].displayname !== undefined
                        ? this.outputs[o].displayname
                        : "",
                    hidden: this.outputs[o].hidden !== undefined
                        ? this.outputs[o].hidden
                        : false,
                    order: this.outputs[o].order !== undefined
                        ? this.outputs[o].order
                        : 0,
                    tooltip: this.outputs[o].tooltip !== undefined
                        ? this.outputs[o].tooltip
                        : "",
                };
            }
            const responseO = Object.values(properties).length !== 0
                ? yield this.saveOutputProperties(properties)
                : true;
            // save partial settings
            const response = saveInSettings
                ? yield this.saveSettings(this._settingsEngine.settings)
                : true;
            if (response && responseP && responseO && responseE) {
                this._logger.debug(`Session(${this.id}).saveSessionProperties: Saved session properties.`);
            }
            else {
                this._logger.warn(`Session(${this.id}).saveSessionProperties: Could not save session properties.`);
            }
            return response && responseP && responseO && responseE;
        });
    }
    setJwtToken(value, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability();
            this._jwtToken = value;
            try {
                this._sdk.setConfigurationValue(sdk_geometry_api_sdk_v2_1.ShapeDiverSdkConfigType.JWT_TOKEN, value);
                const responseDto = yield this._sdk.session.default(this._sessionId);
                if (this._responseDto)
                    this._responseDto.actions = responseDto.actions;
            }
            catch (e) {
                yield this.handleError(e, retry);
                yield this.setJwtToken(value, true);
            }
        });
    }
    updateOutputs(taskEventInfo, waitForViewportUpdate = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventId = taskEventInfo
                ? taskEventInfo.eventId
                : this._uuidGenerator.create();
            const eventType = taskEventInfo
                ? taskEventInfo.type
                : viewer_shared_types_1.TASK_TYPE.SESSION_OUTPUTS_UPDATE;
            const eventData = taskEventInfo
                ? taskEventInfo.data
                : { sessionId: this.id };
            if (!taskEventInfo) {
                const eventStart = {
                    type: eventType,
                    id: eventId,
                    progress: 0,
                    data: eventData,
                    status: "Updating outputs",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);
            }
            const customizationId = this._uuidGenerator.create();
            const oldNode = this.node;
            __classPrivateFieldSet(this, _SessionEngine_customizationProcess, customizationId, "f");
            this._logger.debugLow(`Session(${this.id}).updateOutputs: Updating Outputs.`);
            this.addBusyMode(customizationId);
            const eventRequest = {
                type: eventType,
                id: eventId,
                progress: taskEventInfo
                    ? (taskEventInfo.progressRange.max -
                        taskEventInfo.progressRange.min) *
                        0.1 +
                        taskEventInfo.progressRange.min
                    : 0.1,
                data: eventData,
                status: "Loading outputs",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventRequest);
            const oldOutputVersions = this._outputLoader.getCurrentOutputVersions();
            const newNode = yield this.loadOutputs(() => __classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId, {
                eventId,
                type: eventType,
                progressRange: {
                    min: taskEventInfo
                        ? (taskEventInfo.progressRange.max -
                            taskEventInfo.progressRange.min) *
                            0.1 +
                            taskEventInfo.progressRange.min
                        : 0.1,
                    max: taskEventInfo
                        ? (taskEventInfo.progressRange.max -
                            taskEventInfo.progressRange.min) *
                            0.9 +
                            taskEventInfo.progressRange.min
                        : 0.9,
                },
                data: eventData,
            });
            this._warningCreator(this._responseDto.outputs, this._responseDto.exports, this._throwOnCustomizationError);
            const newOutputVersions = this._outputLoader.getCurrentOutputVersions();
            const eventSceneUpdate = {
                type: eventType,
                id: eventId,
                progress: taskEventInfo
                    ? (taskEventInfo.progressRange.max -
                        taskEventInfo.progressRange.min) *
                        0.9 +
                        taskEventInfo.progressRange.min
                    : 0.9,
                data: eventData,
                status: "Updating scene",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventSceneUpdate);
            // OPTION TO SKIP - PART 1
            const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo
                ? (taskEventInfo.progressRange.max -
                    taskEventInfo.progressRange.min) *
                    1 +
                    taskEventInfo.progressRange.min
                : 1, eventData, newNode);
            if (cancelResult)
                return cancelResult;
            // call the update callbacks
            if (waitForViewportUpdate === false) {
                for (const outputId in this.outputs) {
                    if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                            outputId: outputId,
                            outputVersion: newOutputVersions[outputId],
                            newNode: newNode.children.find((c) => c.name === outputId),
                            oldNode: oldNode.children.find((c) => c.name === outputId),
                        });
                    }
                }
                yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                // OPTION TO SKIP - PART 2
                const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo
                    ? (taskEventInfo.progressRange.max -
                        taskEventInfo.progressRange.min) *
                        1 +
                        taskEventInfo.progressRange.min
                    : 1, eventData, newNode);
                if (cancelResult)
                    return cancelResult;
            }
            if (this.automaticSceneUpdate)
                this.removeFromSceneTree(this.node);
            this._node = newNode;
            if (this.automaticSceneUpdate && this._closed === false)
                this.addToSceneTree(this.node);
            this._logger.debug(`Session(${this.id}).updateOutputs: Updating outputs finished, updating geometry.`);
            // set the output content to what has been updated
            for (const outputId in this.outputs) {
                this.outputs[outputId].updateOutput(newNode.children.find((c) => c.name === outputId), oldNode.children.find((c) => c.name === outputId));
            }
            // set the export definitions
            for (const exportId in this.exports)
                this.exports[exportId].updateExport();
            this.node.excludeViewports = JSON.parse(JSON.stringify(this._excludeViewports));
            this.removeBusyMode(customizationId);
            this._logger.debug(`Session(${this.id}).updateOutputs: Updated outputs.`);
            if (!taskEventInfo) {
                const eventEnd = {
                    type: eventType,
                    id: eventId,
                    progress: 1,
                    data: eventData,
                    status: "Outputs updated",
                };
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);
            }
            // update the viewports
            if (waitForViewportUpdate) {
                for (const r in this._stateEngine.viewportEngines)
                    if (this._stateEngine.viewportEngines[r] &&
                        !this.excludeViewports.includes(this._stateEngine.viewportEngines[r].id))
                        this._stateEngine.viewportEngines[r].update(`SessionEngine(${this.id}).updateOutputs`);
                for (const outputId in this.outputs) {
                    if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                        this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.OUTPUT.OUTPUT_UPDATED, {
                            outputId: outputId,
                            outputVersion: newOutputVersions[outputId],
                            newNode: newNode.children.find((c) => c.name === outputId),
                            oldNode: oldNode.children.find((c) => c.name === outputId),
                        });
                    }
                }
                yield this.waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode);
                // OPTION TO SKIP - PART 3
                const cancelResult = this.cancelProcess(customizationId, eventId, eventType, taskEventInfo
                    ? (taskEventInfo.progressRange.max -
                        taskEventInfo.progressRange.min) *
                        1 +
                        taskEventInfo.progressRange.min
                    : 1, eventData, newNode);
                if (cancelResult)
                    return cancelResult;
            }
            return this.node;
        });
    }
    uploadFile(parameterId, data, type, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("file-upload");
            try {
                const result = yield this._sdk.file.requestUpload(this._sessionId, {
                    [parameterId]: {
                        size: data.size,
                        format: type,
                        filename: data.name === "" ? undefined : data.name,
                    },
                });
                if (result &&
                    result.asset &&
                    result.asset.file &&
                    result.asset.file[parameterId]) {
                    const fileAsset = result.asset.file[parameterId];
                    yield this._sdk.utils.uploadAsset(fileAsset.href, yield data.arrayBuffer(), fileAsset.headers);
                    return fileAsset.id;
                }
                else {
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.uploadFile: Upload reply has not the required format.");
                }
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.uploadFile(parameterId, data, type, true);
            }
        });
    }
    /**
     * Uploads all file parameters and returns the file parameter values.
     * If parameterValues is provided, the file parameter values are added to it.
     *
     * @param parameterValues
     * @returns
     */
    uploadFileParameters(parameterValues) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameterValueSet = parameterValues !== undefined
                ? this.getFileParameterSet(parameterValues)
                : undefined;
            const fileParameterValues = {};
            // load file parameter first
            for (const parameterId in this.parameters) {
                if (this.parameters[parameterId] instanceof FileParameter_1.FileParameter) {
                    fileParameterValues[parameterId] = yield (this.parameters[parameterId]).upload(parameterValueSet
                        ? parameterValueSet[parameterId]
                        : undefined);
                    if (parameterValues) {
                        parameterValues[parameterId] =
                            fileParameterValues[parameterId];
                        // if the parameter value of the file parameter was used, set the value to the parameter
                        if (parameterValues[parameterId] === undefined &&
                            this.parameters[parameterId].value !==
                                fileParameterValues[parameterId])
                            this.parameters[parameterId].value =
                                fileParameterValues[parameterId];
                    }
                    else if (this.parameters[parameterId].value !==
                        fileParameterValues[parameterId]) {
                        this.parameters[parameterId].value =
                            fileParameterValues[parameterId];
                    }
                }
            }
            return fileParameterValues;
        });
    }
    uploadGLTF(blob, conversion = sdk_geometry_api_sdk_v2_1.ShapeDiverRequestGltfUploadQueryConversion.NONE, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("gltf-upload");
            try {
                const responseDto = yield this._sdk.gltf.upload(this._sessionId, yield blob.arrayBuffer(), "model/gltf-binary", conversion);
                if (!responseDto || !responseDto.gltf || !responseDto.gltf.href)
                    throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.uploadGLTF: Upload reply has not the required format.");
                return responseDto;
            }
            catch (e) {
                yield this.handleError(e, retry);
                return yield this.uploadGLTF(blob, conversion, true);
            }
        });
    }
    // #endregion Public Methods (31)
    // #region Private Methods (18)
    _saveSessionSettings() {
        const parameters = this.parameters;
        const exports = this.exports;
        const sessionProperties = {};
        for (const p in parameters) {
            sessionProperties[p] = {
                order: parameters[p].order || 0,
                displayname: parameters[p].displayname || "",
                hidden: parameters[p].hidden,
            };
        }
        for (const e in exports) {
            sessionProperties[e] = {
                order: exports[e].order || 0,
                displayname: exports[e].displayname || "",
                hidden: exports[e].hidden,
            };
        }
        this._settingsEngine.session = sessionProperties;
    }
    _warningCreator(outputs, exports, throwError = false) {
        const outputsWithIssues = {};
        const exportsWithIssues = {};
        for (const outputId in outputs) {
            const outputObj = outputs[outputId];
            if ((throwError === false && outputObj.msg !== undefined) ||
                (outputObj.status_collect &&
                    outputObj.status_collect !==
                        sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS) ||
                (outputObj.status_computation &&
                    outputObj.status_computation !==
                        sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)) {
                outputsWithIssues[outputId] = outputObj;
            }
        }
        for (const exportId in exports) {
            const exportObj = exports[exportId];
            if ((throwError === false && exportObj.msg !== undefined) ||
                (exportObj.status_collect &&
                    exportObj.status_collect !==
                        sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS) ||
                (exportObj.status_computation &&
                    exportObj.status_computation !==
                        sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)) {
                exportsWithIssues[exportId] = exportObj;
            }
        }
        if (Object.keys(outputsWithIssues).length > 0 ||
            Object.keys(exportsWithIssues).length > 0) {
            if (throwError) {
                throw new viewer_shared_services_1.ShapeDiverViewerCustomizationError("There was at least one output or export with issues.", { outputs: outputsWithIssues, exports: exportsWithIssues });
            }
            else {
                // create warning messages for outputs
                for (const outputId in outputsWithIssues) {
                    let warning = "";
                    if (outputsWithIssues[outputId].msg)
                        warning += `\n\t- ${outputsWithIssues[outputId].msg}`;
                    if (outputsWithIssues[outputId].status_collect &&
                        outputsWithIssues[outputId].status_collect !==
                            sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                        warning += `\n\t- status_collect is ${outputsWithIssues[outputId].status_collect}`;
                    if (outputsWithIssues[outputId].status_computation &&
                        outputsWithIssues[outputId].status_computation !==
                            sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                        warning += `\n\t- status_computation is ${outputsWithIssues[outputId].status_computation}`;
                    if (warning)
                        this._logger.warn(`\nOutput(${outputId}):${warning}`);
                }
                // create warning messages for exports
                for (const exportId in exportsWithIssues) {
                    let warning = "";
                    if (exportsWithIssues[exportId].msg)
                        warning += `\n\t- ${exportsWithIssues[exportId].msg}`;
                    if (exportsWithIssues[exportId].status_collect &&
                        exportsWithIssues[exportId].status_collect !==
                            sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                        warning += `\n\t- status_collect is ${exportsWithIssues[exportId].status_collect}`;
                    if (exportsWithIssues[exportId].status_computation &&
                        exportsWithIssues[exportId].status_computation !==
                            sdk_geometry_api_sdk_v2_1.ShapeDiverResponseModelComputationStatus.SUCCESS)
                        warning += `\n\t- status_computation is ${exportsWithIssues[exportId].status_computation}`;
                    if (warning)
                        this._logger.warn(`\nExport(${exportId}):${warning}`);
                }
            }
        }
    }
    addBusyMode(busyId) {
        for (const r in this._stateEngine.viewportEngines) {
            if (this._stateEngine.viewportEngines[r] &&
                !this.excludeViewports.includes(r)) {
                this._stateEngine.viewportEngines[r].busy.push(busyId);
                __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").push(busyId);
            }
        }
    }
    addToSceneTree(node) {
        this._sceneTree.addNode(node);
        this._sceneTree.root.updateVersion();
    }
    cancelProcess(customizationId, eventId, eventType, eventProgress, eventData, newNode = new SessionTreeNode_1.SessionTreeNode()) {
        if (__classPrivateFieldGet(this, _SessionEngine_customizationProcess, "f") !== customizationId) {
            this.removeBusyMode(customizationId);
            const eventCancel = {
                type: eventType,
                id: eventId,
                progress: eventProgress,
                data: eventData,
                status: "The request was exceeded by another customization request",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
            this._logger.debug(`Session(${this.id}).cancelProcess: The request was was exceeded by another request.`);
            return newNode;
        }
        else if (this._closed === true) {
            this.removeBusyMode(customizationId);
            this._logger.debug(`Session(${this.id}).cancelProcess: The session was closed during the request.`);
            const eventCancel = {
                type: viewer_shared_types_1.TASK_TYPE.SESSION_CUSTOMIZATION,
                id: eventId,
                progress: 1,
                data: { sessionId: this.id },
                status: "The session was closed during the request.",
            };
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, eventCancel);
            return new SessionTreeNode_1.SessionTreeNode();
        }
    }
    checkAvailability(action, checkForModelId = false) {
        var _a;
        if (!this._responseDto)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.checkAvailability: responseDto not available.");
        if (!this._sessionId)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.checkAvailability: sessionId not available.");
        if (checkForModelId && !this._modelId)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.checkAvailability: modelId not available.");
        if (action && !this._responseDto.actions)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError("Session.checkAvailability: actions not available.");
        const responseDtoAction = (_a = this._responseDto.actions) === null || _a === void 0 ? void 0 : _a.find((a) => a.name === action);
        if (action && !responseDtoAction)
            throw new viewer_shared_services_1.ShapeDiverViewerSessionError(`Session.checkAvailability: action ${action} not available.`);
    }
    cleanExportParameters(parameters) {
        const requestParameterSet = {};
        // first step, we convert all our names and displaynames to ids
        for (const parameterIdOrName in parameters) {
            // we prioritize id, then name and then displayname
            // if there are two parameters with the same name or displayname, we take the one that is found first (no way for us to evaluate which one the user meant)
            const parameterObject = Object.values(this._parameters).find((p) => p.id === parameterIdOrName ||
                p.name === parameterIdOrName ||
                p.displayname === parameterIdOrName);
            // in case the key of the key value pair was neither the id, name or displayname, skip
            if (!parameterObject)
                continue;
            // copy into new dictionary
            requestParameterSet[parameterObject.id] = (" " + parameterObject.stringify(parameters[parameterIdOrName])).slice(1);
        }
        // seconds step, fill all other parameter values that are currently not set
        const currentParameters = this.parameterValues;
        for (const parameterId in currentParameters) {
            // if already set by input values, skip
            if (requestParameterSet[parameterId] !== undefined)
                continue;
            // deep copy into new dictionary
            requestParameterSet[parameterId] = (" " + currentParameters[parameterId]).slice(1);
        }
        return requestParameterSet;
    }
    /**
     * Create an interaction parameter based on the parameter definition.
     *
     * @param parameter
     * @returns
     */
    createInteractionParameter(parameter) {
        const result = (0, viewer_shared_types_1.validateInteractionParameterSettings)(parameter.settings);
        if (result.success) {
            switch (parameter.settings.type) {
                case "selection":
                    return new SelectionParameter_1.SelectionParameter(parameter, this);
                case "gumball":
                    return new GumballParameter_1.GumballParameter(parameter, this);
                case "dragging":
                    return new DraggingParameter_1.DraggingParameter(parameter, this);
            }
        }
        else {
            this._logger.warn(`SessionEngine.createInteractionParameter: The value ${parameter.settings} is not a valid InteractionParameter: ${result.error.message}`);
        }
        return new Parameter_1.Parameter(parameter, this);
    }
    customizeInternal(cancelRequest, taskEventInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.customizeSession(this._parameterValues, cancelRequest, taskEventInfo);
        });
    }
    customizeSession(parameters, cancelRequest, taskEventInfo, parallel = false, loadOutputs = true, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAvailability("customize");
            try {
                this._performanceEvaluator.startSection("sessionResponse");
                const responseDto = yield this._sdk.utils.submitAndWaitForCustomization(this._sdk, this._sessionId, parameters);
                this._performanceEvaluator.endSection("sessionResponse");
                if (loadOutputs === true && this._allowOutputLoading === true) {
                    if (cancelRequest())
                        return new SessionTreeNode_1.SessionTreeNode();
                    if (parallel === true) {
                        // special case, we load the outputs put don't add them to the scene
                        return this.loadOutputsParallel(responseDto, cancelRequest, taskEventInfo);
                    }
                    else {
                        // default case, we load the outputs and return the nodes
                        this.updateResponseDto(responseDto);
                        return this.loadOutputs(cancelRequest, taskEventInfo);
                    }
                }
                else {
                    // special case, we don't load the outputs and only return the responseDto
                    const node = new SessionTreeNode_1.SessionTreeNode();
                    node.data.push(new SessionData_1.SessionData(responseDto));
                    return node;
                }
            }
            catch (e) {
                yield this.handleError(e, retry);
                if (cancelRequest())
                    return new SessionTreeNode_1.SessionTreeNode();
                return yield this.customizeSession(parameters, cancelRequest, taskEventInfo, parallel, loadOutputs, true);
            }
        });
    }
    /**
     * Get all file parameters from the parameter set.
     * If the parameter is not set in the parameter set, the value from the parameter object is used.
     *
     * @param parameters
     * @returns
     */
    getFileParameterSet(parameters) {
        const fileParameterSet = {};
        for (const parameterId in this.parameters) {
            if (this.parameters[parameterId] instanceof FileParameter_1.FileParameter) {
                fileParameterSet[parameterId] =
                    parameters[parameterId] !== undefined
                        ? parameters[parameterId]
                        : this.parameters[parameterId].value;
            }
        }
        return fileParameterSet;
    }
    handleError(e, retry = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, sdk_geometry_api_sdk_v2_1.isGBResponseError)(e)) {
                if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.SESSION_GONE_ERROR) {
                    // case 1: the session is no longer available
                    // we try to re-initialize the session 3 times, if that does not work, we close it
                    this._logger.warn("The session has been closed, trying to re-initialize.");
                    if (this._sessionId)
                        this._httpClient.removeDataLoading(this._sessionId);
                    if (this._retryCounter < 3) {
                        // we retry this 3 times, the `retry` option in the init function is set to true and passed on
                        this._retryCounter = retry ? this._retryCounter + 1 : 1;
                        this._initialized = false;
                        yield this.init(this.parameterValues, true);
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn("Tried to retry the connect multiple times, bearer token still not valid. Closing Session.");
                        // eslint-disable-next-line no-empty
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._httpClient.convertError(e);
                    }
                }
                else if (e.error === sdk_geometry_api_sdk_v2_1.ShapeDiverResponseErrorType.JWT_VALIDATION_ERROR) {
                    // if any of the above errors occur, we try to get a new bearer token
                    // if we get a new one, we retry 3 times (by requiring new bearer tokens every time)
                    if (this._retryCounter < 3) {
                        if (this._refreshJwtToken) {
                            yield this.setJwtToken(yield this._refreshJwtToken());
                            this._retryCounter = retry ? this._retryCounter + 1 : 1;
                            this._logger.warn("Re-trying with new bearer token.");
                        }
                        else {
                            // no bearer tokens are supplied, we close the session
                            this._logger.warn("No retry possible, no new bearer token was supplied. Closing Session.");
                            // eslint-disable-next-line no-empty
                            try {
                                yield this._closeOnFailure();
                            }
                            catch (e) { }
                            throw this._httpClient.convertError(e);
                        }
                    }
                    else {
                        // the retries were exceeded, we close the session
                        this._logger.warn("Tried to retry the connect multiple times, bearer token still not valid. Closing Session.");
                        // eslint-disable-next-line no-empty
                        try {
                            yield this._closeOnFailure();
                        }
                        catch (e) { }
                        throw this._httpClient.convertError(e);
                    }
                }
                else {
                    throw this._httpClient.convertError(e);
                }
            }
            else {
                throw this._httpClient.convertError(e);
            }
        });
    }
    /**
     * Process the image input and return the image data and array buffer.
     *
     * In the case of the image being a Blob or File, the image data is constructed from the Blob or File.
     * In the case of the image being a string, we check if it is a data URL or a URL.
     * If it is a data URL, we convert it to a Blob and construct the image data from the Blob.
     * If it is a URL, we download the image and return the image data and array buffer.
     *
     * @param image
     * @returns
     */
    processImageInput(image) {
        return __awaiter(this, void 0, void 0, function* () {
            if (image instanceof File || image instanceof Blob)
                return this._converter.constructImageData(image);
            let imageString;
            if (image instanceof Promise) {
                imageString = yield image;
            }
            else if (typeof image === "function") {
                const result = image();
                if (result instanceof Promise) {
                    imageString = yield result;
                }
                else {
                    imageString = result;
                }
            }
            else {
                imageString = image;
            }
            if (imageString.startsWith("data:")) {
                // case where the image is a data URL
                const { blob, arrayBuffer } = this._converter.dataURLtoBlob(imageString);
                return {
                    imageData: {
                        format: blob.type,
                        size: blob.size,
                    },
                    arrayBuffer,
                };
            }
            else {
                // case where the image is a URL
                const [arrayBuffer, type] = yield this._sdk.asset.downloadImage(this._sessionId, imageString);
                return {
                    imageData: {
                        format: type,
                        size: arrayBuffer.byteLength,
                    },
                    arrayBuffer,
                };
            }
        });
    }
    removeBusyMode(busyId) {
        for (const r in this._stateEngine.viewportEngines) {
            if (this._stateEngine.viewportEngines[r] &&
                this._stateEngine.viewportEngines[r].busy.includes(busyId))
                this._stateEngine.viewportEngines[r].busy.splice(this._stateEngine.viewportEngines[r].busy.indexOf(busyId), 1);
            if (__classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").includes(busyId))
                __classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").splice(__classPrivateFieldGet(this, _SessionEngine_customizationBusyModes, "f").indexOf(busyId), 1);
        }
    }
    removeFromSceneTree(node) {
        this._sceneTree.removeNode(node);
        this._sceneTree.root.updateVersion();
    }
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    timeout(ms) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => setTimeout(resolve, ms));
        });
    }
    updateResponseDto(responseDto, initialParameters) {
        if (!this._responseDto) {
            this._responseDto = responseDto;
            return;
        }
        // convert parameters
        if (responseDto.parameters) {
            for (const parameterId in responseDto.parameters) {
                this._responseDto.parameters =
                    this._responseDto.parameters || {};
                this._responseDto.parameters[parameterId] =
                    this._responseDto.parameters[parameterId] ||
                        responseDto.parameters[parameterId];
            }
        }
        // convert outputs
        if (responseDto.outputs) {
            for (const outputId in responseDto.outputs) {
                this._responseDto.outputs = this._responseDto.outputs || {};
                if ("version" in responseDto.outputs[outputId] ||
                    !(this._responseDto.outputs[outputId] &&
                        "version" in this._responseDto.outputs[outputId]))
                    this._responseDto.outputs[outputId] =
                        responseDto.outputs[outputId];
            }
        }
        // convert exports
        if (responseDto.exports) {
            for (const exportId in responseDto.exports) {
                this._responseDto.exports = this._responseDto.exports || {};
                if ("version" in responseDto.exports[exportId] ||
                    !(this._responseDto.exports[exportId] &&
                        "version" in this._responseDto.exports[exportId]))
                    this._responseDto.exports[exportId] =
                        responseDto.exports[exportId];
            }
        }
        const parameterSet = {};
        for (const parameterId in this._responseDto.parameters) {
            if (this.parameters[parameterId])
                continue;
            this._responseDto.parameters[parameterId].id = parameterId;
            switch (true) {
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.BOOL:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.COLOR:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.FILE:
                    this.parameters[parameterId] = new FileParameter_1.FileParameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.EVEN ||
                    this._responseDto.parameters[parameterId].type ===
                        viewer_shared_types_1.PARAMETER_TYPE.FLOAT ||
                    this._responseDto.parameters[parameterId].type ===
                        viewer_shared_types_1.PARAMETER_TYPE.INT ||
                    this._responseDto.parameters[parameterId].type ===
                        viewer_shared_types_1.PARAMETER_TYPE.ODD:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.INTERACTION:
                    this.parameters[parameterId] =
                        this.createInteractionParameter(this._responseDto.parameters[parameterId]);
                    break;
                case this._responseDto.parameters[parameterId].type ===
                    viewer_shared_types_1.PARAMETER_TYPE.DRAWING:
                    this.parameters[parameterId] = new DrawingParameter_1.DrawingParameter(this._responseDto.parameters[parameterId], this);
                    break;
                default:
                    this.parameters[parameterId] = new Parameter_1.Parameter(this._responseDto.parameters[parameterId], this);
                    break;
            }
            // we don't have to do larger restrictions for this as the backend would have already thrown an error if the values were not correct
            if (initialParameters) {
                // check if the id is within the initial parameters
                if (initialParameters[parameterId] !== undefined) {
                    this.parameters[parameterId].value =
                        initialParameters[parameterId];
                }
                // check if the name is within the initial parameters
                else if (initialParameters[this.parameters[parameterId].name] !==
                    undefined) {
                    this.parameters[parameterId].value =
                        initialParameters[this.parameters[parameterId].name];
                }
                // NOTE: At some point the checking may also be done with the displayname, this is the code for it
                // // check if the displayname is within the initial parameters
                // else if(this.parameters[parameterId].displayname && initialParameters[this.parameters[parameterId].displayname!] !== undefined) {
                //     this.parameters[parameterId].value = initialParameters[this.parameters[parameterId].displayname!];
                // }
            }
            parameterSet[parameterId] = {
                value: this.parameters[parameterId].value,
                valueString: this.parameters[parameterId].stringify(),
            };
            if (!this.initialized)
                this.parameterValues[parameterId] =
                    parameterSet[parameterId].valueString;
        }
        // store the initialization as the first parameter set in the history
        if (!this.initialized)
            __classPrivateFieldGet(this, _SessionEngine_parameterHistory, "f").push(parameterSet);
        for (const exportId in this._responseDto.exports) {
            if (this._responseDto.exports[exportId].type ===
                sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.EMAIL ||
                this._responseDto.exports[exportId].type ===
                    sdk_geometry_api_sdk_v2_1.ShapeDiverResponseExportDefinitionType.DOWNLOAD) {
                if (!this.exports[exportId]) {
                    this._responseDto.exports[exportId].id = exportId;
                    this.exports[exportId] = new Export_1.Export(this._responseDto.exports[exportId], this);
                }
                else {
                    this.exports[exportId].updateExportDefinition(this._responseDto.exports[exportId]);
                }
            }
        }
        for (const outputId in this._responseDto.outputs) {
            if (!this.outputs[outputId]) {
                this._responseDto.outputs[outputId].id = outputId;
                if (this.outputsFreeze[outputId] === undefined)
                    this.outputsFreeze[outputId] = false;
                this.outputs[outputId] = new Output_1.Output((this._responseDto.outputs[outputId]), this);
            }
            else {
                this.outputs[outputId].updateOutputDefinition((this._responseDto.outputs[outputId]));
            }
        }
    }
    waitForUpdateCallbacks(newOutputVersions, oldOutputVersions, newNode, oldNode) {
        return __awaiter(this, void 0, void 0, function* () {
            // call the update callback function on the session
            if (this._updateCallback)
                yield Promise.resolve(this._updateCallback(newNode, oldNode));
            const promises = [];
            // call the update callback functions on the outputs
            for (const outputId in this.outputs) {
                if (oldOutputVersions[outputId] !== newOutputVersions[outputId]) {
                    promises.push(this.outputs[outputId].triggerUpdateCallback(newNode.children.find((c) => c.name === outputId), oldNode.children.find((c) => c.name === outputId)));
                }
            }
            yield Promise.all(promises);
        });
    }
}
exports.SessionEngine = SessionEngine;
_SessionEngine_customizationBusyModes = new WeakMap(), _SessionEngine_customizationProcess = new WeakMap(), _SessionEngine_parameterHistory = new WeakMap(), _SessionEngine_parameterHistoryCall = new WeakMap(), _SessionEngine_parameterHistoryForward = new WeakMap();
//# sourceMappingURL=SessionEngine.js.map
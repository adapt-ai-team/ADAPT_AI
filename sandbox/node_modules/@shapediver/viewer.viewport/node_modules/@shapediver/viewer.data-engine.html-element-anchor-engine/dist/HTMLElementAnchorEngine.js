"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorEngine = void 0;
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
class HTMLElementAnchorEngine {
    constructor() {
        // #region Properties (4)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._inputValidator = viewer_shared_services_1.InputValidator.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        // #endregion Public Methods (1)
    }
    // #endregion Properties (4)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (1)
    /**
     * Load the material content into a scene graph node.
     *
     * @param content the material content
     * @returns the scene graph node
     */
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const node = new viewer_shared_node_tree_1.TreeNode("htmlElementAnchors");
                if (content.format === "tag2d") {
                    const data = content.data;
                    data.forEach((element) => {
                        // we need a location and a text, otherwise this doesn't make sense
                        if (!element.location || !element.text) {
                            this._logger.warn("HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.");
                            return;
                        }
                        const cleanedText = this._inputValidator.sanitize(element.text);
                        node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({
                            location: this._converter.toVec3(element.location),
                            data: {
                                color: element.color || "#000000",
                                text: cleanedText,
                            },
                        }));
                    });
                }
                else if (content.format === "anchor") {
                    const data = content.data;
                    data.forEach((element) => {
                        if (!element.location || !element.data) {
                            this._logger.warn("HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.");
                            return;
                        }
                        let position;
                        if (element.data.position)
                            position = {
                                vertical: element.data.position.vertical,
                                horizontal: element.data.position.horizontal,
                            };
                        let intersectionTarget;
                        if (element.intersectionTarget) {
                            if (typeof element.intersectionTarget === "string" ||
                                Array.isArray(element.intersectionTarget)) {
                                intersectionTarget = element.intersectionTarget;
                            }
                            else if (element.intersectionTarget.min &&
                                element.intersectionTarget.max) {
                                intersectionTarget = new viewer_shared_math_1.Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max));
                            }
                        }
                        if (!element.format || element.format === "text") {
                            if (!element.data.text) {
                                this._logger.warn("HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.");
                                return;
                            }
                            const textData = element.data;
                            const cleanedText = this._inputValidator.sanitize(textData.text);
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({
                                location: this._converter.toVec3(element.location),
                                data: {
                                    color: textData.color || "#000000",
                                    text: cleanedText,
                                    hidden: textData.hidden,
                                    textAlign: textData.textAlign,
                                    position,
                                },
                                hideable: element.hideable,
                                viewports: element.viewports,
                                intersectionTarget,
                            }));
                        }
                        else if (element.format === "image") {
                            if (!element.data.src ||
                                !element.data.width ||
                                !element.data.height ||
                                !element.data.alt) {
                                this._logger.warn("HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.");
                                return;
                            }
                            const imageData = element.data;
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorImageData({
                                location: this._converter.toVec3(element.location),
                                data: {
                                    alt: imageData.alt,
                                    height: typeof imageData.height === "string"
                                        ? +imageData.height
                                        : imageData.height,
                                    width: typeof imageData.width === "string"
                                        ? +imageData.width
                                        : imageData.width,
                                    src: imageData.src,
                                    hidden: imageData.hidden,
                                    position,
                                },
                                hideable: element.hideable,
                                viewports: element.viewports,
                                intersectionTarget,
                            }));
                        }
                        this._logger.warn(`HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);
                    });
                }
                return node;
            }
            catch (e) {
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("HTMLElementAnchorEngine.load: Loading of anchors failed.");
            }
        });
    }
}
exports.HTMLElementAnchorEngine = HTMLElementAnchorEngine;
//# sourceMappingURL=HTMLElementAnchorEngine.js.map
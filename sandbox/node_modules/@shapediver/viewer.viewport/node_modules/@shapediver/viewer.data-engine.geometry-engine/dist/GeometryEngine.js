"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryEngine = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const GLTFLoader_1 = require("./gltfv1/GLTFLoader");
const GLTFLoader_2 = require("./gltfv2/GLTFLoader");
class GeometryEngine {
    constructor() {
        // #region Properties (7)
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._loadingQueue = [];
        this._logger = viewer_shared_services_1.Logger.instance;
        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;
        this._loadingQueueLength = Infinity;
        // #endregion Public Methods (1)
    }
    // #endregion Properties (7)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Accessors (2)
    get parallelGlTFProcessing() {
        return this._loadingQueueLength;
    }
    set parallelGlTFProcessing(value) {
        this._loadingQueueLength = value;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (1)
    /**
     * Load the geometry content into a scene graph node.
     *
     * @param content the geometry content
     * @returns the scene graph node
     */
    loadContent(content, taskEventId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!content || (content && !content.href))
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("GeometryEngine cannot load content.");
            while (this._loadingQueueLength <= this._loadingQueue.length)
                yield new Promise((resolve) => setTimeout(resolve, 10));
            const url = content.href;
            // eslint-disable-next-line no-async-promise-executor
            const loadingPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;
                let version = "2.0";
                if (content.format === "glb" || content.format === "gltf") {
                    this._performanceEvaluator.startSection("gltfProcessing." + url);
                    this._performanceEvaluator.startSection("loadGltf." + url);
                    const axiosResponse = (yield this._httpClient
                        .get(url, {
                        responseType: "arraybuffer",
                    })
                        .catch(reject));
                    this._performanceEvaluator.endSection("loadGltf." + url);
                    const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));
                    const isBinary = magic === "glTF";
                    if (isBinary) {
                        gltfBinary = axiosResponse.data;
                        // create header data
                        const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
                        gltfHeader = {
                            magic: magic,
                            version: headerDataView.getUint32(4, true),
                            length: headerDataView.getUint32(8, true),
                            contentLength: headerDataView.getUint32(12, true),
                            contentFormat: headerDataView.getUint32(16, true),
                        };
                        if (gltfHeader.magic != "glTF")
                            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("Invalid data: glTF magic wrong.");
                        // create content
                        const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);
                        const contentDecoded = new TextDecoder().decode(contentDataView);
                        gltfContent = JSON.parse(contentDecoded);
                        if (gltfContent &&
                            gltfContent.asset &&
                            gltfContent.asset.version) {
                            const assetVersion = (gltfContent.asset.version + "").endsWith(".0")
                                ? gltfContent.asset.version
                                : gltfContent.asset.version + ".0";
                            if (gltfHeader.version + ".0" === assetVersion) {
                                version = gltfHeader.version + ".0";
                            }
                            else {
                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("GeometryEngine.loadContent: glTF header version (" +
                                    gltfHeader.version +
                                    ") is not the same as asset version (" +
                                    assetVersion +
                                    ").");
                            }
                        }
                        else {
                            version = gltfHeader.version + ".0";
                        }
                    }
                    else {
                        gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));
                        if (gltfContent &&
                            gltfContent.asset &&
                            gltfContent.asset.version) {
                            if (gltfContent.asset.version !== "2.0")
                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("GeometryEngine.loadContent: Only gltf v2 is supported in a non-binary format.");
                        }
                        else {
                            this._logger.warn("GeometryEngine.loadContent: No version specified in asset, trying to load as v2.");
                            version = "2.0";
                        }
                        const removeLastDirectoryPartOf = (the_url) => {
                            const dir_char = the_url.includes("/") ? "/" : "\\";
                            const the_arr = the_url.split(dir_char);
                            the_arr.pop();
                            return the_arr.join(dir_char);
                        };
                        gltfBaseUrl = removeLastDirectoryPartOf(url);
                        if (!gltfBaseUrl &&
                            window &&
                            window.location &&
                            window.location.href)
                            gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);
                    }
                }
                let promise;
                if (version === "1.0") {
                    promise = new GLTFLoader_1.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);
                }
                else {
                    promise = new GLTFLoader_2.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);
                }
                promise.catch((e) => {
                    reject(e);
                });
                resolve(promise);
            }));
            this._loadingQueue.push(loadingPromise);
            const node = yield loadingPromise;
            this._loadingQueue.splice(this._loadingQueue.indexOf(loadingPromise), 1);
            this._performanceEvaluator.endSection("gltfProcessing." + url);
            return node;
        });
    }
}
exports.GeometryEngine = GeometryEngine;
//# sourceMappingURL=GeometryEngine.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfBinaryBufferCache = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
class SdtfBinaryBufferCache {
    constructor() {
        this.cacheIdFullBuffer = 'full';
        this.cache = {};
    }
    calcCacheKey(uri = '') {
        let hash = 0;
        for (let i = 0; i < uri.length; i++) {
            const char = uri.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash &= hash;
        }
        return new Uint32Array([hash])[0].toString(36);
    }
    calcCacheId(offset, length) {
        return `${offset};${length}`;
    }
    loadFromCache(key, offset, length) {
        const item = this.cache[key];
        if (!item) {
            return undefined;
        }
        const id = this.calcCacheId(offset, length);
        if (item[id]) {
            return item[id];
        }
        if (item[this.cacheIdFullBuffer]) {
            const buffer = item[this.cacheIdFullBuffer];
            return new DataView(buffer.buffer, buffer.byteOffset + offset, length);
        }
    }
    storeInCache(key, id, buffer) {
        var _a;
        const item = (_a = this.cache[key]) !== null && _a !== void 0 ? _a : {};
        item[id] = buffer;
        this.cache[key] = item;
    }
    setBinaryBody(binaryBody) {
        if (!binaryBody)
            return;
        this.cache[this.calcCacheKey()] = {
            [this.cacheIdFullBuffer]: binaryBody,
        };
    }
    getBuffer(uri, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const cacheKey = this.calcCacheKey(uri);
            return ((_a = this.loadFromCache(cacheKey, offset, length)) !== null && _a !== void 0 ? _a : (yield this.acquireBuffer(uri, length, offset)));
        });
    }
    acquireBuffer(uri, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new sdk_sdtf_core_1.SdtfError('Resolution of external buffers is not supported in this mode. ' +
                "Please use 'ISdtfParser.readFromFile()' or 'ISdtfParser.readFromUrl()' to instantiate the sdTF asset and to enable this functionality.");
        });
    }
}
exports.SdtfBinaryBufferCache = SdtfBinaryBufferCache;
//# sourceMappingURL=SdtfBinaryBufferCache.js.map
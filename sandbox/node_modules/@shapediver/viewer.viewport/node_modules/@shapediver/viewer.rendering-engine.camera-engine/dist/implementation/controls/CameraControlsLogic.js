"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraControlsLogic = void 0;
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const gl_matrix_1 = require("gl-matrix");
const IOrthographicCamera_1 = require("../../interfaces/camera/IOrthographicCamera");
const ICameraEngine_1 = require("../../interfaces/ICameraEngine");
const OrthographicCamera_1 = require("../camera/OrthographicCamera");
class CameraControlsLogic {
    // #endregion Properties (13)
    // #region Constructors (1)
    constructor(_controls, _settingsAdjustments, _touchAdjustments) {
        this._controls = _controls;
        this._settingsAdjustments = _settingsAdjustments;
        this._touchAdjustments = _touchAdjustments;
        // #region Properties (13)
        this._adjustedSettings = {
            autoRotationSpeed: () => this._controls.autoRotationSpeed *
                this._settingsAdjustments.autoRotationSpeed,
            damping: () => this._controls.damping * this._settingsAdjustments.damping,
            movementSmoothness: () => this._controls.movementSmoothness *
                this._settingsAdjustments.movementSmoothness,
            panSpeed: () => this._controls.panSpeed * this._settingsAdjustments.panSpeed,
            rotationSpeed: () => this._controls.rotationSpeed *
                this._settingsAdjustments.rotationSpeed,
            zoomSpeed: () => this._controls.zoomSpeed * this._settingsAdjustments.zoomSpeed,
        };
        this._damping = {
            rotation: {
                time: 0,
                duration: 0,
                theta: 0,
                phi: 0,
            },
            zoom: {
                time: 0,
                duration: 0,
                delta: 0,
            },
            pan: {
                time: 0,
                duration: 0,
                offset: gl_matrix_1.vec3.create(),
            },
        };
        this._dollyDelta = 0;
        this._dollyEnd = 0;
        this._dollyStart = 0;
        this._panDelta = gl_matrix_1.vec2.create();
        this._panEnd = gl_matrix_1.vec2.create();
        this._panStart = gl_matrix_1.vec2.create();
        this._rotateDelta = gl_matrix_1.vec2.create();
        this._rotateEnd = gl_matrix_1.vec2.create();
        this._rotateStart = gl_matrix_1.vec2.create();
        this._quat = gl_matrix_1.quat.fromValues(-Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));
        this._quatInverse = gl_matrix_1.quat.fromValues(Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));
    }
    // #endregion Constructors (1)
    // #region Public Methods (7)
    isWithinRestrictions(position, target) {
        const pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);
        if (!(pBox.containsPoint(position) && pSphere.containsPoint(position)))
            return false;
        if (!(tBox.containsPoint(target) && tSphere.containsPoint(target)))
            return false;
        const currentDistance = gl_matrix_1.vec3.distance(position, target);
        if (currentDistance > this._controls.zoomRestriction.maxDistance ||
            currentDistance < this._controls.zoomRestriction.minDistance)
            return false;
        const minPolarAngle = this._controls.rotationRestriction.minPolarAngle *
            (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle *
            (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle *
            (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle *
            (Math.PI / 180);
        if (minAzimuthAngle !== -Infinity ||
            maxAzimuthAngle !== Infinity ||
            minPolarAngle !== 0 ||
            maxPolarAngle !== 180) {
            const offset = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, target);
            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
            if (spherical.theta < minAzimuthAngle ||
                spherical.theta > maxAzimuthAngle ||
                spherical.phi < minPolarAngle ||
                spherical.phi > maxPolarAngle) {
                return false;
            }
        }
        return true;
    }
    pan(x, y, active, touch) {
        if (!active) {
            this._panStart = gl_matrix_1.vec2.fromValues(x, y);
        }
        else {
            this._panEnd = gl_matrix_1.vec2.fromValues(x, y);
            gl_matrix_1.vec2.sub(this._panDelta, this._panEnd, this._panStart);
            if (this._panDelta[0] === 0 && this._panDelta[1] === 0)
                return;
            gl_matrix_1.vec2.copy(this._panStart, this._panEnd);
            const adjustedPanSpeed = this._adjustedSettings.panSpeed() *
                (touch ? this._touchAdjustments.panSpeed : 1.0);
            const offset = this.panDeltaToOffset(gl_matrix_1.vec2.mul(gl_matrix_1.vec2.create(), this._panDelta, gl_matrix_1.vec2.fromValues(adjustedPanSpeed, adjustedPanSpeed)));
            if (this._damping.pan.duration > 0) {
                if (offset[0] < 0) {
                    offset[0] = Math.min(offset[0], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[0]);
                }
                else {
                    offset[0] = Math.max(offset[0], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[0]);
                }
                if (offset[1] < 0) {
                    offset[1] = Math.min(offset[1], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[1]);
                }
                else {
                    offset[1] = Math.max(offset[1], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[1]);
                }
                if (offset[2] < 0) {
                    offset[2] = Math.min(offset[2], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[2]);
                }
                else {
                    offset[2] = Math.max(offset[2], this._adjustedSettings.movementSmoothness() *
                        this._damping.pan.offset[2]);
                }
            }
            const damping = 1 -
                Math.max(0.01, Math.min(0.99, this._adjustedSettings.damping()));
            const framesOffsetX = (Math.log(1 / Math.abs(offset[0])) - 5 * Math.log(10)) /
                Math.log(damping);
            const framesOffsetY = (Math.log(1 / Math.abs(offset[1])) - 5 * Math.log(10)) /
                Math.log(damping);
            const framesOffsetZ = (Math.log(1 / Math.abs(offset[2])) - 5 * Math.log(10)) /
                Math.log(damping);
            this._damping.pan.time = 0;
            this._damping.pan.duration =
                Math.max(framesOffsetX, Math.max(framesOffsetY, framesOffsetZ)) * 16.6666;
            this._damping.pan.offset = gl_matrix_1.vec3.clone(offset);
            this._damping.rotation.duration = 0;
            this._damping.zoom.duration = 0;
            this._controls.applyTargetVector(offset, true);
            this._controls.applyPositionVector(offset, true);
        }
    }
    reset() {
        this._damping = {
            rotation: {
                time: 0,
                duration: 0,
                theta: 0,
                phi: 0,
            },
            zoom: {
                time: 0,
                duration: 0,
                delta: 0,
            },
            pan: {
                time: 0,
                duration: 0,
                offset: gl_matrix_1.vec3.create(),
            },
        };
        this._dollyDelta = 0;
        this._dollyEnd = 0;
        this._dollyStart = 0;
        this._panDelta = gl_matrix_1.vec2.create();
        this._panEnd = gl_matrix_1.vec2.create();
        this._panStart = gl_matrix_1.vec2.create();
        this._rotateDelta = gl_matrix_1.vec2.create();
        this._rotateEnd = gl_matrix_1.vec2.create();
        this._rotateStart = gl_matrix_1.vec2.create();
    }
    restrict(position, target, sceneRotation) {
        const pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);
        if (!pBox.containsPoint(position))
            position = pBox.clampPoint(position);
        if (!pSphere.containsPoint(position))
            position = pSphere.clampPoint(position);
        if (!tBox.containsPoint(target))
            target = tBox.clampPoint(target);
        if (!tSphere.containsPoint(target))
            target = tSphere.clampPoint(target);
        // zoom restrictions
        const currentDistance = gl_matrix_1.vec3.distance(position, target);
        if (currentDistance > this._controls.zoomRestriction.maxDistance ||
            currentDistance < this._controls.zoomRestriction.minDistance) {
            const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target));
            const distance = Math.max(this._controls.zoomRestriction.minDistance, Math.min(this._controls.zoomRestriction.maxDistance, currentDistance));
            gl_matrix_1.vec3.add(position, gl_matrix_1.vec3.multiply(position, direction, gl_matrix_1.vec3.fromValues(distance, distance, distance)), target);
        }
        // angle restrictions
        const minPolarAngle = this._controls.rotationRestriction.minPolarAngle *
            (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle *
            (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle *
            (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle *
            (Math.PI / 180);
        if (minAzimuthAngle !== -Infinity ||
            maxAzimuthAngle !== Infinity ||
            minPolarAngle !== 0 ||
            maxPolarAngle !== 180 ||
            this._controls.enableAzimuthRotation === false ||
            this._controls.enablePolarRotation === false ||
            this._controls.enableObjectControls === true) {
            let offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target);
            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
            if (spherical.theta < minAzimuthAngle ||
                spherical.theta > maxAzimuthAngle ||
                spherical.phi < minPolarAngle ||
                spherical.phi > maxPolarAngle ||
                this._controls.enableAzimuthRotation === false ||
                this._controls.enablePolarRotation === false ||
                this._controls.enableObjectControls === true) {
                spherical.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, spherical.theta));
                spherical.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, spherical.phi));
                if (this._controls.enableAzimuthRotation === false ||
                    this._controls.enablePolarRotation === false ||
                    this._controls.enableObjectControls === true) {
                    const defaultOffset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), this._controls.camera.defaultPosition, this._controls.camera.defaultTarget);
                    gl_matrix_1.vec3.transformQuat(defaultOffset, defaultOffset, this._quat);
                    const defaultSpherical = new viewer_shared_math_1.Spherical().fromVec3(defaultOffset);
                    if (this._controls.enableAzimuthRotation === false)
                        spherical.theta = defaultSpherical.theta;
                    if (this._controls.enablePolarRotation === false)
                        spherical.phi = defaultSpherical.phi;
                    if (this._controls.enableObjectControls) {
                        spherical.theta = defaultSpherical.theta;
                        spherical.phi = defaultSpherical.phi;
                    }
                }
                spherical.makeSafe();
                offset = spherical.toVec3();
                gl_matrix_1.vec3.transformQuat(offset, offset, this._quatInverse);
                gl_matrix_1.vec3.add(position, offset, target);
            }
            if ((sceneRotation[1] < minAzimuthAngle ||
                sceneRotation[1] > maxAzimuthAngle ||
                sceneRotation[0] < minPolarAngle ||
                sceneRotation[0] > maxPolarAngle ||
                this._controls.enableAzimuthRotation === false ||
                this._controls.enablePolarRotation === false) &&
                this._controls.enableObjectControls === false) {
                sceneRotation[1] =
                    this._controls.enableAzimuthRotation === false
                        ? 0
                        : Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sceneRotation[1]));
                sceneRotation[0] =
                    this._controls.enablePolarRotation === false
                        ? 0
                        : Math.max(minPolarAngle, Math.min(maxPolarAngle, sceneRotation[0]));
            }
        }
        return { position, target, sceneRotation };
    }
    rotate(x, y, active, touch) {
        if (this._controls.camera.type === ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC &&
            this._controls.camera.direction !==
                IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.CUSTOM)
            return;
        if (!active) {
            this._rotateStart = gl_matrix_1.vec2.fromValues(x, y);
        }
        else {
            this._rotateEnd = gl_matrix_1.vec2.fromValues(x, y);
            gl_matrix_1.vec2.subtract(this._rotateDelta, this._rotateEnd, this._rotateStart);
            gl_matrix_1.vec2.copy(this._rotateStart, this._rotateEnd);
            if (!this._controls.canvas)
                return;
            if (this._controls.canvas.clientWidth == 0 ||
                this._controls.canvas.clientHeight == 0)
                return;
            const spherical = new viewer_shared_math_1.Spherical();
            const rotationSpeed = this._adjustedSettings.rotationSpeed() *
                (touch ? this._touchAdjustments.rotationSpeed : 1.0);
            spherical.theta -=
                (rotationSpeed * this._rotateDelta[0]) /
                    this._controls.canvas.clientHeight;
            spherical.phi -=
                (rotationSpeed * this._rotateDelta[1]) /
                    this._controls.canvas.clientHeight;
            if (this._damping.rotation.duration > 0) {
                const thetaDelta = this._damping.rotation.theta - spherical.theta;
                spherical.theta +=
                    thetaDelta * this._adjustedSettings.movementSmoothness();
                const phiDelta = this._damping.rotation.phi - spherical.phi;
                spherical.phi +=
                    phiDelta * this._adjustedSettings.movementSmoothness();
            }
            let sphericalForOffset = spherical;
            if (this._controls.enableTurntableControls)
                sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
            const offset = this.rotationSphericalToOffset(sphericalForOffset);
            const damping = 1 -
                Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
            const framesTheta = (Math.log(1 / Math.abs(spherical.theta)) - 5 * Math.log(10)) /
                Math.log(damping);
            const framesPhi = (Math.log(1 / Math.abs(spherical.phi)) - 5 * Math.log(10)) /
                Math.log(damping);
            this._damping.rotation.time = 0;
            this._damping.rotation.duration =
                Math.max(framesTheta, framesPhi) * 16.6666;
            this._damping.rotation.theta = spherical.theta;
            this._damping.rotation.phi = spherical.phi;
            this._damping.pan.duration = 0;
            this._damping.zoom.duration = 0;
            this._controls.applyPositionVector(offset, true);
            if (this._controls.enableTurntableControls)
                this._controls.applyRotation([0, spherical.theta], true);
            if (this._controls.enableObjectControls)
                this._controls.applyRotation([spherical.phi, spherical.theta], true);
        }
    }
    update(time, manualInteraction) {
        if (manualInteraction === true) {
            this._damping.zoom.duration = 0;
            this._damping.pan.duration = 0;
            this._damping.rotation.duration = 0;
        }
        const damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
        if (this._damping.pan.duration > 0) {
            if (this._damping.pan.time + time > this._damping.pan.duration) {
                this._damping.pan.time = this._damping.pan.duration;
                this._damping.pan.duration = 0;
            }
            else {
                this._damping.pan.time += time;
                const frameSinceStart = this._damping.pan.time / 16.6666;
                const dampingFrames = Math.pow(damping, frameSinceStart);
                const offset = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._damping.pan.offset, gl_matrix_1.vec3.fromValues(dampingFrames, dampingFrames, dampingFrames));
                this._controls.applyTargetVector(offset);
                this._controls.applyPositionVector(offset);
            }
        }
        else {
            this._damping.pan.time = 0;
        }
        if (this._damping.rotation.duration > 0) {
            if (this._damping.rotation.time + time >
                this._damping.rotation.duration) {
                this._damping.rotation.time = this._damping.rotation.duration;
                this._damping.rotation.duration = 0;
            }
            else {
                this._damping.rotation.time += time;
                const frameSinceStart = this._damping.rotation.time / 16.6666;
                const spherical = new viewer_shared_math_1.Spherical();
                spherical.theta =
                    this._damping.rotation.theta *
                        Math.pow(damping, frameSinceStart);
                spherical.phi =
                    this._damping.rotation.phi *
                        Math.pow(damping, frameSinceStart);
                let sphericalForOffset = spherical;
                if (this._controls.enableTurntableControls)
                    sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
                const offset = this.rotationSphericalToOffset(sphericalForOffset);
                this._controls.applyPositionVector(offset);
                if (this._controls.enableTurntableControls)
                    this._controls.applyRotation([0, spherical.theta]);
                if (this._controls.enableObjectControls)
                    this._controls.applyRotation([
                        spherical.phi,
                        spherical.theta,
                    ]);
            }
        }
        else {
            this._damping.rotation.time = 0;
        }
        if (this._damping.zoom.duration > 0) {
            if (this._damping.zoom.time + time > this._damping.zoom.duration) {
                this._damping.zoom.time = this._damping.zoom.duration;
                this._damping.zoom.duration = 0;
            }
            else {
                this._damping.zoom.time += time;
                const frameSinceStart = this._damping.zoom.time / 16.6666;
                const delta = this._damping.zoom.delta *
                    Math.pow(damping, frameSinceStart);
                const offset = this.zoomDistanceToOffset(delta);
                this._controls.applyPositionVector(offset);
            }
        }
        else {
            this._damping.zoom.time = 0;
        }
        if (this._controls.enableAutoRotation) {
            const spherical = new viewer_shared_math_1.Spherical(1.0, 0.0, -this._adjustedSettings.autoRotationSpeed());
            let sphericalForOffset = spherical;
            if (this._controls.enableTurntableControls)
                sphericalForOffset = new viewer_shared_math_1.Spherical(1.0, spherical.phi, 0);
            const offset = this.rotationSphericalToOffset(sphericalForOffset);
            this._controls.applyPositionVector(offset);
            if (this._controls.enableTurntableControls)
                this._controls.applyRotation([0, spherical.theta]);
            if (this._controls.enableObjectControls)
                this._controls.applyRotation([spherical.phi, spherical.theta]);
        }
    }
    zoom(x, y, active, touch) {
        const distance = Math.sqrt(x * x + y * y);
        if (!active) {
            this._dollyStart = distance;
        }
        else {
            this._dollyEnd = distance;
            this._dollyDelta = this._dollyEnd - this._dollyStart;
            this._dollyStart = this._dollyEnd;
            if (this._damping.zoom.duration > 0) {
                if (this._dollyDelta < 0) {
                    this._dollyDelta = Math.min(this._dollyDelta, this._adjustedSettings.movementSmoothness() *
                        this._damping.zoom.delta);
                }
                else {
                    this._dollyDelta = Math.max(this._dollyDelta, this._adjustedSettings.movementSmoothness() *
                        this._damping.zoom.delta);
                }
            }
            const delta = -this._dollyDelta *
                this._adjustedSettings.zoomSpeed() *
                (touch ? this._touchAdjustments.zoomSpeed : 1.0);
            const damping = 1 -
                Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));
            const framesDelta = (Math.log(1 / Math.abs(this._dollyDelta)) - 5 * Math.log(10)) /
                Math.log(damping);
            this._damping.zoom.time = 0;
            this._damping.zoom.duration = framesDelta * 16.6666;
            this._damping.zoom.delta = delta;
            this._damping.rotation.duration = 0;
            this._damping.pan.duration = 0;
            const offset = this.zoomDistanceToOffset(delta);
            this._controls.applyPositionVector(offset, true);
        }
    }
    // #endregion Public Methods (7)
    // #region Private Methods (3)
    panDeltaToOffset(panDelta) {
        var _a, _b, _c, _d;
        const offset = gl_matrix_1.vec3.create();
        const panOffset = gl_matrix_1.vec3.create();
        if (!this._controls.canvas)
            return offset;
        if (this._controls.canvas.clientWidth == 0 ||
            this._controls.canvas.clientHeight == 0)
            return offset;
        // perspective
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        if (this._controls.camera instanceof OrthographicCamera_1.OrthographicCamera) {
            const orthographicCamera = (this._controls.camera);
            const mat = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), orthographicCamera.position, orthographicCamera.target, orthographicCamera.up);
            // // we use only clientHeight here so aspect ratio does not distort speed
            // // left
            const v1 = gl_matrix_1.vec3.fromValues(mat[0], mat[1], mat[2]);
            const scalar1 = -(((panDelta[0] *
                (orthographicCamera.right - orthographicCamera.left) *
                0.5) /
                ((_a = this._controls.canvas) === null || _a === void 0 ? void 0 : _a.clientHeight)) /** orthographicCamera.zoom */);
            gl_matrix_1.vec3.multiply(v1, v1, gl_matrix_1.vec3.fromValues(scalar1, scalar1, scalar1));
            gl_matrix_1.vec3.add(panOffset, panOffset, v1);
            // // up
            const v2 = gl_matrix_1.vec3.fromValues(mat[4], mat[5], mat[6]);
            const scalar2 = (panDelta[1] *
                (orthographicCamera.right - orthographicCamera.left) *
                0.5) /
                ((_b = this._controls.canvas) === null || _b === void 0 ? void 0 : _b.clientHeight); /** orthographicCamera.zoom */
            gl_matrix_1.vec3.multiply(v2, v2, gl_matrix_1.vec3.fromValues(scalar2, scalar2, scalar2));
            gl_matrix_1.vec3.add(panOffset, panOffset, v2);
        }
        else {
            let targetDistance = gl_matrix_1.vec3.length(offset);
            // half of the fov is center to top of screen
            targetDistance *= Math.tan(((this._controls.camera.fov / 2) *
                Math.PI) /
                180.0);
            // we use only clientHeight here so aspect ratio does not distort speed
            // left
            const mat = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this._controls.camera.position, this._controls.camera.target, gl_matrix_1.vec3.fromValues(0, 0, 1));
            const v1 = gl_matrix_1.vec3.fromValues(mat[0], mat[1], mat[2]);
            const scalar1 = -((2 * panDelta[0] * targetDistance) /
                ((_c = this._controls.canvas) === null || _c === void 0 ? void 0 : _c.clientHeight));
            gl_matrix_1.vec3.multiply(v1, v1, gl_matrix_1.vec3.fromValues(scalar1, scalar1, scalar1));
            gl_matrix_1.vec3.add(panOffset, panOffset, v1);
            // // up
            const v2 = gl_matrix_1.vec3.fromValues(mat[4], mat[5], mat[6]);
            const scalar2 = (2 * panDelta[1] * targetDistance) /
                ((_d = this._controls.canvas) === null || _d === void 0 ? void 0 : _d.clientHeight);
            gl_matrix_1.vec3.multiply(v2, v2, gl_matrix_1.vec3.fromValues(scalar2, scalar2, scalar2));
            gl_matrix_1.vec3.add(panOffset, panOffset, v2);
        }
        return gl_matrix_1.vec3.clone(panOffset);
    }
    rotationSphericalToOffset(s) {
        let offset = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);
        const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);
        spherical.theta += s.theta;
        spherical.phi += s.phi;
        const minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle *
            (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle *
            (Math.PI / 180);
        if (spherical.theta > Math.PI) {
            spherical.theta -= 2 * Math.PI;
            if (minAzimuthAngle > spherical.theta) {
                spherical.theta += 2 * Math.PI;
            }
        }
        else if (spherical.theta < -Math.PI) {
            spherical.theta += 2 * Math.PI;
            if (maxAzimuthAngle < spherical.theta) {
                spherical.theta -= 2 * Math.PI;
            }
        }
        spherical.makeSafe();
        offset = spherical.toVec3();
        offset = gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), offset, this._quatInverse);
        offset = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), offset, this._controls.getTargetWithManualUpdates());
        offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), offset, this._controls.getPositionWithManualUpdates());
        return gl_matrix_1.vec3.clone(offset);
    }
    zoomDistanceToOffset(distance) {
        const offset = gl_matrix_1.vec3.create();
        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());
        return gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), offset, gl_matrix_1.vec3.fromValues(distance, distance, distance));
    }
}
exports.CameraControlsLogic = CameraControlsLogic;
//# sourceMappingURL=CameraControlsLogic.js.map
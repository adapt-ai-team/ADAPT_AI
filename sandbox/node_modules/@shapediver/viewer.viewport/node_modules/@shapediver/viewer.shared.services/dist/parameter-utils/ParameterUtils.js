"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.isValid = void 0;
const api_geometry_api_dto_v2_1 = require("@shapediver/api.geometry-api-dto-v2");
const Converter_1 = require("../converter/Converter");
const InputValidator_1 = require("../input-validator/InputValidator");
const ShapeDiverViewerErrors_1 = require("../logger/ShapeDiverViewerErrors");
const isValid = (definition, value, throwError) => {
    try {
        return validateParameterValue(definition, value);
    }
    catch (e) {
        if (throwError)
            throw e;
        return false;
    }
};
exports.isValid = isValid;
const validateParameterValue = (definition, value) => {
    const { id, type, min, max, decimalplaces, choices, visualization } = definition;
    switch (true) {
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.BOOL:
            if (typeof value === "string") {
                if (!(value === "true" || value === "false"))
                    throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is a string that is neither true or false.`);
            }
            else {
                InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, value, "boolean");
            }
            break;
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.COLOR:
            InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, value, "color");
            break;
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.FILE:
            InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, value, "file");
            break;
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.EVEN ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.FLOAT ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.INT ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.ODD:
            {
                let temp = value;
                if (typeof value === "string")
                    temp = +value;
                InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, temp, "number");
                if (type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.EVEN) {
                    if (temp % 2 !== 0)
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is not even.`);
                }
                else if (type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.ODD) {
                    if (temp % 2 === 0)
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is not odd.`);
                }
                else if (type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.INT) {
                    if (!Number.isInteger(temp))
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is not an integer.`);
                }
                if (min || min === 0)
                    if (temp < min)
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is smaller than the minimum ${min}.`);
                if (max || max === 0)
                    if (temp > max)
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} is larger than the maximum ${max}.`);
                if (decimalplaces || decimalplaces === 0) {
                    const numStr = temp + "";
                    let decimalplaces = 0;
                    if (numStr.includes("."))
                        decimalplaces = numStr.split(".")[1].length;
                    if (decimalplaces < decimalplaces)
                        throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${value} has not the correct number of decimalplaces (${decimalplaces}).`);
                }
            }
            break;
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.STRINGLIST: {
            InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, value, "string");
            const choicesChecker = (v) => {
                // has to be a single value that is
                // 1. convertible to number
                // 2. between 0 and choices.length -1
                const temp = +v;
                InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, temp, "number");
                if (temp < 0 || temp > choices.length - 1)
                    throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${v} is not within the range of the defined number choices.`);
            };
            if (visualization ===
                api_geometry_api_dto_v2_1.ShapeDiverResponseParameterVisualization.CHECKLIST) {
                // comma separated numbers
                if (value.includes(",")) {
                    const values = value.split(",");
                    for (let i = 0; i < values.length; i++) {
                        if (values.filter((item) => item === values[i])
                            .length !== 1)
                            throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).isValid: The value ${values[i]} exists multiple times, but should only exist once.`);
                        choicesChecker(values[i]);
                    }
                }
                else {
                    // to number
                    let temp = value;
                    if (typeof value === "string")
                        temp = +value;
                    InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, temp, "number");
                    choicesChecker(value);
                }
            }
            else {
                // to number
                let temp = value;
                if (typeof value === "string")
                    temp = +value;
                InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, temp, "number");
                choicesChecker(value);
            }
            break;
        }
        default:
            InputValidator_1.InputValidator.instance.validateAndError(`Parameter(${id}).isValid`, value, "string");
            break;
    }
    return true;
};
const stringify = (definition, value) => {
    const { id, type, decimalplaces } = definition;
    switch (true) {
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.BOOL:
            return typeof value === "string"
                ? value
                : value + "";
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.COLOR:
            return Converter_1.Converter.instance.toHex8Color(value);
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.FILE:
            if (typeof value !== "string")
                throw new ShapeDiverViewerErrors_1.ShapeDiverViewerSessionError(`Parameter(${id}).stringify: Error in stringify. Cannot stringify FileParameter that has not been uploaded yet.`);
            return value;
        case type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.EVEN ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.FLOAT ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.INT ||
            type === api_geometry_api_dto_v2_1.ShapeDiverResponseParameterType.ODD:
            if (typeof value === "string") {
                // cast to number and round to decimalplaces if they exist
                if (decimalplaces || decimalplaces === 0) {
                    const number = +value;
                    return number.toFixed(decimalplaces);
                }
                else {
                    return value;
                }
            }
            else {
                // round to decimalplaces if they exist
                if (decimalplaces || decimalplaces === 0) {
                    return value.toFixed(decimalplaces);
                }
                else {
                    return value + "";
                }
            }
        default:
            return value;
    }
};
exports.stringify = stringify;
//# sourceMappingURL=ParameterUtils.js.map
import { RenderingEngine as RenderingEngineThreeJs } from "@shapediver/viewer.rendering-engine.rendering-engine-threejs";
import { ISettings } from "@shapediver/viewer.settings";
import { ITreeNode } from "@shapediver/viewer.shared.node-tree";
import { IDomEventListener, SESSION_SETTINGS_MODE } from "@shapediver/viewer.shared.services";
import { Color, FLAG_TYPE, IAnimationData, IGeometryData, IIntersectionFilter, ISDTFAttributeVisualizationData, ISDTFItemData, ISDTFOverview, MaterialBasicLineData, MaterialPointData, MaterialStandardData, MATERIAL_TYPE, RENDERER_TYPE, TEXTURE_ENCODING, TONE_MAPPING } from "@shapediver/viewer.shared.types";
import { quat, vec2, vec3 } from "gl-matrix";
import * as THREE from "three";
import { ICameraApi } from "../interfaces/camera/ICameraApi";
import { IOrthographicCameraApi } from "../interfaces/camera/IOrthographicCameraApi";
import { IPerspectiveCameraApi } from "../interfaces/camera/IPerspectiveCameraApi";
import { IPostProcessingApi } from "../interfaces/IPostProcessingApi";
import { IViewportApi } from "../interfaces/IViewportApi";
import { ILightSceneApi } from "../interfaces/lights/ILightSceneApi";
export declare class ViewportApi implements IViewportApi {
    #private;
    constructor(renderingEngine: RenderingEngineThreeJs);
    get animations(): {
        [key: string]: IAnimationData;
    };
    get arRotation(): vec3;
    set arRotation(value: vec3);
    get arScale(): vec3;
    set arScale(value: vec3);
    get arTranslation(): vec3;
    set arTranslation(value: vec3);
    get automaticColorAdjustment(): boolean;
    set automaticColorAdjustment(value: boolean);
    get automaticResizing(): boolean;
    set automaticResizing(value: boolean);
    get beautyRenderBlendingDuration(): number;
    set beautyRenderBlendingDuration(value: number);
    get beautyRenderDelay(): number;
    set beautyRenderDelay(value: number);
    get camera(): ICameraApi | null;
    get cameras(): {
        [key: string]: ICameraApi;
    };
    get canvas(): HTMLCanvasElement;
    get clearAlpha(): number;
    set clearAlpha(value: number);
    get clearColor(): Color;
    set clearColor(value: Color);
    get contactShadowBlur(): number;
    set contactShadowBlur(value: number);
    get contactShadowDarkness(): number;
    set contactShadowDarkness(value: number);
    get contactShadowHeight(): number;
    set contactShadowHeight(value: number);
    get contactShadowOpacity(): number;
    set contactShadowOpacity(value: number);
    get contactShadowVisibility(): boolean;
    set contactShadowVisibility(value: boolean);
    get defaultLineMaterial(): MaterialBasicLineData;
    get defaultMaterial(): MaterialStandardData;
    get defaultMaterialColor(): Color;
    set defaultMaterialColor(value: Color);
    get defaultPointMaterial(): MaterialPointData;
    get enableAR(): boolean;
    set enableAR(value: boolean);
    get environmentMap(): string | string[];
    set environmentMap(value: string | string[]);
    get environmentMapAsBackground(): boolean;
    set environmentMapAsBackground(value: boolean);
    get environmentMapBlurriness(): number;
    set environmentMapBlurriness(value: number);
    get environmentMapForUnlitMaterials(): boolean;
    set environmentMapForUnlitMaterials(value: boolean);
    get environmentMapIntensity(): number;
    set environmentMapIntensity(value: number);
    get environmentMapResolution(): string;
    set environmentMapResolution(value: string);
    get environmentMapRotation(): quat;
    set environmentMapRotation(value: quat);
    get gridColor(): Color;
    set gridColor(value: Color);
    get gridVisibility(): boolean;
    set gridVisibility(value: boolean);
    get groundPlaneColor(): Color;
    set groundPlaneColor(value: Color);
    get groundPlaneShadowColor(): Color;
    set groundPlaneShadowColor(value: Color);
    get groundPlaneShadowVisibility(): boolean;
    set groundPlaneShadowVisibility(value: boolean);
    get groundPlaneVisibility(): boolean;
    set groundPlaneVisibility(value: boolean);
    get id(): string;
    get lightScene(): ILightSceneApi | null;
    get lightScenes(): {
        [key: string]: ILightSceneApi;
    };
    get lights(): boolean;
    set lights(value: boolean);
    get materialOverrideType(): MATERIAL_TYPE | undefined;
    set materialOverrideType(value: MATERIAL_TYPE | undefined);
    get maximumRenderingSize(): {
        width: number;
        height: number;
    };
    set maximumRenderingSize(value: {
        width: number;
        height: number;
    });
    get outputEncoding(): TEXTURE_ENCODING;
    set outputEncoding(value: TEXTURE_ENCODING);
    get physicallyCorrectLights(): boolean;
    set physicallyCorrectLights(value: boolean);
    get pointSize(): number;
    set pointSize(value: number);
    get postProcessing(): IPostProcessingApi;
    get postRenderingCallback(): ((renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera) => void) | undefined;
    set postRenderingCallback(value: ((renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.Camera) => void) | undefined);
    get preRenderingCallback(): ((renderer: THREE.WebGLRenderer) => void) | undefined;
    set preRenderingCallback(value: ((renderer: THREE.WebGLRenderer) => void) | undefined);
    get sessionSettingsId(): string | undefined;
    get sessionSettingsMode(): SESSION_SETTINGS_MODE;
    get shadows(): boolean;
    set shadows(value: boolean);
    get show(): boolean;
    set show(value: boolean);
    get showStatistics(): boolean;
    set showStatistics(value: boolean);
    get softShadows(): boolean;
    set softShadows(value: boolean);
    get textureEncoding(): TEXTURE_ENCODING;
    set textureEncoding(value: TEXTURE_ENCODING);
    get threeJsCoreObjects(): {
        scene: THREE.Scene;
        renderer: THREE.WebGLRenderer;
        camera: THREE.Camera;
    };
    get toneMapping(): TONE_MAPPING;
    set toneMapping(value: TONE_MAPPING);
    get toneMappingExposure(): number;
    set toneMappingExposure(value: number);
    get type(): RENDERER_TYPE;
    set type(value: RENDERER_TYPE);
    get visualizeAttributes(): ((overview: ISDTFOverview, itemData?: ISDTFItemData) => ISDTFAttributeVisualizationData) | undefined;
    set visualizeAttributes(value: ((overview: ISDTFOverview, itemData?: ISDTFItemData) => ISDTFAttributeVisualizationData) | undefined);
    addCanvasEventListener(listener: IDomEventListener): string;
    addFlag(flag: FLAG_TYPE): string;
    addRestrictedCanvasListenerToken(token: string): void;
    applyViewportSettings(settings: ISettings, sections?: {
        ar?: boolean | undefined;
        scene?: boolean | undefined;
        camera?: boolean | undefined;
        light?: boolean | undefined;
        environment?: boolean | undefined;
        general?: boolean | undefined;
        postprocessing?: boolean | undefined;
    }): Promise<void>;
    assignCamera(id: string): boolean;
    assignLightScene(id: string): boolean;
    close(): Promise<void>;
    continueRendering(): void;
    convert3Dto2D(p: vec3): {
        container: vec2;
        client: vec2;
        page: vec2;
        hidden: boolean;
    };
    convertToGlTF(node?: ITreeNode, convertForAr?: boolean): Promise<Blob>;
    createArSessionLink(node?: ITreeNode, qrCode?: boolean, fallbackUrl?: string): Promise<string>;
    createLightScene(properties?: {
        name?: string | undefined;
        standard?: boolean | undefined;
    }): ILightSceneApi;
    createOrthographicCamera(id?: string): IOrthographicCameraApi;
    createPerspectiveCamera(id?: string): IPerspectiveCameraApi;
    createSDTFOverview(node: ITreeNode): ISDTFOverview;
    displayErrorMessage(message: string): void;
    getEnvironmentMapImageUrl(): string;
    getScreenshot(type?: string, quality?: number): string;
    getViewportSettings(): ISettings;
    isMobileDeviceWithoutBrowserARSupport(): boolean;
    pauseRendering(): void;
    pointerEventToRay(event: PointerEvent): {
        origin: vec3;
        direction: vec3;
    };
    raytraceScene(origin: vec3, direction: vec3, filterCriteria?: IIntersectionFilter[]): {
        distance: number;
        node: ITreeNode;
        data?: IGeometryData;
    }[];
    removeCamera(id: string): boolean;
    removeCanvasEventListener(token: string): boolean;
    removeFlag(token: string): boolean;
    removeLightScene(id: string): boolean;
    removeRestrictedCanvasListenerToken(token: string): void;
    render(): void;
    resetToDefaultCameras(): void;
    resize(width: number, height: number): void;
    restrictEventListeners(allowedListeners: {
        mousewheel?: boolean;
        pointerdown?: boolean;
        pointermove?: boolean;
        pointerup?: boolean;
        pointerout?: boolean;
        keydown?: boolean;
        keyup?: boolean;
        contextmenu?: boolean;
    }): void;
    update(id?: string): void;
    updateDefaultLineMaterial(value: MaterialBasicLineData): void;
    updateDefaultMaterial(value: MaterialStandardData): void;
    updateDefaultPointMaterial(value: MaterialPointData): void;
    updateEnvironmentGeometry(): void;
    updateNode(node: ITreeNode): void;
    updateNodeTransformation(node: ITreeNode): void;
    viewInAR(node?: ITreeNode): Promise<void>;
    viewableInAR(): boolean;
}
//# sourceMappingURL=ViewportApi.d.ts.map
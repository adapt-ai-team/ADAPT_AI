"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createViewport = exports.viewports = void 0;
const viewer_api_general_1 = require("@shapediver/viewer.api.general");
const viewer_creation_control_center_viewport_1 = require("@shapediver/viewer.creation-control-center.viewport");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const ViewportApi_1 = require("./implementation/ViewportApi");
/**
 * The viewports that are currently being used.
 */
exports.viewports = {};
// Whenever a session or viewport is added or removed, this update is called.
const updateViewports = (renderingEngines) => {
    for (const v in renderingEngines)
        if (!exports.viewports[v])
            exports.viewports[v] = new ViewportApi_1.ViewportApi(renderingEngines[v]);
    for (const v in exports.viewports) {
        if (!renderingEngines[v])
            delete exports.viewports[v];
    }
};
/**
 * Create and initialize a viewport with the provided type and canvas,
 * and return a viewport api object allowing to control it.
 *
 * An optional identifier for the viewport can be provided. This identifier can be used to retrieve the
 * viewport object from {@link viewports}. In case no identifier is provided, a unique one will be generated.
 *
 * By default a new viewport displays the complete scene tree. Viewports can be excluded from
 * displaying geometry for specific sessions by using the {@link excludeViewports} property of
 * {@link ISessionApi}.
 *
 * @param properties.visibility The visibility of the viewport.
 * @param properties.canvas The canvas that the viewport should use. A canvas element will be created if none is provided.
 * @param properties.id The unique identifier to use for the viewport.
 * @param properties.branding Optional branding options.
 * @param properties.visibilitySessionIds Optional list of session ids to be displayed in the viewport when the {@link VISIBILITY_MODE} is set to {@link VISIBILITY_MODE.SESSIONS}.
 * @param properties.sessionSettingsId Optional identifier of the session to be used for loading / persisting settings of the viewport when the {@link SESSION_SETTINGS_MODE} is set to MANUAL.
 * @param properties.sessionSettingsMode Allows to control which session to use for loading / persisting settings of the viewport. (default: {@link SESSION_SETTINGS_MODE.FIRST}).
 * @param properties.flags Optional flags that should be initially set on the viewport. The key is the token that is used to identify the flag, and the value is the type of the flag.
 * @returns
 */
const createViewport = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    const creationControlCenterViewport = viewer_creation_control_center_viewport_1.CreationControlCenterViewport.instance;
    const inputValidator = viewer_shared_services_1.InputValidator.instance;
    const logger = viewer_shared_services_1.Logger.instance;
    if (creationControlCenterViewport.updateViewports === undefined)
        creationControlCenterViewport.updateViewports = updateViewports;
    (0, viewer_api_general_1.showConsoleMessage)();
    const prop = Object.assign({}, properties);
    const copy = Object.fromEntries(Object.entries(prop).filter(([key]) => key !== "canvas"));
    logger.debug(`createSession: Creating and initializing session with properties ${JSON.stringify(copy)}.`);
    inputValidator.validateAndError("createViewport", properties, "object", false);
    inputValidator.validateAndError("createViewport", prop.canvas, "HTMLCanvasElement", false);
    inputValidator.validateAndError("createViewport", prop.id, "string", false);
    inputValidator.validateAndError("createViewport", prop.sessionSettingsId, "string", false);
    inputValidator.validateAndError("createViewport", prop.sessionSettingsMode, "enum", false, Object.values(viewer_shared_services_1.SESSION_SETTINGS_MODE));
    inputValidator.validateAndError("createViewport", prop.visibilitySessionIds, "array", false);
    inputValidator.validateAndError("createViewport", prop.visibility, "enum", false, Object.values(viewer_shared_types_1.VISIBILITY_MODE));
    inputValidator.validateAndError("createViewport", prop.flags, "object", false);
    inputValidator.validateAndError("createViewport", prop.branding, "object", false);
    const branding = Object.assign({}, prop.branding);
    if (branding.logo !== null)
        inputValidator.validateAndError("createViewport", branding.logo, "string", false);
    inputValidator.validateAndError("createViewport", branding.backgroundColor, "string", false);
    inputValidator.validateAndError("createViewport", branding.busyModeSpinner, "string", false);
    inputValidator.validateAndError("createViewport", branding.busyModeDisplay, "enum", false, Object.values(viewer_shared_types_1.BUSY_MODE_DISPLAY));
    inputValidator.validateAndError("createViewport", branding.spinnerPositioning, "enum", false, Object.values(viewer_shared_types_1.SPINNER_POSITIONING));
    prop.sessionSettingsMode =
        prop.sessionSettingsMode !== undefined
            ? prop.sessionSettingsMode
            : viewer_shared_services_1.SESSION_SETTINGS_MODE.FIRST;
    if (prop.sessionSettingsMode === viewer_shared_services_1.SESSION_SETTINGS_MODE.MANUAL &&
        !prop.sessionSettingsId)
        throw new viewer_shared_services_1.ShapeDiverViewerValidationError("createViewport: Input could not be validated. sessionSettingsId has to point to a valid and created session when using SESSION_SETTINGS_MODE.MANUAL", prop.sessionSettingsId, "string");
    const renderingEngine = yield creationControlCenterViewport.createViewportEngine(prop);
    exports.viewports[renderingEngine.id] = new ViewportApi_1.ViewportApi(renderingEngine);
    return exports.viewports[renderingEngine.id];
});
exports.createViewport = createViewport;
//# sourceMappingURL=main.js.map
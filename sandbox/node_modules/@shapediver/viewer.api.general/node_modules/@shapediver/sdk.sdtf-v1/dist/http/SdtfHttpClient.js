"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfHttpClient = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const axios_1 = __importDefault(require("axios"));
const SdtfBinarySdtf_1 = require("../binary_sdtf/SdtfBinarySdtf");
class SdtfHttpClient {
    constructor(jsonContentUrl, authToken) {
        this.binarySdtfParser = new SdtfBinarySdtf_1.SdtfBinarySdtf();
        this.jsonContentUrl = jsonContentUrl;
        this.basicHttpHeader = {};
        if (authToken)
            this.basicHttpHeader.authorization = 'Bearer ' + authToken;
    }
    calcUrl(uri) {
        if (!uri)
            return this.jsonContentUrl;
        const index = this.jsonContentUrl.lastIndexOf('/');
        return `${this.jsonContentUrl.substring(0, index)}/${uri}`;
    }
    getJsonContent() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data, partial } = yield this.fetch(this.jsonContentUrl, 0, this.binarySdtfParser.binaryHeaderLength);
                if (partial) {
                    const [contentLength, _] = this.binarySdtfParser.readHeader(data);
                    const jsonContentBuffer = yield this.fetch(this.jsonContentUrl, 20, contentLength);
                    if (jsonContentBuffer.partial)
                        return [new DataView(jsonContentBuffer.data), undefined];
                }
                return this.binarySdtfParser.parseBinarySdtf(data);
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(`Could not fetch sdTF JSON content: ${e.message}`);
            }
        });
    }
    getBinaryBuffer(uri, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data, partial } = yield this.fetch(this.calcUrl(uri), offset, length);
                if (partial) {
                    return [new DataView(data), undefined];
                }
                else {
                    return [new DataView(data, offset, length), data];
                }
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(`Could not fetch sdTF binary buffer: ${e.message}`);
            }
        });
    }
    fetch(url, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let response;
            try {
                response = yield axios_1.default.head(url, { headers: this.basicHttpHeader });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            if (response.status > 299)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            const contentEncoding = !!((_a = response.headers['Content-Encoding']) !== null && _a !== void 0 ? _a : response.headers['content-encoding']);
            const acceptRanges = (_b = response.headers['Accept-Ranges']) !== null && _b !== void 0 ? _b : response.headers['accept-ranges'];
            const rangeRequestsSupported = !contentEncoding && acceptRanges === 'bytes';
            const data = rangeRequestsSupported
                ? yield this.fetchPartially(url, offset, length)
                : yield this.fetchFully(url);
            const buffer = data instanceof ArrayBuffer ? data : Uint8Array.from(data).buffer;
            return {
                data: buffer,
                partial: rangeRequestsSupported,
            };
        });
    }
    fetchPartially(url, offset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                response = yield axios_1.default.get(url, {
                    headers: Object.assign(Object.assign({}, this.basicHttpHeader), { range: `bytes=${offset}-${offset + length - 1}` }),
                    responseType: 'arraybuffer',
                });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            if (response.status === 416)
                throw new sdk_sdtf_core_1.SdtfError('Invalid range requested.');
            if (response.status !== 200 && response.status !== 206)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            const data = response.data;
            const buffer = data instanceof ArrayBuffer ? data : Uint8Array.from(data).buffer;
            return buffer.byteLength > length ? buffer.slice(offset, offset + length) : buffer;
        });
    }
    fetchFully(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                response = yield axios_1.default.get(url, {
                    headers: this.basicHttpHeader,
                    responseType: 'arraybuffer',
                });
            }
            catch (e) {
                throw new sdk_sdtf_core_1.SdtfError(e.message);
            }
            if (response.status !== 200)
                throw new sdk_sdtf_core_1.SdtfError(`Received HTTP status ${response.status}.`);
            return response.data;
        });
    }
}
exports.SdtfHttpClient = SdtfHttpClient;
//# sourceMappingURL=SdtfHttpClient.js.map
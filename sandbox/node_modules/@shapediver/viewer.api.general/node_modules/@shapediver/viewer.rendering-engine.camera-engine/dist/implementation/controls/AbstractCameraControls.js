"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCameraControls = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const CameraInterpolationManager_1 = require("../interpolation/CameraInterpolationManager");
class AbstractCameraControls {
    // #endregion Properties (38)
    // #region Constructors (1)
    constructor(_camera, _enabled) {
        this._camera = _camera;
        this._enabled = _enabled;
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._autoRotationSpeed = 0;
        this._cubePositionRestriction = {
            min: gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity),
            max: gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity),
        };
        this._cubeTargetRestriction = {
            min: gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity),
            max: gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity),
        };
        this._damping = 0.1;
        this._enableAutoRotation = false;
        this._enableAzimuthRotation = true;
        this._enableKeyPan = false;
        this._enableObjectControls = false;
        this._enablePan = true;
        this._enablePolarRotation = true;
        this._enableRotation = true;
        this._enableTurntableControls = false;
        this._enableZoom = true;
        this._input = {
            keys: { up: 38, down: 40, left: 37, right: 39 },
            mouse: { rotate: 0, zoom: 1, pan: 2 },
            touch: { rotate: 1, zoom: 2, pan: 2 },
        };
        this._keyPanSpeed = 0.5;
        this._manualInteraction = false;
        this._movementSmoothness = 0.5;
        this._moving = false;
        this._movingDuration = 0;
        this._nonmanualInteraction = false;
        this._objectControlsCenter = gl_matrix_1.vec3.create();
        this._panSpeed = 0.5;
        this._position = gl_matrix_1.vec3.create();
        this._rotationRestriction = {
            minPolarAngle: 0,
            maxPolarAngle: 180,
            minAzimuthAngle: -Infinity,
            maxAzimuthAngle: Infinity,
        };
        this._rotationSpeed = 0.5;
        this._sceneRotation = gl_matrix_1.vec2.create();
        this._spherePositionRestriction = {
            center: gl_matrix_1.vec3.create(),
            radius: Infinity,
        };
        this._sphereTargetRestriction = {
            center: gl_matrix_1.vec3.create(),
            radius: Infinity,
        };
        this._target = gl_matrix_1.vec3.create();
        this._turntableCenter = gl_matrix_1.vec3.create();
        this._zoomRestriction = {
            minDistance: 0,
            maxDistance: Infinity,
        };
        this._zoomSpeed = 0.5;
        this._cameraInterpolationManager = new CameraInterpolationManager_1.CameraInterpolationManager(this._camera, this);
        this._manualInteractionTransformations = {
            position: [],
            target: [],
            sceneRotation: [],
        };
        this._nonmanualInteractionTransformations = {
            position: [],
            target: [],
            sceneRotation: [],
        };
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (59)
    get autoRotationSpeed() {
        return this._autoRotationSpeed;
    }
    set autoRotationSpeed(value) {
        this._autoRotationSpeed = value;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    get cameraControlsEventDistribution() {
        return this._cameraControlsEventDistribution;
    }
    get canvas() {
        return this._canvas;
    }
    set canvas(value) {
        this._canvas = value;
    }
    get cubePositionRestriction() {
        return this._cubePositionRestriction;
    }
    set cubePositionRestriction(value) {
        this._cubePositionRestriction = value;
    }
    get cubeTargetRestriction() {
        return this._cubeTargetRestriction;
    }
    set cubeTargetRestriction(value) {
        this._cubeTargetRestriction = value;
    }
    get damping() {
        return this._damping;
    }
    set damping(value) {
        this._damping = value;
    }
    get enableAutoRotation() {
        return this._enableAutoRotation;
    }
    set enableAutoRotation(value) {
        this._enableAutoRotation = value;
    }
    get enableAzimuthRotation() {
        return this._enableAzimuthRotation;
    }
    set enableAzimuthRotation(value) {
        this._enableAzimuthRotation = value;
    }
    get enableKeyPan() {
        return this._enableKeyPan;
    }
    set enableKeyPan(value) {
        this._enableKeyPan = value;
    }
    get enableObjectControls() {
        return this._enableObjectControls;
    }
    set enableObjectControls(value) {
        this._enableObjectControls = value;
    }
    get enablePan() {
        return this._enablePan;
    }
    set enablePan(value) {
        this._enablePan = value;
    }
    get enablePolarRotation() {
        return this._enablePolarRotation;
    }
    set enablePolarRotation(value) {
        this._enablePolarRotation = value;
    }
    get enableRotation() {
        return this._enableRotation;
    }
    set enableRotation(value) {
        this._enableRotation = value;
    }
    get enableTurntableControls() {
        return this._enableTurntableControls;
    }
    set enableTurntableControls(value) {
        this._enableTurntableControls = value;
    }
    get enableZoom() {
        return this._enableZoom;
    }
    set enableZoom(value) {
        this._enableZoom = value;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (!value) {
            this._manualInteraction = false;
            this._manualInteractionTransformations = {
                position: [],
                target: [],
                sceneRotation: [],
            };
            this._nonmanualInteraction = false;
            this._nonmanualInteractionTransformations = {
                position: [],
                target: [],
                sceneRotation: [],
            };
            this._cameraControlsEventDistribution.reset();
            this._cameraLogic.reset();
        }
        this._enabled = value;
    }
    get input() {
        return this._input;
    }
    set input(value) {
        this._input = value;
    }
    get keyPanSpeed() {
        return this._keyPanSpeed;
    }
    set keyPanSpeed(value) {
        this._keyPanSpeed = value;
    }
    get movementSmoothness() {
        return this._movementSmoothness;
    }
    set movementSmoothness(value) {
        this._movementSmoothness = value;
    }
    get objectControlsCenter() {
        return this._objectControlsCenter;
    }
    set objectControlsCenter(value) {
        this._objectControlsCenter = value;
    }
    get panSpeed() {
        return this._panSpeed;
    }
    set panSpeed(value) {
        this._panSpeed = value;
    }
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value;
    }
    get rotationRestriction() {
        return this._rotationRestriction;
    }
    set rotationRestriction(value) {
        this._rotationRestriction = value;
    }
    get rotationSpeed() {
        return this._rotationSpeed;
    }
    set rotationSpeed(value) {
        this._rotationSpeed = value;
    }
    get sceneRotation() {
        return this._sceneRotation;
    }
    set sceneRotation(value) {
        this._sceneRotation = value;
    }
    get spherePositionRestriction() {
        return this._spherePositionRestriction;
    }
    set spherePositionRestriction(value) {
        this._spherePositionRestriction = value;
    }
    get sphereTargetRestriction() {
        return this._sphereTargetRestriction;
    }
    set sphereTargetRestriction(value) {
        this._sphereTargetRestriction = value;
    }
    get target() {
        return this._target;
    }
    set target(value) {
        this._target = value;
    }
    get turntableCenter() {
        return this._turntableCenter;
    }
    set turntableCenter(value) {
        this._turntableCenter = value;
    }
    get zoomRestriction() {
        return this._zoomRestriction;
    }
    set zoomRestriction(value) {
        this._zoomRestriction = value;
    }
    get zoomSpeed() {
        return this._zoomSpeed;
    }
    set zoomSpeed(value) {
        this._zoomSpeed = value;
    }
    // #endregion Public Getters And Setters (59)
    // #region Public Methods (16)
    animate(path, options) {
        if (options && options.duration === 0) {
            this._position = path[path.length - 1].position;
            this._target = path[path.length - 1].target;
            return new Promise((resolve) => resolve(true));
        }
        this._manualInteraction = false;
        this._manualInteractionTransformations = {
            position: [],
            target: [],
            sceneRotation: [],
        };
        return this._cameraInterpolationManager.interpolate(path, options);
    }
    applyPositionMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ matrix });
        }
    }
    applyPositionVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ vector });
        }
    }
    applyRotation(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.sceneRotation.push({
                theta: vector[0],
                phi: vector[1],
            });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.sceneRotation.push({
                theta: vector[0],
                phi: vector[1],
            });
        }
    }
    applySettings(settingsEngine) {
        const cameraSetting = settingsEngine.camera.cameras[this.camera.id];
        if (!cameraSetting)
            return;
        this.reset();
        const controlsSettings = (cameraSetting.controls);
        this.autoRotationSpeed = controlsSettings.autoRotationSpeed;
        this.damping = controlsSettings.damping;
        this.enableAutoRotation = controlsSettings.enableAutoRotation;
        this.enableKeyPan = controlsSettings.enableKeyPan;
        this.enablePan = controlsSettings.enablePan;
        this.enableRotation = controlsSettings.enableRotation;
        this.enableZoom = controlsSettings.enableZoom;
        // this.input = controlsSettings.input;
        this.keyPanSpeed = controlsSettings.keyPanSpeed;
        this.movementSmoothness = controlsSettings.movementSmoothness;
        this.rotationSpeed = controlsSettings.rotationSpeed;
        this.panSpeed = controlsSettings.panSpeed;
        this.zoomSpeed = controlsSettings.zoomSpeed;
        this.enableAzimuthRotation = controlsSettings.enableAzimuthRotation;
        this.enablePolarRotation = controlsSettings.enablePolarRotation;
        this.enableTurntableControls = controlsSettings.enableTurntableControls;
        this.enableObjectControls = controlsSettings.enableObjectControls;
        this.turntableCenter = this._converter.toVec3(controlsSettings.turntableCenter);
        this.objectControlsCenter = this._converter.toVec3(controlsSettings.objectControlsCenter);
        if (controlsSettings.restrictions.position.cube.min.x === null)
            controlsSettings.restrictions.position.cube.min.x = -Infinity;
        if (controlsSettings.restrictions.position.cube.min.y === null)
            controlsSettings.restrictions.position.cube.min.y = -Infinity;
        if (controlsSettings.restrictions.position.cube.min.z === null)
            controlsSettings.restrictions.position.cube.min.z = -Infinity;
        if (controlsSettings.restrictions.position.cube.max.x === null)
            controlsSettings.restrictions.position.cube.max.x = Infinity;
        if (controlsSettings.restrictions.position.cube.max.y === null)
            controlsSettings.restrictions.position.cube.max.y = Infinity;
        if (controlsSettings.restrictions.position.cube.max.z === null)
            controlsSettings.restrictions.position.cube.max.z = Infinity;
        if (controlsSettings.restrictions.position.sphere.radius === null)
            controlsSettings.restrictions.position.sphere.radius = Infinity;
        if (controlsSettings.restrictions.target.cube.min.x === null)
            controlsSettings.restrictions.target.cube.min.x = -Infinity;
        if (controlsSettings.restrictions.target.cube.min.y === null)
            controlsSettings.restrictions.target.cube.min.y = -Infinity;
        if (controlsSettings.restrictions.target.cube.min.z === null)
            controlsSettings.restrictions.target.cube.min.z = -Infinity;
        if (controlsSettings.restrictions.target.cube.max.x === null)
            controlsSettings.restrictions.target.cube.max.x = Infinity;
        if (controlsSettings.restrictions.target.cube.max.y === null)
            controlsSettings.restrictions.target.cube.max.y = Infinity;
        if (controlsSettings.restrictions.target.cube.max.z === null)
            controlsSettings.restrictions.target.cube.max.z = Infinity;
        if (controlsSettings.restrictions.target.sphere.radius === null)
            controlsSettings.restrictions.target.sphere.radius = Infinity;
        if (controlsSettings.restrictions.rotation.minAzimuthAngle === null)
            controlsSettings.restrictions.rotation.minAzimuthAngle = -Infinity;
        if (controlsSettings.restrictions.rotation.maxAzimuthAngle === null)
            controlsSettings.restrictions.rotation.maxAzimuthAngle = Infinity;
        if (controlsSettings.restrictions.zoom.maxDistance === null)
            controlsSettings.restrictions.zoom.maxDistance = Infinity;
        this.cubePositionRestriction = {
            min: this._converter.toVec3(controlsSettings.restrictions.position.cube.min),
            max: this._converter.toVec3(controlsSettings.restrictions.position.cube.max),
        };
        this.spherePositionRestriction = {
            center: this._converter.toVec3(controlsSettings.restrictions.position.sphere.center),
            radius: controlsSettings.restrictions.position.sphere.radius,
        };
        this.cubeTargetRestriction = {
            min: this._converter.toVec3(controlsSettings.restrictions.target.cube.min),
            max: this._converter.toVec3(controlsSettings.restrictions.target.cube.max),
        };
        this.sphereTargetRestriction = {
            center: this._converter.toVec3(controlsSettings.restrictions.target.sphere.center),
            radius: controlsSettings.restrictions.target.sphere.radius,
        };
        this.rotationRestriction = controlsSettings.restrictions.rotation;
        this.zoomRestriction = controlsSettings.restrictions.zoom;
    }
    applyTargetMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ matrix });
        }
    }
    applyTargetVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ vector });
        }
    }
    applyUpMatrix(matrix, manualInteraction) {
        // https://shapediver.atlassian.net/browse/SS-2949
        throw new Error("Method not implemented.");
    }
    assignViewer(viewportId, canvas) {
        this._canvas = canvas;
        this._viewportId = viewportId;
    }
    getPositionWithManualUpdates() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i]
                        .matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i]
                        .vector);
                }
            }
        }
        return position;
    }
    getPositionWithUpdates() {
        return this.getPosition();
    }
    getTargetWithManualUpdates() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i]
                        .matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i]
                        .vector);
                }
            }
        }
        return target;
    }
    getTargetWithUpdates() {
        return this.getTarget();
    }
    isMoving() {
        return this._manualInteraction || this._nonmanualInteraction;
    }
    isWithinRestrictions(position, target) {
        return this._cameraLogic.isWithinRestrictions(position, target);
    }
    reset() {
        this._cameraControlsEventDistribution.reset();
        this._cameraLogic.reset();
    }
    update(time) {
        if (!this._enabled)
            return {
                position: gl_matrix_1.vec3.clone(this._position),
                target: gl_matrix_1.vec3.clone(this._target),
                sceneRotation: gl_matrix_1.vec2.clone(this._sceneRotation),
            };
        // reset all values
        if (this._manualInteraction === true &&
            this._cameraInterpolationManager.active())
            this._cameraInterpolationManager.stop();
        const { position, target, sceneRotation } = this._cameraLogic.restrict(this.getPosition(), this.getTarget(), this.getSceneRotation());
        this._position = gl_matrix_1.vec3.clone(position);
        this._target = gl_matrix_1.vec3.clone(target);
        this._sceneRotation = sceneRotation
            ? gl_matrix_1.vec2.clone(sceneRotation)
            : gl_matrix_1.vec2.create();
        this._manualInteraction = false;
        this._manualInteractionTransformations = {
            position: [],
            target: [],
            sceneRotation: [],
        };
        this._nonmanualInteraction = this._cameraInterpolationManager.active();
        this._nonmanualInteractionTransformations = {
            position: [],
            target: [],
            sceneRotation: [],
        };
        this._cameraLogic.update(time, this._nonmanualInteraction);
        const oldMovement = this._moving;
        const cameraDefinition = {
            position: gl_matrix_1.vec3.clone(this._position),
            target: gl_matrix_1.vec3.clone(this._target),
            sceneRotation: gl_matrix_1.vec2.clone(this._sceneRotation),
        };
        this._movingDuration += time;
        this._moving = this._manualInteraction || this._nonmanualInteraction;
        switch (true) {
            case oldMovement !== this._moving && this._moving === true:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, {
                    viewportId: this._viewportId,
                    cameraId: this.camera.id,
                });
                break;
            case oldMovement !== this._moving && this._moving === false:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, {
                    viewportId: this._viewportId,
                    cameraId: this.camera.id,
                });
                break;
            default:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_MOVE, {
                    viewportId: this._viewportId,
                    cameraId: this.camera.id,
                });
        }
        if (!this._moving)
            this._movingDuration = 0;
        return cameraDefinition;
    }
    // #endregion Public Methods (16)
    // #region Private Methods (3)
    getPosition() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i]
                        .matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i]
                        .vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.position.length -
                1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._nonmanualInteractionTransformations.position[i]
                        .matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._nonmanualInteractionTransformations.position[i]
                        .vector);
                }
            }
        }
        return position;
    }
    getSceneRotation() {
        let sceneRotation = gl_matrix_1.vec2.clone(this._sceneRotation);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.sceneRotation
                .length - 1; i >= 0; i--) {
                sceneRotation = gl_matrix_1.vec2.add(sceneRotation, sceneRotation, gl_matrix_1.vec2.fromValues(this._manualInteractionTransformations.sceneRotation[i]
                    .theta, this._manualInteractionTransformations.sceneRotation[i]
                    .phi));
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.sceneRotation
                .length - 1; i >= 0; i--) {
                sceneRotation = gl_matrix_1.vec2.add(sceneRotation, sceneRotation, gl_matrix_1.vec2.fromValues(this._nonmanualInteractionTransformations.sceneRotation[i].theta, this._nonmanualInteractionTransformations.sceneRotation[i].phi));
            }
        }
        return sceneRotation;
    }
    getTarget() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i]
                        .matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i]
                        .vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._nonmanualInteractionTransformations.target[i]
                        .matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._nonmanualInteractionTransformations.target[i]
                        .vector);
                }
            }
        }
        return target;
    }
}
exports.AbstractCameraControls = AbstractCameraControls;
//# sourceMappingURL=AbstractCameraControls.js.map
import { IRenderingEngine } from "@shapediver/viewer.rendering-engine.rendering-engine";
import { Box, IBox, Sphere } from "@shapediver/viewer.shared.math";
import { AbstractTreeNodeData, ITreeNode } from "@shapediver/viewer.shared.node-tree";
import { EventEngine, SettingsEngine, StateEngine } from "@shapediver/viewer.shared.services";
import { mat4, vec2, vec3, vec4 } from "gl-matrix";
import { ICamera, ICameraOptions } from "../../interfaces/camera/ICamera";
import { ICameraControls } from "../../interfaces/controls/ICameraControls";
import { CAMERA_TYPE } from "../../interfaces/ICameraEngine";
export declare abstract class AbstractCamera extends AbstractTreeNodeData implements ICamera {
    #private;
    private readonly _id;
    private readonly _type;
    private readonly _isDefault;
    protected readonly _eventEngine: EventEngine;
    protected readonly _stateEngine: StateEngine;
    protected _boundingBox: IBox;
    protected abstract _controls: ICameraControls;
    protected _position: vec3;
    protected _target: vec3;
    protected _viewportId?: string;
    constructor(_id: string, _type: CAMERA_TYPE, version?: string, _isDefault?: boolean);
    get active(): boolean;
    set active(value: boolean);
    get autoAdjust(): boolean;
    set autoAdjust(value: boolean);
    set boundingBox(value: IBox);
    get cameraMovementDuration(): number;
    set cameraMovementDuration(value: number);
    get controls(): ICameraControls;
    get defaultPosition(): vec3;
    set defaultPosition(value: vec3);
    get defaultTarget(): vec3;
    set defaultTarget(value: vec3);
    get domEventListenerToken(): string | undefined;
    set domEventListenerToken(value: string | undefined);
    get enableCameraControls(): boolean;
    set enableCameraControls(value: boolean);
    get far(): number;
    set far(value: number);
    get id(): string;
    get isDefault(): boolean;
    get name(): string | undefined;
    set name(value: string | undefined);
    get near(): number;
    set near(value: number);
    get node(): ITreeNode | undefined;
    set node(value: ITreeNode | undefined);
    get order(): number | undefined;
    set order(value: number | undefined);
    get position(): vec3;
    set position(value: vec3);
    get revertAtMouseUp(): boolean;
    set revertAtMouseUp(value: boolean);
    get revertAtMouseUpDuration(): number;
    set revertAtMouseUpDuration(value: number);
    get sceneRotation(): vec2;
    set sceneRotation(value: vec2);
    get target(): vec3;
    set target(value: vec3);
    get type(): CAMERA_TYPE;
    get useNodeData(): boolean;
    set useNodeData(value: boolean);
    get viewportId(): string | undefined;
    get zoomExtentsFactor(): number;
    set zoomExtentsFactor(value: number);
    protected abstract getProjectionMatrix(sphere: Sphere): mat4 | undefined;
    animate(path: {
        position: vec3;
        target: vec3;
    }[], options?: ICameraOptions): Promise<boolean>;
    boundingSphereVisible(sphere: Sphere): boolean;
    destroy(): void;
    reset(options?: ICameraOptions): Promise<boolean>;
    set(position: vec3, target: vec3, options?: ICameraOptions): Promise<boolean>;
    update(time: number): boolean;
    zoomTo(zoomTarget?: Box, options?: ICameraOptions): Promise<boolean>;
    abstract applySettings(settingsEngine?: SettingsEngine): void;
    abstract assignViewer(renderingEngine: IRenderingEngine): void;
    abstract calculateZoomTo(zoomTarget?: Box, startingPosition?: vec3, startingTarget?: vec3): {
        position: vec3;
        target: vec3;
    };
    abstract project(p: vec3): vec2;
    abstract unproject(p: vec3): vec3;
    protected assignViewerInternal(viewportId: string): void;
    protected getFrustumPlanes(projectionMatrix: mat4): vec4[];
}
//# sourceMappingURL=AbstractCamera.d.ts.map
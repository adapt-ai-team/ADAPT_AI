"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialEngine = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const materialDatabase_1 = require("./materialDatabase");
/* eslint-disable no-prototype-builtins */
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
class MaterialEngine {
    constructor() {
        // #region Properties (4)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        // #endregion Private Methods (4)
    }
    // #endregion Properties (4)
    // #region Public Static Getters And Setters (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Getters And Setters (1)
    // #region Public Methods (12)
    /**
     * Create a material data based on the material properties
     *
     * @param materialProperties
     * @returns
     */
    createMaterialData(materialProperties) {
        const materialType = materialProperties.type || viewer_shared_types_1.MATERIAL_TYPE.STANDARD;
        switch (materialType) {
            case viewer_shared_types_1.MATERIAL_TYPE.SPECULAR_GLOSSINESS:
                return new viewer_shared_types_1.MaterialSpecularGlossinessData(materialProperties);
            case viewer_shared_types_1.MATERIAL_TYPE.UNLIT:
                return new viewer_shared_types_1.MaterialUnlitData(materialProperties);
            case viewer_shared_types_1.MATERIAL_TYPE.GEM:
                return new viewer_shared_types_1.MaterialGemData(materialProperties);
            case viewer_shared_types_1.MATERIAL_TYPE.PHONG:
                return new viewer_shared_types_1.MaterialPhongData(materialProperties);
            case viewer_shared_types_1.MATERIAL_TYPE.LAMBERT:
                return new viewer_shared_types_1.MaterialLambertData(materialProperties);
            default:
                return new viewer_shared_types_1.MaterialStandardData(materialProperties);
        }
    }
    createMaterialDataFromDefinition(definition) {
        return __awaiter(this, void 0, void 0, function* () {
            const materialType = definition.type || viewer_shared_types_1.MATERIAL_TYPE.STANDARD;
            const promises = [];
            const abstractProperties = {};
            abstractProperties.alphaCutoff = definition.alphaCutoff;
            promises.push(this.loadMapFromDefinition(definition.alphaMap).then((map) => {
                if (map)
                    abstractProperties.alphaMap = map;
                return map;
            }));
            abstractProperties.alphaMode = definition.alphaMode;
            promises.push(this.loadMapFromDefinition(definition.aoMap).then((map) => {
                if (map)
                    abstractProperties.aoMap = map;
                return map;
            }));
            abstractProperties.aoMapIntensity = definition.aoMapIntensity;
            promises.push(this.loadMapFromDefinition(definition.bumpMap).then((map) => {
                if (map)
                    abstractProperties.bumpMap = map;
                return map;
            }));
            abstractProperties.bumpScale = definition.bumpScale;
            abstractProperties.color = definition.color
                ? definition.color
                : undefined;
            abstractProperties.depthTest = definition.depthTest;
            abstractProperties.depthWrite = definition.depthWrite;
            promises.push(this.loadMapFromDefinition(definition.emissiveMap).then((map) => {
                if (map)
                    abstractProperties.emissiveMap = map;
                return map;
            }));
            abstractProperties.emissiveness = definition.emissiveness
                ? definition.emissiveness
                : undefined;
            promises.push(this.loadMapFromDefinition(definition.map).then((map) => {
                if (map)
                    abstractProperties.map = map;
                return map;
            }));
            abstractProperties.name = definition.name;
            promises.push(this.loadMapFromDefinition(definition.normalMap).then((map) => {
                if (map)
                    abstractProperties.normalMap = map;
                return map;
            }));
            abstractProperties.normalScale = definition.normalScale;
            abstractProperties.opacity = definition.opacity;
            abstractProperties.shading = definition.shading;
            abstractProperties.side = definition.side;
            abstractProperties.transparent = definition.transparent;
            abstractProperties.type = materialType;
            switch (materialType) {
                case viewer_shared_types_1.MATERIAL_TYPE.SPECULAR_GLOSSINESS: {
                    const specularGlossinessProperties = abstractProperties;
                    const specularGlossinessDefinition = definition;
                    specularGlossinessProperties.envMap =
                        specularGlossinessDefinition.envMap;
                    specularGlossinessProperties.glossiness =
                        specularGlossinessDefinition.glossiness;
                    specularGlossinessProperties.specular =
                        specularGlossinessDefinition.specular;
                    if (specularGlossinessDefinition.specularGlossinessMap) {
                        promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.specularGlossinessMap).then((map) => {
                            if (map)
                                specularGlossinessProperties.specularGlossinessMap =
                                    map;
                            return map;
                        }));
                    }
                    else {
                        promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.specularMap).then((map) => {
                            if (map)
                                specularGlossinessProperties.specularMap = map;
                            return map;
                        }));
                        promises.push(this.loadMapFromDefinition(specularGlossinessDefinition.glossinessMap).then((map) => {
                            if (map)
                                specularGlossinessProperties.glossinessMap =
                                    map;
                            return map;
                        }));
                    }
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialSpecularGlossinessData(specularGlossinessProperties);
                }
                case viewer_shared_types_1.MATERIAL_TYPE.UNLIT: {
                    const unlitProperties = abstractProperties;
                    const unlitDefinition = definition;
                    unlitProperties.envMap = unlitDefinition.envMap;
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialUnlitData(unlitProperties);
                }
                case viewer_shared_types_1.MATERIAL_TYPE.PHONG: {
                    const phongProperties = abstractProperties;
                    const phongDefinition = definition;
                    phongProperties.displacementBias =
                        phongDefinition.displacementBias;
                    promises.push(this.loadMapFromDefinition(phongDefinition.displacementMap).then((map) => {
                        if (map)
                            phongProperties.displacementMap = map;
                        return map;
                    }));
                    phongProperties.displacementScale =
                        phongDefinition.displacementScale;
                    phongProperties.envMap = phongDefinition.envMap;
                    phongProperties.reflectivity = phongDefinition.reflectivity;
                    phongProperties.shininess = phongDefinition.shininess;
                    phongProperties.specular = phongDefinition.specular;
                    promises.push(this.loadMapFromDefinition(phongDefinition.specularMap).then((map) => {
                        if (map)
                            phongProperties.specularMap = map;
                        return map;
                    }));
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialPhongData(phongProperties);
                }
                case viewer_shared_types_1.MATERIAL_TYPE.LAMBERT: {
                    const lambertProperties = abstractProperties;
                    const lambertDefinition = definition;
                    lambertProperties.displacementBias =
                        lambertDefinition.displacementBias;
                    promises.push(this.loadMapFromDefinition(lambertDefinition.displacementMap).then((map) => {
                        if (map)
                            lambertProperties.displacementMap = map;
                        return map;
                    }));
                    lambertProperties.displacementScale =
                        lambertDefinition.displacementScale;
                    lambertProperties.envMap = lambertDefinition.envMap;
                    lambertProperties.reflectivity = lambertDefinition.reflectivity;
                    promises.push(this.loadMapFromDefinition(lambertDefinition.specularMap).then((map) => {
                        if (map)
                            lambertProperties.specularMap = map;
                        return map;
                    }));
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialLambertData(lambertProperties);
                }
                case viewer_shared_types_1.MATERIAL_TYPE.GEM: {
                    const gemProperties = abstractProperties;
                    const gemDefinition = definition;
                    gemProperties.brightness = gemDefinition.brightness;
                    gemProperties.center = gemDefinition.center;
                    gemProperties.colorTransferBegin =
                        gemDefinition.colorTransferBegin;
                    gemProperties.colorTransferEnd = gemDefinition.colorTransferEnd;
                    gemProperties.contrast = gemDefinition.contrast;
                    gemProperties.dispersion = gemDefinition.dispersion;
                    gemProperties.envMap = gemDefinition.envMap;
                    gemProperties.gamma = gemDefinition.gamma;
                    promises.push(this.loadMapFromDefinition(gemDefinition.impurityMap).then((map) => {
                        if (map)
                            gemProperties.impurityMap = map;
                        return map;
                    }));
                    gemProperties.impurityScale = gemDefinition.impurityScale;
                    gemProperties.radius = gemDefinition.radius;
                    gemProperties.refractionIndex = gemDefinition.refractionIndex;
                    promises.push(this.loadMapFromDefinition(gemDefinition.sphericalNormalMap).then((map) => {
                        if (map)
                            gemProperties.sphericalNormalMap = map;
                        return map;
                    }));
                    gemProperties.tracingDepth = gemDefinition.tracingDepth;
                    gemProperties.tracingOpacity = gemDefinition.tracingOpacity;
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialGemData(gemProperties);
                }
                default: {
                    const standardProperties = abstractProperties;
                    const standardDefinition = definition;
                    standardProperties.attenuationColor =
                        standardDefinition.attenuationColor;
                    standardProperties.attenuationDistance =
                        standardDefinition.attenuationDistance;
                    standardProperties.clearcoat = standardDefinition.clearcoat;
                    promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatMap).then((map) => {
                        if (map)
                            standardProperties.clearcoatMap = map;
                        return map;
                    }));
                    promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatNormalMap).then((map) => {
                        if (map)
                            standardProperties.clearcoatNormalMap = map;
                        return map;
                    }));
                    standardProperties.clearcoatRoughness =
                        standardDefinition.clearcoatRoughness;
                    promises.push(this.loadMapFromDefinition(standardDefinition.clearcoatRoughnessMap).then((map) => {
                        if (map)
                            standardProperties.clearcoatRoughnessMap = map;
                        return map;
                    }));
                    standardProperties.displacementBias =
                        standardDefinition.displacementBias;
                    promises.push(this.loadMapFromDefinition(standardDefinition.displacementMap).then((map) => {
                        if (map)
                            standardProperties.displacementMap = map;
                        return map;
                    }));
                    standardProperties.displacementScale =
                        standardDefinition.displacementScale;
                    standardProperties.envMap = standardDefinition.envMap;
                    standardProperties.ior = standardDefinition.ior;
                    standardProperties.metalness = standardDefinition.metalness;
                    if (standardDefinition.metalnessRoughnessMap) {
                        promises.push(this.loadMapFromDefinition(standardDefinition.metalnessMap).then((map) => {
                            if (map)
                                standardProperties.metalnessMap = map;
                            return map;
                        }));
                    }
                    else {
                        promises.push(this.loadMapFromDefinition(standardDefinition.metalnessMap).then((map) => {
                            if (map)
                                standardProperties.metalnessMap = map;
                            return map;
                        }));
                        promises.push(this.loadMapFromDefinition(standardDefinition.roughnessMap).then((map) => {
                            if (map)
                                standardProperties.roughnessMap = map;
                            return map;
                        }));
                    }
                    standardProperties.roughness = standardDefinition.roughness;
                    standardProperties.sheen = standardDefinition.sheen;
                    standardProperties.sheenColor = standardDefinition.sheenColor;
                    promises.push(this.loadMapFromDefinition(standardDefinition.sheenColorMap).then((map) => {
                        if (map)
                            standardProperties.sheenColorMap = map;
                        return map;
                    }));
                    standardProperties.sheenRoughness =
                        standardDefinition.sheenRoughness;
                    promises.push(this.loadMapFromDefinition(standardDefinition.sheenRoughnessMap).then((map) => {
                        if (map)
                            standardProperties.sheenRoughnessMap = map;
                        return map;
                    }));
                    standardProperties.specularColor =
                        standardDefinition.specularColor;
                    promises.push(this.loadMapFromDefinition(standardDefinition.specularColorMap).then((map) => {
                        if (map)
                            standardProperties.specularColorMap = map;
                        return map;
                    }));
                    standardProperties.specularIntensity =
                        standardDefinition.specularIntensity;
                    promises.push(this.loadMapFromDefinition(standardDefinition.specularIntensityMap).then((map) => {
                        if (map)
                            standardProperties.specularIntensityMap = map;
                        return map;
                    }));
                    standardProperties.thickness = standardDefinition.thickness;
                    promises.push(this.loadMapFromDefinition(standardDefinition.thicknessMap).then((map) => {
                        if (map)
                            standardProperties.thicknessMap = map;
                        return map;
                    }));
                    standardProperties.transmission =
                        standardDefinition.transmission;
                    promises.push(this.loadMapFromDefinition(standardDefinition.transmissionMap).then((map) => {
                        if (map)
                            standardProperties.transmissionMap = map;
                        return map;
                    }));
                    yield Promise.all(promises);
                    return new viewer_shared_types_1.MaterialStandardData(standardProperties);
                }
            }
        });
    }
    /**
     * Load the material content into a scene graph node.
     *
     * @param content the material content
     * @returns the scene graph node
     */
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = new viewer_shared_node_tree_1.TreeNode(content.name || "material");
            if (!content)
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("MaterialEngine.loadContent: Invalid content was provided to material engine.");
            let material = new viewer_shared_types_1.MaterialStandardData();
            if (content.data) {
                const data = content.data;
                let presetData;
                if (data.materialpreset)
                    presetData = this.loadPresetMaterialDefinition(data.materialpreset);
                if (data.materialType && data.materialType !== "standard") {
                    // gem material https://shapediver.atlassian.net/browse/SS-2514
                }
                else {
                    if (data.version) {
                        if (data.version === "1.0") {
                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV1(data, presetData));
                        }
                        else if (data.version === "2.0") {
                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV2(data, presetData));
                        }
                        else if (data.version === "3.0") {
                            material = yield this.loadMaterialV3(this.loadMaterialDefinitionV3(data, presetData));
                        }
                        else {
                            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("MaterialEngine.loadContent: Material data version not supported.");
                        }
                    }
                }
            }
            else {
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError("MaterialEngine.loadContent: No material data was provided to material engine.");
            }
            node.data.push(material);
            return node;
        });
    }
    loadMap(url, id) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            if (!id) {
                response = yield this._httpClient.loadTexture(url);
            }
            else {
                response = yield this._httpClient.loadTexture("https://viewer.shapediver.com/v2/materials/1024/" +
                    id +
                    "/" +
                    url);
            }
            if (!response)
                return;
            if (response.data.image) {
                return new viewer_shared_types_1.MapData(response.data.image, { blob: response.data.blob });
            }
            else {
                return new viewer_shared_types_1.MapData(response.data.buffer, {
                    blob: response.data.blob,
                });
            }
        });
    }
    /**
     * Load a map from a definition.
     *
     * @param definition
     * @returns
     */
    loadMapFromDefinition(definition) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!definition)
                return undefined;
            if (typeof definition === "string") {
                return this.loadMap(definition);
            }
            else if (definition.image) {
                if (typeof definition.image === "string") {
                    return this.loadMapWithProperties({
                        href: definition.image,
                        wrapS: definition.wrapS,
                        wrapT: definition.wrapT,
                        center: definition.center,
                        color: definition.color
                            ? this._converter.toColorArray(definition.color)
                            : undefined,
                        offset: definition.offset,
                        repeat: definition.repeat,
                        rotation: definition.rotation,
                    });
                }
                else {
                    return new viewer_shared_types_1.MapData(definition.image);
                }
            }
            return;
        });
    }
    loadMapWithProperties(texture) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._httpClient.loadTexture(texture.href);
            if (!response)
                return;
            const wrapS = texture.wrapS === 1
                ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE
                : texture.wrapS === 2
                    ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT
                    : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;
            const wrapT = texture.wrapT === 1
                ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE
                : texture.wrapT === 2
                    ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT
                    : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;
            const center = texture.center
                ? gl_matrix_1.vec2.fromValues(texture.center[0], texture.center[1])
                : gl_matrix_1.vec2.fromValues(0, 0);
            const color = texture.color
                ? gl_matrix_1.vec4.fromValues(texture.color[0] / 255, texture.color[1] / 255, texture.color[2] / 255, texture.color[3] / 255)
                : gl_matrix_1.vec4.fromValues(1, 1, 1, 1);
            const offset = texture.offset
                ? gl_matrix_1.vec2.fromValues(texture.offset[0], texture.offset[1])
                : gl_matrix_1.vec2.fromValues(0, 0);
            const repeat = texture.repeat
                ? gl_matrix_1.vec2.fromValues(texture.repeat[0], texture.repeat[1])
                : gl_matrix_1.vec2.fromValues(1, 1);
            return new viewer_shared_types_1.MapData((_a = response.data.image) !== null && _a !== void 0 ? _a : response.data.buffer, {
                blob: response.data.blob,
                wrapS,
                wrapT,
                minFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR,
                magFilter: viewer_shared_types_1.TEXTURE_FILTERING.LINEAR,
                center,
                color,
                offset,
                repeat,
                rotation: texture.rotation || 0,
            });
        });
    }
    loadMaterialDefinitionV1(data, presetData = {}) {
        // ambient is ignored
        if (data.color) {
            presetData.color = this.multiplyColors(data.color, presetData.color);
        }
        else if (data.diffuse) {
            // multiply color with diffuse
            presetData.color = this.multiplyColors(data.diffuse, presetData.color);
        }
        // emission is ignored
        // specular is ignored
        if (data.shine || data.shine === 0) {
            presetData.metalness = Math.min(1, data.shine);
            presetData.roughness = 1 - Math.min(1, data.shine);
        }
        if (data.hasOwnProperty("transparency"))
            presetData.transparency = data.transparency;
        if (data.bitmaptexture)
            presetData.bitmaptexture = {
                href: data.bitmaptexture,
            };
        if (data.bumptexture)
            presetData.bumptexture = {
                href: data.bumptexture,
            };
        if (data.transparencytexture)
            presetData.transparencytexture = {
                href: data.transparencytexture,
            };
        return presetData;
    }
    loadMaterialDefinitionV2(data, presetData = {}) {
        // ambient is ignored
        if (data.color)
            presetData.color = this.multiplyColors(data.color, presetData.color);
        presetData.side = data.side;
        if (data.metalness || data.metalness === 0)
            presetData.metalness = data.metalness;
        if (data.roughness || data.roughness === 0)
            presetData.roughness = data.roughness;
        if (data.hasOwnProperty("transparency"))
            presetData.transparency = data.transparency;
        if (data.alphaThreshold || data.alphaThreshold === 0)
            presetData.alphaThreshold = data.alphaThreshold;
        if (data.bitmaptexture)
            presetData.bitmaptexture = {
                href: data.bitmaptexture,
            };
        if (data.metalnesstexture)
            presetData.metalnesstexture = {
                href: data.metalnesstexture,
            };
        if (data.roughnesstexture)
            presetData.roughnesstexture = {
                href: data.roughnesstexture,
            };
        if (data.bumptexture)
            presetData.bumptexture = {
                href: data.bumptexture,
            };
        if (data.normaltexture)
            presetData.normaltexture = {
                href: data.normaltexture,
            };
        if (data.transparencytexture)
            presetData.transparencytexture = {
                href: data.transparencytexture,
            };
        return presetData;
    }
    loadMaterialDefinitionV3(data, presetData = {}) {
        // ambient is ignored
        if (data.color)
            presetData.color = this.multiplyColors(data.color, presetData.color);
        presetData.side = data.side;
        if (data.metalness || data.metalness === 0)
            presetData.metalness = data.metalness;
        if (data.roughness || data.roughness === 0)
            presetData.roughness = data.roughness;
        if (data.hasOwnProperty("transparency"))
            presetData.transparency = data.transparency;
        if (data.alphaThreshold || data.alphaThreshold === 0)
            presetData.alphaThreshold = data.alphaThreshold;
        if (data.bumpAmplitude || data.bumpAmplitude === 0)
            presetData.bumpAmplitude = data.bumpAmplitude;
        if (data.bitmaptexture)
            presetData.bitmaptexture = data.bitmaptexture;
        if (data.metalnesstexture)
            presetData.metalnesstexture = data.metalnesstexture;
        if (data.roughnesstexture)
            presetData.roughnesstexture = data.roughnesstexture;
        if (data.bumptexture)
            presetData.bumptexture = data.bumptexture;
        if (data.normaltexture)
            presetData.normaltexture = data.normaltexture;
        if (data.transparencytexture)
            presetData.transparencytexture = data.transparencytexture;
        // line material https://shapediver.atlassian.net/browse/SS-2272
        return presetData;
    }
    loadMaterialV3(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const material = new viewer_shared_types_1.MaterialStandardData();
            const promises = [];
            // ambient is ignored
            if (data.color)
                material.color = data.color;
            material.side =
                data.side === "front"
                    ? viewer_shared_types_1.MATERIAL_SIDE.FRONT
                    : data.side === "back"
                        ? viewer_shared_types_1.MATERIAL_SIDE.BACK
                        : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
            if (data.metalness || data.metalness === 0)
                material.metalness = data.metalness;
            if (data.roughness || data.roughness === 0)
                material.roughness = data.roughness;
            if (data.hasOwnProperty("transparency"))
                material.opacity = 1 - data.transparency;
            if (data.alphaThreshold || data.alphaThreshold === 0)
                material.alphaCutoff = data.alphaThreshold;
            if (data.bumpAmplitude || data.bumpAmplitude === 0)
                material.bumpScale = data.bumpAmplitude;
            if (data.bitmaptexture) {
                promises.push(this.loadMapWithProperties(data.bitmaptexture).then((map) => {
                    if (map)
                        material.map = map;
                    return map;
                }));
            }
            if (data.metalnesstexture) {
                promises.push(this.loadMapWithProperties(data.metalnesstexture).then((map) => {
                    if (map)
                        material.metalnessMap = map;
                    return map;
                }));
            }
            if (data.roughnesstexture) {
                promises.push(this.loadMapWithProperties(data.roughnesstexture).then((map) => {
                    if (map)
                        material.roughnessMap = map;
                    return map;
                }));
            }
            if (data.bumptexture) {
                promises.push(this.loadMapWithProperties(data.bumptexture).then((map) => {
                    if (map)
                        material.bumpMap = map;
                    return map;
                }));
            }
            if (data.normaltexture) {
                promises.push(this.loadMapWithProperties(data.normaltexture).then((map) => {
                    if (map)
                        material.normalMap = map;
                    return map;
                }));
            }
            if (data.transparencytexture) {
                promises.push(this.loadMapWithProperties(data.transparencytexture).then((map) => {
                    if (map)
                        material.alphaMap = map;
                    return map;
                }));
            }
            // line material https://shapediver.atlassian.net/browse/SS-2272
            yield Promise.all(promises);
            return material;
        });
    }
    loadPresetMaterial(preset) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.loadMaterialV3(this.loadPresetMaterialDefinition(preset));
        });
    }
    loadPresetMaterialDefinition(preset) {
        const definition = {};
        const idStrings = this.getClassAndSpecificId(preset);
        if (materialDatabase_1.materialDatabase[idStrings.class] &&
            materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific]) {
            this.assignSpecificDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], definition);
            this.assignGeneralDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], definition);
        }
        else if (materialDatabase_1.materialDatabase[idStrings.class] &&
            materialDatabase_1.materialDatabase[idStrings.class]["00"]) {
            this.assignSpecificDefinition({ class: idStrings.class, specific: "00" }, materialDatabase_1.materialDatabase[idStrings.class]["00"], definition);
            this.assignGeneralDefinition({ class: idStrings.class, specific: "00" }, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class]["00"], definition);
        }
        else {
            this.assignSpecificDefinition({ class: "00", specific: "00" }, materialDatabase_1.materialDatabase["00"]["00"], definition);
            this.assignGeneralDefinition({ class: "00", specific: "00" }, materialDatabase_1.materialDatabase["00"].properties, materialDatabase_1.materialDatabase["00"]["00"], definition);
        }
        return definition;
    }
    // #endregion Public Methods (12)
    // #region Private Methods (4)
    assignGeneralDefinition(id, generalDefinition, specificDefinition, definition) {
        if (generalDefinition.transparencytexture &&
            !specificDefinition.transparencytexture)
            definition.transparencytexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.transparencytexture,
            };
        if (generalDefinition.hasOwnProperty("alphaThreshold") &&
            !specificDefinition.hasOwnProperty("alphaThreshold"))
            definition.alphaThreshold = generalDefinition.alphaThreshold;
        if (generalDefinition.bumptexture && !specificDefinition.bumptexture)
            definition.bumptexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.bumptexture,
            };
        if (generalDefinition.hasOwnProperty("bumpAmplitude") &&
            !specificDefinition.hasOwnProperty("bumpAmplitude"))
            definition.bumpAmplitude = generalDefinition.bumpAmplitude;
        if (generalDefinition.color && !specificDefinition.color)
            definition.color = generalDefinition.color;
        if (generalDefinition.bitmaptexture &&
            !specificDefinition.bitmaptexture)
            definition.bitmaptexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.bitmaptexture,
            };
        if (generalDefinition.hasOwnProperty("metalness") &&
            !specificDefinition.hasOwnProperty("metalness"))
            definition.metalness = generalDefinition.metalness;
        if (generalDefinition.metalnesstexture &&
            !specificDefinition.metalnesstexture)
            definition.metalnesstexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.metalnesstexture,
            };
        if (generalDefinition.normaltexture &&
            !specificDefinition.normaltexture)
            definition.normaltexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.normaltexture,
            };
        if (generalDefinition.hasOwnProperty("transparency") &&
            !specificDefinition.hasOwnProperty("transparency"))
            definition.transparency = generalDefinition.transparency;
        if (generalDefinition.hasOwnProperty("roughness") &&
            !specificDefinition.hasOwnProperty("roughness"))
            definition.roughness = generalDefinition.roughness;
        if (generalDefinition.roughnesstexture &&
            !specificDefinition.roughnesstexture)
            definition.roughnesstexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    generalDefinition.roughnesstexture,
            };
        if (generalDefinition.side && !specificDefinition.side)
            definition.side = generalDefinition.side;
    }
    assignSpecificDefinition(id, specificDefinition, definition) {
        if (specificDefinition.transparencytexture)
            definition.transparencytexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.transparencytexture,
            };
        if (specificDefinition.hasOwnProperty("alphaThreshold"))
            definition.alphaThreshold = specificDefinition.alphaThreshold;
        if (specificDefinition.bumptexture)
            definition.bumptexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.bumptexture,
            };
        if (specificDefinition.hasOwnProperty("bumpAmplitude"))
            definition.bumpAmplitude = specificDefinition.bumpAmplitude;
        if (specificDefinition.color)
            definition.color = specificDefinition.color;
        if (specificDefinition.bitmaptexture)
            definition.bitmaptexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.bitmaptexture,
            };
        if (specificDefinition.hasOwnProperty("metalness"))
            definition.metalness = specificDefinition.metalness;
        if (specificDefinition.metalnesstexture)
            definition.metalnesstexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.metalnesstexture,
            };
        if (specificDefinition.normaltexture)
            definition.normaltexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.normaltexture,
            };
        if (specificDefinition.hasOwnProperty("transparency"))
            definition.transparency = specificDefinition.transparency;
        if (specificDefinition.hasOwnProperty("roughness"))
            definition.roughness = specificDefinition.roughness;
        if (specificDefinition.roughnesstexture)
            definition.roughnesstexture = {
                href: "https://viewer.shapediver.com/v2/materials/1024/" +
                    id.class +
                    "/" +
                    id.specific +
                    "/" +
                    specificDefinition.roughnesstexture,
            };
        if (specificDefinition.side)
            definition.side = specificDefinition.side;
    }
    getClassAndSpecificId(id) {
        // for a while, we had documented the presets to be 10, 20, 30 and 40 here, we allow for the few cases where this was used to succeed
        if (id < 100 && id % 10 == 0)
            id /= 10;
        // if the id is less than 10, multiply it by 100
        if (id < 10)
            id *= 100;
        const cast = (id) => {
            const idString = String(id);
            return idString.padStart(2, "0").slice(0, 2);
        };
        return {
            class: cast(Math.floor(id / 100)),
            specific: cast(id - Math.floor(id / 100) * 100),
        };
    }
    /**
     * Multiply two colors
     *
     * @param color1
     * @param color2
     * @returns
     */
    multiplyColors(color1, color2) {
        if (!color2)
            return color1;
        return [
            Math.min(255, (color1[0] * color2[0]) / 255),
            Math.min(255, (color1[1] * color2[1]) / 255),
            Math.min(255, (color1[2] * color2[2]) / 255),
            Math.min(255, ((color1[3] !== undefined ? color1[3] : 255) *
                (color2[3] !== undefined ? color2[3] : 255)) /
                255),
        ];
    }
}
exports.MaterialEngine = MaterialEngine;
//# sourceMappingURL=MaterialEngine.js.map
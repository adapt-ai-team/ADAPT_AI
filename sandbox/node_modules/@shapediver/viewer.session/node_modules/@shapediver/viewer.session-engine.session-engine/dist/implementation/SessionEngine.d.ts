import { ShapeDiverRequestExport, ShapeDiverRequestGltfUploadQueryConversion, ShapeDiverResponseDto, ShapeDiverResponseExport, ShapeDiverResponseFileInfo, ShapeDiverResponseModelState } from "@shapediver/sdk.geometry-api-sdk-v2";
import { ITreeNode } from "@shapediver/viewer.shared.node-tree";
import { SettingsEngine } from "@shapediver/viewer.shared.services";
import { ISettingsSections } from "@shapediver/viewer.shared.types";
import { IExport } from "../interfaces/dto/IExport";
import { IOutput } from "../interfaces/dto/IOutput";
import { IParameter } from "../interfaces/dto/IParameter";
import { ISessionEngine } from "../interfaces/ISessionEngine";
import { ISessionTreeNode } from "../interfaces/ISessionTreeNode";
import { OutputLoaderTaskEventInfo } from "./OutputLoader";
export declare class SessionEngine implements ISessionEngine {
    #private;
    private readonly _converter;
    private readonly _eventEngine;
    private readonly _exports;
    private readonly _guid?;
    private readonly _httpClient;
    private readonly _id;
    private readonly _logger;
    private readonly _modelViewUrl;
    private readonly _outputLoader;
    private readonly _outputs;
    private readonly _outputsFreeze;
    private readonly _parameterValues;
    private readonly _parameters;
    private readonly _performanceEvaluator;
    private readonly _sceneTree;
    private readonly _sessionEngineId;
    private readonly _settingsEngine;
    private readonly _stateEngine;
    private readonly _ticket?;
    private readonly _uuidGenerator;
    private _allowOutputLoading;
    private _automaticSceneUpdate;
    private _closeOnFailure;
    private _closed;
    private _customizeOnParameterChange;
    private _dataCache;
    private _excludeViewports;
    private _headers;
    private _initialized;
    private _jwtToken?;
    private _loadSdtf;
    private _modelId?;
    private _modelState?;
    private _modelStateId?;
    private _modelStateValidationMode?;
    private _node;
    private _refreshJwtToken?;
    private _responseDto?;
    private _retryCounter;
    private _sdk;
    private _sessionId?;
    private _updateCallback;
    private _viewerSettings?;
    private _viewerSettingsVersion;
    private _viewerSettingsVersionBackend;
    private _throwOnCustomizationError;
    /**
     * Can be use to initialize a session with the ticket/guid and modelViewUrl and returns a scene graph node with the result.
     * Can be use to customize the session with updated parameters to get the updated scene graph node.
     */
    constructor(properties: {
        id: string;
        ticket?: string;
        guid?: string;
        modelViewUrl: string;
        buildVersion: string;
        buildDate: string;
        jwtToken?: string;
        excludeViewports?: string[];
        allowOutputLoading: boolean;
        loadSdtf: boolean;
        modelStateId?: string;
        modelStateValidationMode?: boolean;
        throwOnCustomizationError?: boolean;
    });
    get automaticSceneUpdate(): boolean;
    set automaticSceneUpdate(value: boolean);
    get canUploadGLTF(): boolean;
    get customizeOnParameterChange(): boolean;
    set customizeOnParameterChange(value: boolean);
    get excludeViewports(): string[];
    set excludeViewports(value: string[]);
    get exports(): {
        [key: string]: IExport;
    };
    get guid(): string | undefined;
    get hasStoredSettings(): boolean;
    get id(): string;
    get initialized(): boolean;
    get jwtToken(): string | undefined;
    get loadSdtf(): boolean;
    set loadSdtf(value: boolean);
    get modelState(): ShapeDiverResponseModelState | undefined;
    get modelViewUrl(): string;
    get node(): ITreeNode;
    get outputs(): {
        [key: string]: IOutput;
    };
    get outputsFreeze(): {
        [key: string]: boolean;
    };
    get parameterValues(): {
        [key: string]: string;
    };
    get parameters(): {
        [key: string]: IParameter<unknown>;
    };
    get refreshJwtToken(): (() => Promise<string>) | undefined;
    set refreshJwtToken(value: (() => Promise<string>) | undefined);
    get settingsEngine(): SettingsEngine;
    get ticket(): string | undefined;
    get updateCallback(): ((newNode?: ITreeNode, oldNode?: ITreeNode) => void) | null;
    set updateCallback(value: ((newNode?: ITreeNode, oldNode?: ITreeNode) => void) | null);
    get viewerSettings(): object | undefined;
    applySettings(response: ShapeDiverResponseDto, sections?: ISettingsSections): void;
    canGoBack(): boolean;
    canGoForward(): boolean;
    cancelCustomization(): void;
    close(retry?: boolean): Promise<void>;
    createModelState(parameterValues?: {
        [key: string]: unknown;
    }, omitSessionParameterValues?: boolean, image?: (() => string) | (() => Promise<string>) | string | Promise<string> | Blob | File, data?: Record<string, any>, arScene?: (() => Promise<ArrayBuffer>) | ArrayBuffer | (() => Promise<Blob>) | Blob | File, retry?: boolean): Promise<string>;
    /**
     * Customizes the session with updated parameters to get the updated scene graph node.
     *
     * @param parameters the parameter set to update the session
     * @returns promise with a scene graph node
     */
    customize(force?: boolean, waitForViewportUpdate?: boolean): Promise<ITreeNode>;
    customizeParallel(parameterValues: {
        [key: string]: unknown;
    }, loadOutputs?: boolean): Promise<ISessionTreeNode | ShapeDiverResponseDto>;
    customizeWithModelState(modelState: string | ShapeDiverResponseDto, retry?: boolean): Promise<ITreeNode>;
    getFileInfo(parameterId: string, fileId: string, retry?: boolean): Promise<ShapeDiverResponseFileInfo>;
    goBack(): Promise<ITreeNode>;
    goForward(): Promise<ITreeNode>;
    /**
     * Initializes the session with the ticket and modelViewUrl.
     *
     * @returns promise with a scene graph node
     */
    init(parameterValues?: {
        [key: string]: string;
    }, retry?: boolean): Promise<void>;
    loadCachedOutputsParallel(outputMapping: {
        [key: string]: string;
    }, taskEventInfo?: OutputLoaderTaskEventInfo, retry?: boolean): Promise<{
        [key: string]: ITreeNode | undefined;
    }>;
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(cancelRequest: (() => boolean) | undefined, taskEventInfo: OutputLoaderTaskEventInfo, retry?: boolean): Promise<ISessionTreeNode>;
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, another customization request with the parameter set is sent.
     *
     * @param parameters the parameter set to update the session
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputsParallel(responseDto: ShapeDiverResponseDto, cancelRequest: (() => boolean) | undefined, taskEventInfo: OutputLoaderTaskEventInfo, retry?: boolean): Promise<ISessionTreeNode>;
    requestExport(exportId: string, parameters: {
        [key: string]: unknown;
    }, maxWaitTime: number, retry?: boolean): Promise<ShapeDiverResponseExport>;
    requestExports(body: ShapeDiverRequestExport, loadOutputs?: boolean, maxWaitMsec?: number, retry?: boolean): Promise<ShapeDiverResponseDto>;
    resetSettings(sections?: ISettingsSections): void;
    saveDefaultParameterValues(): Promise<boolean>;
    saveDefaultParameters(retry?: boolean): Promise<boolean>;
    /**
     * Save the export properties for displayname, order, tooltip and hidden
     *
     * @param exports
     * @returns
     */
    saveExportProperties(exports: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    /**
     * Save the output properties for displayname, order, tooltip and hidden
     *
     * @param outputs
     * @returns
     */
    saveOutputProperties(outputs: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    /**
     * Save the parameter properties for displayname, order, tooltip and hidden
     *
     * @param parameters
     * @returns
     */
    saveParameterProperties(parameters: {
        [key: string]: {
            displayname: string;
            hidden: boolean;
            order: number;
            tooltip: string;
        };
    }, retry?: boolean): Promise<boolean>;
    saveSettings(json: unknown, retry?: boolean): Promise<boolean>;
    saveUiProperties(saveInSettings?: boolean): Promise<boolean>;
    setJwtToken(value: string, retry?: boolean): Promise<void>;
    updateOutputs(taskEventInfo?: OutputLoaderTaskEventInfo, waitForViewportUpdate?: boolean): Promise<ITreeNode>;
    uploadFile(parameterId: string, data: File, type: string, retry?: boolean): Promise<string>;
    /**
     * Uploads all file parameters and returns the file parameter values.
     * If parameterValues is provided, the file parameter values are added to it.
     *
     * @param parameterValues
     * @returns
     */
    uploadFileParameters(parameterValues?: {
        [key: string]: unknown;
    }): Promise<{
        [key: string]: string;
    }>;
    uploadGLTF(blob: Blob, conversion?: ShapeDiverRequestGltfUploadQueryConversion, retry?: boolean): Promise<ShapeDiverResponseDto>;
    private _saveSessionSettings;
    private _warningCreator;
    private addBusyMode;
    private addToSceneTree;
    private cancelProcess;
    private checkAvailability;
    private cleanExportParameters;
    /**
     * Create an interaction parameter based on the parameter definition.
     *
     * @param parameter
     * @returns
     */
    private createInteractionParameter;
    private customizeInternal;
    private customizeSession;
    /**
     * Get all file parameters from the parameter set.
     * If the parameter is not set in the parameter set, the value from the parameter object is used.
     *
     * @param parameters
     * @returns
     */
    private getFileParameterSet;
    private handleError;
    /**
     * Process the image input and return the image data and array buffer.
     *
     * In the case of the image being a Blob or File, the image data is constructed from the Blob or File.
     * In the case of the image being a string, we check if it is a data URL or a URL.
     * If it is a data URL, we convert it to a Blob and construct the image data from the Blob.
     * If it is a URL, we download the image and return the image data and array buffer.
     *
     * @param image
     * @returns
     */
    private processImageInput;
    private removeBusyMode;
    private removeFromSceneTree;
    /**
     * Returns a promise that resolves after the amount of milliseconds provided.
     *
     * @param ms the milliseconds
     * @returns promise that resolve after specified milliseconds
     */
    private timeout;
    private updateResponseDto;
    private waitForUpdateCallbacks;
}
//# sourceMappingURL=SessionEngine.d.ts.map
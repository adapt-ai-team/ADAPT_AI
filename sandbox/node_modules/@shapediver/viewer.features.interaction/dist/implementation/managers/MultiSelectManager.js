"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MultiSelectManager_eventEngine, _MultiSelectManager_logger, _MultiSelectManager_tree, _MultiSelectManager_deselectOnEmpty, _MultiSelectManager_effectMaterialTokens, _MultiSelectManager_filter, _MultiSelectManager_groupEffectMaterialToken, _MultiSelectManager_groupedNodes, _MultiSelectManager_insertionKey, _MultiSelectManager_maximumNodes, _MultiSelectManager_minimumNodes, _MultiSelectManager_nodes, _MultiSelectManager_removalKey, _MultiSelectManager_useModifierKeys;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSelectManager = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const IInteractionEngine_1 = require("../../interfaces/IInteractionEngine");
const AbstractInteractionManager_1 = require("../AbstractInteractionManager");
const InteractionData_1 = require("../InteractionData");
/* eslint-disable @typescript-eslint/no-unused-vars */
class MultiSelectManager extends AbstractInteractionManager_1.AbstractInteractionManager {
    // #endregion Properties (13)
    // #region Constructors (1)
    constructor(id, effectMaterial, minimumNodes, maximumNodes) {
        super(id, effectMaterial);
        // #region Properties (13)
        _MultiSelectManager_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _MultiSelectManager_logger.set(this, viewer_shared_services_1.Logger.instance);
        _MultiSelectManager_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _MultiSelectManager_deselectOnEmpty.set(this, false);
        _MultiSelectManager_effectMaterialTokens.set(this, []);
        _MultiSelectManager_filter.set(this, (interactionState) => {
            if (interactionState === IInteractionEngine_1.INTERACTION_STATE.DOWN) {
                return (node) => {
                    return !!this.getInteractionData(node);
                };
            }
            return (node) => false;
        });
        _MultiSelectManager_groupEffectMaterialToken.set(this, []);
        _MultiSelectManager_groupedNodes.set(this, []);
        _MultiSelectManager_insertionKey.set(this, "Shift");
        _MultiSelectManager_maximumNodes.set(this, Infinity);
        _MultiSelectManager_minimumNodes.set(this, 0);
        _MultiSelectManager_nodes.set(this, []);
        _MultiSelectManager_removalKey.set(this, "Control");
        _MultiSelectManager_useModifierKeys.set(this, false);
        if (minimumNodes)
            __classPrivateFieldSet(this, _MultiSelectManager_minimumNodes, minimumNodes, "f");
        if (maximumNodes)
            __classPrivateFieldSet(this, _MultiSelectManager_maximumNodes, maximumNodes, "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (13)
    get deselectOnEmpty() {
        return __classPrivateFieldGet(this, _MultiSelectManager_deselectOnEmpty, "f");
    }
    set deselectOnEmpty(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_deselectOnEmpty, value, "f");
    }
    get filter() {
        return __classPrivateFieldGet(this, _MultiSelectManager_filter, "f");
    }
    get insertionKey() {
        return __classPrivateFieldGet(this, _MultiSelectManager_insertionKey, "f");
    }
    set insertionKey(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_insertionKey, value, "f");
    }
    get maximumNodes() {
        return __classPrivateFieldGet(this, _MultiSelectManager_maximumNodes, "f");
    }
    set maximumNodes(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_maximumNodes, value, "f");
    }
    get minimumNodes() {
        return __classPrivateFieldGet(this, _MultiSelectManager_minimumNodes, "f");
    }
    set minimumNodes(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_minimumNodes, value, "f");
    }
    get removalKey() {
        return __classPrivateFieldGet(this, _MultiSelectManager_removalKey, "f");
    }
    set removalKey(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_removalKey, value, "f");
    }
    get useModifierKeys() {
        return __classPrivateFieldGet(this, _MultiSelectManager_useModifierKeys, "f");
    }
    set useModifierKeys(value) {
        __classPrivateFieldSet(this, _MultiSelectManager_useModifierKeys, value, "f");
    }
    // #endregion Public Getters And Setters (13)
    // #region Public Methods (8)
    add(viewport) {
        this.viewport = viewport;
    }
    /**
     * Deselect a specific node.
     *
     * @param node
     */
    deselect(node) {
        if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(node))
            this.deactivateNode(node);
    }
    /**
     * Deselect all nodes.
     */
    deselectAll() {
        while (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length > 0)
            this.deactivateNode(__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f")[0]);
    }
    onDown(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _MultiSelectManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        const intersections = intersection.filter((i) => this.filter(IInteractionEngine_1.INTERACTION_STATE.DOWN)(i.node));
        if (__classPrivateFieldGet(this, _MultiSelectManager_useModifierKeys, "f") === false) {
            if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length > 0) {
                let originalNode;
                __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f").forEach((array) => {
                    if (intersections.length > 0 &&
                        array.includes(intersections[0].node))
                        originalNode = __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").find((n) => array.includes(n));
                });
                if (intersections.length > 0 &&
                    !__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersections[0].node) &&
                    !originalNode) {
                    // case other node was clicked, deselect then select
                    this.activateNode(intersections[0], event, ray);
                }
                else if (intersections.length > 0 &&
                    __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersections[0].node)) {
                    // case same node was clicked, only deselect
                    this.deactivateNode(intersections[0].node, event);
                }
                else if (originalNode) {
                    // case it is one of the grouped nodes
                    this.deactivateNode(originalNode, event);
                }
            }
            else if (intersections.length > 0) {
                // easy case, no node select, just select this one
                this.activateNode(intersections[0], event, ray);
            }
        }
        else {
            const shiftPressed = event.shiftKey;
            const controlPressed = event.ctrlKey;
            if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length > 0) {
                let originalNode;
                __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f").forEach((array) => {
                    if (intersections.length > 0 &&
                        array.includes(intersections[0].node))
                        originalNode = __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").find((n) => array.includes(n));
                });
                if (shiftPressed &&
                    !controlPressed &&
                    intersections.length > 0 &&
                    !__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersections[0].node) &&
                    !originalNode) {
                    // case other node was clicked, deselect then select
                    this.activateNode(intersections[0], event, ray);
                }
                else if (controlPressed &&
                    !shiftPressed &&
                    intersections.length > 0 &&
                    __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersections[0].node)) {
                    // case same node was clicked, only deselect
                    this.deactivateNode(intersections[0].node, event);
                }
                else if (controlPressed && !shiftPressed && originalNode) {
                    // case it is one of the grouped nodes
                    this.deactivateNode(originalNode, event);
                }
                else if (!shiftPressed &&
                    !controlPressed &&
                    intersections.length > 0 &&
                    !__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersections[0].node)) {
                    // switch nodes
                    this.deselectAll();
                    this.activateNode(intersections[0], event, ray);
                }
                else if (intersections.length === 0 &&
                    __classPrivateFieldGet(this, _MultiSelectManager_deselectOnEmpty, "f")) {
                    this.deselectAll();
                }
            }
            else if (!controlPressed && intersections.length > 0) {
                // easy case, no node select, just select this one
                this.activateNode(intersections[0], event, ray);
            }
        }
    }
    onEnd(event, ray, intersection, endState) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _MultiSelectManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
    }
    onMove(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _MultiSelectManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
    }
    remove() {
        while (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length > 0)
            this.deactivateNode(__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f")[0]);
        this.viewport = undefined;
    }
    /**
     * Select a node.
     * The point and distance of the intersection can be freely chosen and are provided in the event callbacks.
     *
     * @param intersection
     */
    select(intersection) {
        if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").includes(intersection.node))
            this.deactivateNode(intersection.node);
        this.activateNode(intersection);
    }
    // #endregion Public Methods (8)
    // #region Private Methods (2)
    /**
     * Utility function to make the node the current active node.
     * Set the according values, apply the effect and emit the event.
     *
     * @param intersection
     * @param event
     * @param ray
     */
    activateNode(intersection, event, ray) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _MultiSelectManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length >= __classPrivateFieldGet(this, _MultiSelectManager_maximumNodes, "f")) {
            __classPrivateFieldGet(this, _MultiSelectManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.MULTI_SELECT_MAXIMUM_NODES, {
                viewportId: this.viewport.id,
                node: intersection.node,
                nodes: __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f"),
                intersectionPoint: intersection.point,
                ray,
                event,
                manager: this,
                groupedNodes: __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1],
            });
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError(`The maximum number of nodes ${this.maximumNodes} has been reached.`);
        }
        __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").push(intersection.node);
        // find the interaction data
        const data = this.getInteractionData(intersection.node);
        if (data)
            data.interactionStates.select = true;
        // find and store all nodes that are within the group
        __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1] = [];
        __classPrivateFieldGet(this, _MultiSelectManager_groupEffectMaterialToken, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1] = [];
        if (data && data.groupId)
            __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1] =
                this.gatheredGroupedNodes[data.groupId] || [];
        if (this.effectMaterial) {
            __classPrivateFieldGet(this, _MultiSelectManager_effectMaterialTokens, "f").push(this.interactionEffectUtils.applyEffectMaterial(intersection.node, this.effectMaterial));
            if (__classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1])
                __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1].forEach((n) => __classPrivateFieldGet(this, _MultiSelectManager_groupEffectMaterialToken, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1].push(this.interactionEffectUtils.applyEffectMaterial(n, this.effectMaterial)));
        }
        else {
            __classPrivateFieldGet(this, _MultiSelectManager_effectMaterialTokens, "f").push(undefined);
        }
        this.viewport.updateNode(intersection.node);
        if (__classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1].forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        __classPrivateFieldGet(this, _MultiSelectManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.MULTI_SELECT_ON, {
            viewportId: this.viewport.id,
            nodes: __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f"),
            node: intersection.node,
            intersectionPoint: intersection.point,
            ray,
            event,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1],
        });
        if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length < __classPrivateFieldGet(this, _MultiSelectManager_minimumNodes, "f")) {
            __classPrivateFieldGet(this, _MultiSelectManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.MULTI_SELECT_MINIMUM_NODES, {
                viewportId: this.viewport.id,
                node: intersection.node,
                nodes: __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f"),
                intersectionPoint: intersection.point,
                ray,
                event,
                manager: this,
                groupedNodes: __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length - 1],
            });
        }
    }
    /**
     * Utility function to make the node inactive.
     * Set the according values, remove the effect and emit the event.
     *
     * @param event
     */
    deactivateNode(node, event) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _MultiSelectManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        // find the interaction data
        const data = this.getInteractionData(node);
        if (data)
            data.interactionStates.select = false;
        const index = __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").indexOf(node);
        if (index === -1)
            return;
        const effectMaterialToken = __classPrivateFieldGet(this, _MultiSelectManager_effectMaterialTokens, "f")[index];
        __classPrivateFieldGet(this, _MultiSelectManager_effectMaterialTokens, "f").splice(index, 1);
        if (effectMaterialToken) {
            this.interactionEffectUtils.removeEffectMaterial(node, effectMaterialToken);
            if (__classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index])
                __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index].forEach((n, i) => this.interactionEffectUtils.removeEffectMaterial(n, __classPrivateFieldGet(this, _MultiSelectManager_groupEffectMaterialToken, "f")[index][i]));
        }
        this.viewport.updateNode(node);
        if (__classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index])
            __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index].forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").splice(index, 1);
        __classPrivateFieldGet(this, _MultiSelectManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.MULTI_SELECT_OFF, {
            viewportId: this.viewport.id,
            nodes: __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f"),
            node: node,
            event,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index],
        });
        __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f").splice(index, 1);
        __classPrivateFieldGet(this, _MultiSelectManager_groupEffectMaterialToken, "f").splice(index, 1);
        if (__classPrivateFieldGet(this, _MultiSelectManager_nodes, "f").length < __classPrivateFieldGet(this, _MultiSelectManager_minimumNodes, "f")) {
            __classPrivateFieldGet(this, _MultiSelectManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.MULTI_SELECT_MINIMUM_NODES, {
                viewportId: this.viewport.id,
                node: node,
                nodes: __classPrivateFieldGet(this, _MultiSelectManager_nodes, "f"),
                event,
                manager: this,
                groupedNodes: __classPrivateFieldGet(this, _MultiSelectManager_groupedNodes, "f")[index],
            });
        }
    }
    getInteractionData(node) {
        for (let i = 0; i < node.data.length; i++) {
            if (node.data[i] instanceof InteractionData_1.InteractionData) {
                if ((node.data[i].restrictedManagers
                    .length === 0 ||
                    (node.data[i]).restrictedManagers.includes(this.id)) &&
                    node.data[i].interactionTypes.select)
                    return node.data[i];
            }
        }
    }
}
exports.MultiSelectManager = MultiSelectManager;
_MultiSelectManager_eventEngine = new WeakMap(), _MultiSelectManager_logger = new WeakMap(), _MultiSelectManager_tree = new WeakMap(), _MultiSelectManager_deselectOnEmpty = new WeakMap(), _MultiSelectManager_effectMaterialTokens = new WeakMap(), _MultiSelectManager_filter = new WeakMap(), _MultiSelectManager_groupEffectMaterialToken = new WeakMap(), _MultiSelectManager_groupedNodes = new WeakMap(), _MultiSelectManager_insertionKey = new WeakMap(), _MultiSelectManager_maximumNodes = new WeakMap(), _MultiSelectManager_minimumNodes = new WeakMap(), _MultiSelectManager_nodes = new WeakMap(), _MultiSelectManager_removalKey = new WeakMap(), _MultiSelectManager_useModifierKeys = new WeakMap();
//# sourceMappingURL=MultiSelectManager.js.map
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DragManager_eventEngine, _DragManager_logger, _DragManager_tree, _DragManager_uuidGenerator, _DragManager_draggedNode, _DragManager_effectMaterialToken, _DragManager_filter, _DragManager_groupEffectMaterialToken, _DragManager_groupedNodes, _DragManager_intersection, _DragManager_restrictionManager, _DragManager_setupOptions, _DragManager_tokenCameraFreeze, _DragManager_tokenContinuousRendering, _DragManager_tokenContinuousShadowMapUpdate;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragManager = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_rendering_engine_intersection_restriction_engine_1 = require("@shapediver/viewer.rendering-engine.intersection-restriction-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const IInteractionEngine_1 = require("../../interfaces/IInteractionEngine");
const AbstractInteractionManager_1 = require("../AbstractInteractionManager");
const CameraPlaneConstraint_1 = require("../dragConstraints/CameraPlaneConstraint");
const LineConstraint_1 = require("../dragConstraints/LineConstraint");
const PlaneConstraint_1 = require("../dragConstraints/PlaneConstraint");
const PointConstraint_1 = require("../dragConstraints/PointConstraint");
const InteractionData_1 = require("../InteractionData");
/* eslint-disable @typescript-eslint/no-unused-vars */
class DragManager extends AbstractInteractionManager_1.AbstractInteractionManager {
    constructor(id, effectMaterial) {
        super(id, effectMaterial);
        _DragManager_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _DragManager_logger.set(this, viewer_shared_services_1.Logger.instance);
        _DragManager_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _DragManager_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        _DragManager_draggedNode.set(this, void 0);
        _DragManager_effectMaterialToken.set(this, void 0);
        _DragManager_filter.set(this, (interactionState) => {
            if (interactionState === IInteractionEngine_1.INTERACTION_STATE.DOWN) {
                return (node) => {
                    return !!this.getInteractionData(node);
                };
            }
            return (node) => false;
        });
        _DragManager_groupEffectMaterialToken.set(this, void 0);
        _DragManager_groupedNodes.set(this, void 0);
        _DragManager_intersection.set(this, null);
        _DragManager_restrictionManager.set(this, void 0);
        _DragManager_setupOptions.set(this, null);
        _DragManager_tokenCameraFreeze.set(this, void 0);
        _DragManager_tokenContinuousRendering.set(this, void 0);
        _DragManager_tokenContinuousShadowMapUpdate.set(this, void 0);
    }
    get filter() {
        return __classPrivateFieldGet(this, _DragManager_filter, "f");
    }
    add(viewport) {
        this.viewport = viewport;
        __classPrivateFieldSet(this, _DragManager_restrictionManager, new viewer_rendering_engine_intersection_restriction_engine_1.RestrictionManager(this.viewport), "f");
    }
    /**
     * Add a new drag constraint.
     * Returns a token that is used for removing the drag constraint via {@link removeRestriction}.
     *
     * @deprecated This method is deprecated. Please use {@link addRestriction} instead.
     * @param constraint
     * @returns
     */
    addDragConstraint(constraint) {
        if (!__classPrivateFieldGet(this, _DragManager_restrictionManager, "f")) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        viewer_shared_services_1.Logger.instance.warn("The method addDragConstraint is deprecated. Please use addRestriction instead.");
        const token = __classPrivateFieldGet(this, _DragManager_uuidGenerator, "f").create();
        if (constraint instanceof PointConstraint_1.PointConstraint) {
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").addRestriction({
                type: viewer_rendering_engine_intersection_restriction_engine_1.RESTRICTION_TYPE.POINT,
                id: token,
                point: constraint.point,
                radius: constraint.radius,
                rotation: constraint.rotation,
            });
        }
        else if (constraint instanceof LineConstraint_1.LineConstraint) {
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").addRestriction({
                type: viewer_rendering_engine_intersection_restriction_engine_1.RESTRICTION_TYPE.LINE,
                id: token,
                point1: constraint.point1,
                point2: constraint.point2,
                radius: constraint.radius,
                rotation: constraint.rotation,
            });
        }
        else if (constraint instanceof CameraPlaneConstraint_1.CameraPlaneConstraint) {
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").addRestriction({
                type: viewer_rendering_engine_intersection_restriction_engine_1.RESTRICTION_TYPE.CAMERA_PLANE,
                id: token,
            });
        }
        else if (constraint instanceof PlaneConstraint_1.PlaneConstraint) {
            const origin = constraint.coplanarPoint
                ? gl_matrix_1.vec3.clone(constraint.coplanarPoint)
                : gl_matrix_1.vec3.fromValues(0, 0, 0);
            const normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), constraint.normal);
            const vector_u = gl_matrix_1.vec3.create();
            const vector_v = gl_matrix_1.vec3.create();
            if (Math.abs(gl_matrix_1.vec3.dot(normal, gl_matrix_1.vec3.fromValues(0, 0, 1))) < 0.999) {
                gl_matrix_1.vec3.cross(vector_u, normal, gl_matrix_1.vec3.fromValues(0, 0, 1));
            }
            else {
                gl_matrix_1.vec3.cross(vector_u, normal, gl_matrix_1.vec3.fromValues(0, 1, 0));
            }
            gl_matrix_1.vec3.normalize(vector_u, vector_u);
            gl_matrix_1.vec3.cross(vector_v, normal, vector_u);
            gl_matrix_1.vec3.normalize(vector_v, vector_v);
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").addRestriction({
                type: viewer_rendering_engine_intersection_restriction_engine_1.RESTRICTION_TYPE.PLANE,
                id: token,
                vector_u,
                vector_v,
                rotation: constraint.rotation,
                origin,
            });
        }
        return token;
    }
    /**
     * Add a new restriction.
     * Returns a token that is used for removing the restriction via {@link removeRestriction}.
     *
     * @param properties
     * @returns
     */
    addRestriction(properties) {
        if (!__classPrivateFieldGet(this, _DragManager_restrictionManager, "f")) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        return __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").addRestriction(properties);
    }
    onDown(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        const intersections = intersection.filter((i) => this.filter(IInteractionEngine_1.INTERACTION_STATE.DOWN)(i.node));
        if (intersections.length > 0) {
            this.setNode(intersections[0].node, intersection[0].geometryData, intersections[0].distance, intersections[0].point, event, ray);
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").showRestrictionVisualization = true;
        }
    }
    onEnd(event, ray, intersection, endState) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").showRestrictionVisualization = false;
        if (!__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            return;
        const transformationResult = __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").rayTrace(ray, {
            type: "dragging",
            dragAnchors: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragAnchors,
            dragOrigin: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            startPoint: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
        });
        const transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrixInverse, (transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.transformation) || gl_matrix_1.mat4.create()), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrix);
        // apply the transformation for the main node
        this.applyTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node, transformationMatrix);
        this.viewport.updateNodeTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        // and apply it for all grouped nodes
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f")) {
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => {
                this.applyTransformation(n, transformationMatrix);
                this.viewport.updateNodeTransformation(n);
            });
        }
        this.removeNode(event, ray);
    }
    onMove(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        if (!__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            return;
        __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").showRestrictionVisualization = true;
        const interactionData = this.getInteractionData(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        const transformationResult = __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").rayTrace(ray, {
            type: "dragging",
            dragAnchors: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragAnchors,
            dragOrigin: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            startPoint: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
        });
        const transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrixInverse, (transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.transformation) || gl_matrix_1.mat4.create()), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrix);
        // apply the transformation for the main node
        this.applyTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node, transformationMatrix);
        this.viewport.updateNodeTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        // and apply it for all grouped nodes
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f")) {
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => {
                this.applyTransformation(n, transformationMatrix);
                this.viewport.updateNodeTransformation(n);
            });
        }
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_MOVE, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            matrix: transformationMatrix,
            ray,
            event,
            restriction: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.restriction,
            dragAnchor: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.dragAnchor,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _DragManager_groupedNodes, "f"),
        });
    }
    remove() {
        this.removeNode();
        this.viewport = undefined;
    }
    /**
     * Remove the drag constraint that was added via {@link removeRestriction}.
     *
     * @deprecated This method is deprecated. Please use {@link removeRestriction} instead.
     * @param token
     * @returns
     */
    removeDragConstraint(token) {
        if (!__classPrivateFieldGet(this, _DragManager_restrictionManager, "f")) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return false;
        }
        return __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").removeRestriction(token);
    }
    /**
     * Remove the node as the currently used drag node.
     *
     * @returns
     */
    removeNode(event, ray) {
        var _a;
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        if (!__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            return;
        __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").showRestrictionVisualization = false;
        let transformationMatrix, transformationResult;
        // if we have everything we need (the ray) than we try one last time to calculate the transformation
        if (ray) {
            const interactionData = this.getInteractionData(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
            transformationResult = __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").rayTrace(ray, {
                type: "dragging",
                dragAnchors: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragAnchors,
                dragOrigin: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
                node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
                startPoint: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
            });
            transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrixInverse, (transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.transformation) || gl_matrix_1.mat4.create()), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrix);
            // apply the transformation for the main node
            this.applyTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node, transformationMatrix);
            this.viewport.updateNodeTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
            // and apply it for all grouped nodes
            if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f")) {
                __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => {
                    this.applyTransformation(n, transformationMatrix);
                    this.viewport.updateNodeTransformation(n);
                });
            }
        }
        else {
            transformationMatrix = (_a = __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node.transformations.find((t) => t.id === "SD_drag_matrix")) === null || _a === void 0 ? void 0 : _a.matrix;
        }
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_END, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            matrix: transformationMatrix,
            event,
            ray,
            restriction: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.restriction,
            dragAnchor: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.dragAnchor,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _DragManager_groupedNodes, "f"),
        });
        __classPrivateFieldSet(this, _DragManager_setupOptions, null, "f");
        // optional removal
        // this.removeTransformation(this.#draggedNode.node);
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        // and update all grouped nodes
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => this.viewport.updateNode(n));
        this.deactivateNode();
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenCameraFreeze, "f"));
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenContinuousRendering, "f"));
        this.viewport.removeFlag(__classPrivateFieldGet(this, _DragManager_tokenContinuousShadowMapUpdate, "f"));
    }
    /**
     * Removes the restriction with the given token.
     *
     * @param token
     * @returns
     */
    removeRestriction(token) {
        if (!__classPrivateFieldGet(this, _DragManager_restrictionManager, "f")) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return false;
        }
        return __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").removeRestriction(token);
    }
    /**
     * Removes all restrictions.
     */
    removeRestrictions() {
        if (!__classPrivateFieldGet(this, _DragManager_restrictionManager, "f")) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        for (const token of Object.keys(__classPrivateFieldGet(this, _DragManager_restrictionManager, "f").restrictions)) {
            __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").removeRestriction(token);
        }
    }
    /**
     * Set the current dragged node.
     * This will serve as the start of the drag event.
     * This function is also called internally at onDown events.
     *
     * @param node
     * @param distance
     * @param intersectionPoint
     * @param ray
     */
    setNode(node, geometryData, distance = 0, intersectionPoint = gl_matrix_1.vec3.create(), event, ray = { origin: gl_matrix_1.vec3.create(), direction: gl_matrix_1.vec3.create() }) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        if (__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            this.removeNode();
        __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").showRestrictionVisualization = true;
        __classPrivateFieldSet(this, _DragManager_draggedNode, this.activateNode({
            node,
            distance,
            point: intersectionPoint,
            geometryData: geometryData,
        }), "f");
        if (!__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            return;
        __classPrivateFieldSet(this, _DragManager_setupOptions, {
            viewport: this.viewport,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            ray,
            intersection: __classPrivateFieldGet(this, _DragManager_intersection, "f"),
        }, "f");
        const transformationResult = __classPrivateFieldGet(this, _DragManager_restrictionManager, "f").rayTrace(ray, {
            type: "dragging",
            dragAnchors: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragAnchors,
            dragOrigin: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            startPoint: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").dragOrigin,
        });
        const transformationMatrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrixInverse, (transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.transformation) || gl_matrix_1.mat4.create()), __classPrivateFieldGet(this, _DragManager_draggedNode, "f").worldMatrix);
        // apply the transformation for the main node
        this.applyTransformation(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node, transformationMatrix);
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        // and apply it for all grouped nodes
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f")) {
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => {
                this.applyTransformation(n, transformationMatrix);
                this.viewport.updateNode(n);
            });
        }
        __classPrivateFieldSet(this, _DragManager_tokenCameraFreeze, this.viewport.addFlag(viewer_1.FLAG_TYPE.CAMERA_FREEZE), "f");
        __classPrivateFieldSet(this, _DragManager_tokenContinuousRendering, this.viewport.addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_RENDERING), "f");
        __classPrivateFieldSet(this, _DragManager_tokenContinuousShadowMapUpdate, this.viewport.addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE), "f");
        __classPrivateFieldGet(this, _DragManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_START, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _DragManager_draggedNode, "f").node,
            matrix: transformationMatrix,
            intersectionPoint,
            ray,
            event,
            restriction: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.restriction,
            dragAnchor: transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.dragAnchor,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _DragManager_groupedNodes, "f"),
        });
    }
    /**
     * Utility function to make the node the current active node.
     * Set the according values, apply the effect and emit the event.
     *
     * @param intersection
     */
    activateNode(intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        __classPrivateFieldSet(this, _DragManager_intersection, intersection, "f");
        const node = __classPrivateFieldGet(this, _DragManager_intersection, "f").node;
        __classPrivateFieldSet(this, _DragManager_groupedNodes, undefined, "f");
        __classPrivateFieldSet(this, _DragManager_groupEffectMaterialToken, undefined, "f");
        // find the interaction data
        const data = this.getInteractionData(node);
        if (data)
            data.interactionStates.drag = true;
        // find and store all nodes that are within the group
        if (data && data.groupId) {
            __classPrivateFieldSet(this, _DragManager_groupedNodes, this.gatheredGroupedNodes[data.groupId] || [], "f");
            __classPrivateFieldSet(this, _DragManager_groupEffectMaterialToken, [], "f");
        }
        // remove the previous transformation of the dragged node (and all grouped within)
        const previousDragMatrix = this.removeTransformation(node);
        let invertedPreviousDragMatrix = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), previousDragMatrix);
        if (!invertedPreviousDragMatrix)
            invertedPreviousDragMatrix = gl_matrix_1.mat4.create();
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => this.removeTransformation(n));
        // store the initial world matrix and its inverse
        const worldMatrix = node.worldMatrix;
        let worldMatrixInverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), worldMatrix);
        if (!worldMatrixInverse)
            worldMatrixInverse = gl_matrix_1.mat4.create();
        // apply the effect material if there is something to apply
        if (this.effectMaterial) {
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, this.interactionEffectUtils.applyEffectMaterial(node, this.effectMaterial), "f");
            if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
                __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => __classPrivateFieldGet(this, _DragManager_groupEffectMaterialToken, "f").push(this.interactionEffectUtils.applyEffectMaterial(n, this.effectMaterial)));
        }
        else {
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, undefined, "f");
        }
        // update the node
        this.viewport.updateNode(node);
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        return {
            node,
            worldMatrix,
            worldMatrixInverse,
            previousDragMatrix,
            dragAnchors: (data === null || data === void 0 ? void 0 : data.dragAnchors) || [],
            dragOrigin: (data === null || data === void 0 ? void 0 : data.dragOrigin)
                ? gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), data.dragOrigin, node.worldMatrix)
                : gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), intersection.point, invertedPreviousDragMatrix),
        };
    }
    /**
     * Utility function to apply the transformation to the current node.
     *
     * @param node
     * @param matrix
     */
    applyTransformation(node, matrix) {
        const index = node.transformations.findIndex((t) => t.id === "SD_drag_matrix");
        if (index !== -1) {
            node.transformations[index].matrix = matrix;
        }
        else {
            node.addTransformation({ id: "SD_drag_matrix", matrix });
        }
    }
    /**
     * Utility function to make the node inactive.
     * Set the according values, remove the effect and emit the event.
     *
     * @param intersection
     */
    deactivateNode() {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _DragManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        if (!__classPrivateFieldGet(this, _DragManager_draggedNode, "f"))
            return;
        // find the interaction data
        const data = this.getInteractionData(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        if (data)
            data.interactionStates.drag = false;
        if (__classPrivateFieldGet(this, _DragManager_effectMaterialToken, "f")) {
            this.interactionEffectUtils.removeEffectMaterial(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node, __classPrivateFieldGet(this, _DragManager_effectMaterialToken, "f"));
            __classPrivateFieldSet(this, _DragManager_effectMaterialToken, undefined, "f");
            if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
                __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n, i) => this.interactionEffectUtils.removeEffectMaterial(n, __classPrivateFieldGet(this, _DragManager_groupEffectMaterialToken, "f")[i]));
            __classPrivateFieldSet(this, _DragManager_groupEffectMaterialToken, undefined, "f");
        }
        this.viewport.updateNode(__classPrivateFieldGet(this, _DragManager_draggedNode, "f").node);
        if (__classPrivateFieldGet(this, _DragManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _DragManager_groupedNodes, "f").forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        __classPrivateFieldSet(this, _DragManager_intersection, null, "f");
        __classPrivateFieldSet(this, _DragManager_draggedNode, undefined, "f");
        __classPrivateFieldSet(this, _DragManager_groupedNodes, undefined, "f");
        __classPrivateFieldSet(this, _DragManager_groupEffectMaterialToken, undefined, "f");
    }
    getInteractionData(node) {
        for (let i = 0; i < node.data.length; i++) {
            if (node.data[i] instanceof InteractionData_1.InteractionData) {
                if ((node.data[i].restrictedManagers
                    .length === 0 ||
                    (node.data[i]).restrictedManagers.includes(this.id)) &&
                    node.data[i].interactionTypes.drag)
                    return node.data[i];
            }
        }
    }
    removeTransformation(node) {
        const index = node.transformations.findIndex((t) => t.id === "SD_drag_matrix");
        if (index !== -1) {
            const matrix = gl_matrix_1.mat4.clone(node.transformations[index].matrix);
            node.removeTransformation(node.transformations[index]);
            return matrix;
        }
        return gl_matrix_1.mat4.create();
    }
}
exports.DragManager = DragManager;
_DragManager_eventEngine = new WeakMap(), _DragManager_logger = new WeakMap(), _DragManager_tree = new WeakMap(), _DragManager_uuidGenerator = new WeakMap(), _DragManager_draggedNode = new WeakMap(), _DragManager_effectMaterialToken = new WeakMap(), _DragManager_filter = new WeakMap(), _DragManager_groupEffectMaterialToken = new WeakMap(), _DragManager_groupedNodes = new WeakMap(), _DragManager_intersection = new WeakMap(), _DragManager_restrictionManager = new WeakMap(), _DragManager_setupOptions = new WeakMap(), _DragManager_tokenCameraFreeze = new WeakMap(), _DragManager_tokenContinuousRendering = new WeakMap(), _DragManager_tokenContinuousShadowMapUpdate = new WeakMap();
//# sourceMappingURL=DragManager.js.map
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HoverManager_eventEngine, _HoverManager_logger, _HoverManager_tree, _HoverManager_effectMaterialToken, _HoverManager_filter, _HoverManager_groupEffectMaterialToken, _HoverManager_groupedNodes, _HoverManager_intersection, _HoverManager_node, _HoverManager_dragEventTokenStart, _HoverManager_currentlyDragging, _HoverManager_dragEventTokenEnd;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverManager = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const IInteractionEngine_1 = require("../../interfaces/IInteractionEngine");
const AbstractInteractionManager_1 = require("../AbstractInteractionManager");
const InteractionData_1 = require("../InteractionData");
/* eslint-disable @typescript-eslint/no-unused-vars */
class HoverManager extends AbstractInteractionManager_1.AbstractInteractionManager {
    // #endregion Properties (8)
    // #region Constructors (1)
    constructor(id, effectMaterial) {
        super(id, effectMaterial);
        // #region Properties (8)
        _HoverManager_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _HoverManager_logger.set(this, viewer_shared_services_1.Logger.instance);
        _HoverManager_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _HoverManager_effectMaterialToken.set(this, void 0);
        _HoverManager_filter.set(this, (interactionState) => {
            if (interactionState === IInteractionEngine_1.INTERACTION_STATE.MOVE) {
                return (node) => {
                    return !!this.getInteractionData(node);
                };
            }
            return (node) => false;
        });
        _HoverManager_groupEffectMaterialToken.set(this, void 0);
        _HoverManager_groupedNodes.set(this, void 0);
        _HoverManager_intersection.set(this, null);
        _HoverManager_node.set(this, null);
        _HoverManager_dragEventTokenStart.set(this, void 0);
        _HoverManager_currentlyDragging.set(this, false);
        _HoverManager_dragEventTokenEnd.set(this, void 0);
        __classPrivateFieldSet(this, _HoverManager_dragEventTokenStart, (0, viewer_1.addListener)(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_START, () => {
            __classPrivateFieldSet(this, _HoverManager_currentlyDragging, true, "f");
        }), "f");
        __classPrivateFieldSet(this, _HoverManager_dragEventTokenEnd, (0, viewer_1.addListener)(viewer_shared_services_1.EVENTTYPE.INTERACTION.DRAG_END, () => {
            __classPrivateFieldSet(this, _HoverManager_currentlyDragging, false, "f");
        }), "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get filter() {
        return __classPrivateFieldGet(this, _HoverManager_filter, "f");
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (7)
    add(viewport) {
        this.viewport = viewport;
    }
    /**
     * Deselect the current node.
     */
    deselect() {
        if (__classPrivateFieldGet(this, _HoverManager_node, "f"))
            this.deactivateNode();
    }
    onDown(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _HoverManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
    }
    onEnd(event, ray, intersection, endState) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _HoverManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
    }
    onMove(event, ray, intersection) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _HoverManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        // if a node is currently being dragged, do not hover any other nodes
        if (__classPrivateFieldGet(this, _HoverManager_currentlyDragging, "f")) {
            if (__classPrivateFieldGet(this, _HoverManager_node, "f"))
                this.deactivateNode(event);
            return;
        }
        let intersections = intersection.filter((i) => this.filter(IInteractionEngine_1.INTERACTION_STATE.MOVE)(i.node));
        intersections = intersection.filter((i) => {
            const data = this.getInteractionData(i.node);
            return !(data && data.interactionStates.drag === true);
        });
        if (__classPrivateFieldGet(this, _HoverManager_node, "f")) {
            if (intersections.length > 0 &&
                intersection[0].node === __classPrivateFieldGet(this, _HoverManager_node, "f")) {
                // do nothing
            }
            else if (intersections.length > 0) {
                this.deactivateNode(event);
                this.activateNode(intersections[0], event, ray);
            }
            else {
                this.deactivateNode(event);
            }
        }
        else if (intersections.length > 0) {
            // easy case, no node hover, just hover this one
            this.activateNode(intersections[0], event, ray);
        }
    }
    remove() {
        if (__classPrivateFieldGet(this, _HoverManager_node, "f"))
            this.deactivateNode();
        this.viewport = undefined;
        (0, viewer_1.removeListener)(__classPrivateFieldGet(this, _HoverManager_dragEventTokenStart, "f"));
        (0, viewer_1.removeListener)(__classPrivateFieldGet(this, _HoverManager_dragEventTokenEnd, "f"));
    }
    /**
     * Select a node for hovering.
     * The point and distance of the intersection can be freely chosen and are provided in the event callbacks.
     *
     * @param intersection
     */
    select(intersection) {
        if (__classPrivateFieldGet(this, _HoverManager_node, "f"))
            this.deactivateNode();
        this.activateNode(intersection);
    }
    // #endregion Public Methods (7)
    // #region Private Methods (2)
    /**
     * Utility function to make the node the current active node.
     * Set the according values, apply the effect and emit the event.
     *
     * @param intersection
     * @param event
     * @param ray
     */
    activateNode(intersection, event, ray) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _HoverManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        __classPrivateFieldSet(this, _HoverManager_intersection, intersection, "f");
        __classPrivateFieldSet(this, _HoverManager_node, __classPrivateFieldGet(this, _HoverManager_intersection, "f").node, "f");
        __classPrivateFieldSet(this, _HoverManager_groupedNodes, undefined, "f");
        __classPrivateFieldSet(this, _HoverManager_groupEffectMaterialToken, undefined, "f");
        // find the interaction data
        const data = this.getInteractionData(__classPrivateFieldGet(this, _HoverManager_node, "f"));
        if (data)
            data.interactionStates.hover = true;
        // find and store all nodes that are within the group
        if (data && data.groupId) {
            __classPrivateFieldSet(this, _HoverManager_groupedNodes, this.gatheredGroupedNodes[data.groupId] || [], "f");
            __classPrivateFieldSet(this, _HoverManager_groupEffectMaterialToken, [], "f");
        }
        // apply the effect material if there is something to apply
        if (this.effectMaterial) {
            __classPrivateFieldSet(this, _HoverManager_effectMaterialToken, this.interactionEffectUtils.applyEffectMaterial(__classPrivateFieldGet(this, _HoverManager_node, "f"), this.effectMaterial), "f");
            if (__classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"))
                __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f").forEach((n) => __classPrivateFieldGet(this, _HoverManager_groupEffectMaterialToken, "f").push(this.interactionEffectUtils.applyEffectMaterial(n, this.effectMaterial)));
        }
        else {
            __classPrivateFieldSet(this, _HoverManager_effectMaterialToken, undefined, "f");
        }
        this.viewport.updateNode(__classPrivateFieldGet(this, _HoverManager_node, "f"));
        if (__classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f").forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        __classPrivateFieldGet(this, _HoverManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.HOVER_ON, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _HoverManager_node, "f"),
            intersectionPoint: __classPrivateFieldGet(this, _HoverManager_intersection, "f").point,
            ray,
            event,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"),
        });
    }
    /**
     * Utility function to make the node inactive.
     * Set the according values, remove the effect and emit the event.
     *
     * @param event
     */
    deactivateNode(event) {
        if (!this.viewport) {
            __classPrivateFieldGet(this, _HoverManager_logger, "f").warn("The interaction manager does not belong to an interaction engine. Please add it to one first.");
            return;
        }
        // find the interaction data
        const data = this.getInteractionData(__classPrivateFieldGet(this, _HoverManager_node, "f"));
        if (data)
            data.interactionStates.hover = false;
        if (__classPrivateFieldGet(this, _HoverManager_effectMaterialToken, "f")) {
            this.interactionEffectUtils.removeEffectMaterial(__classPrivateFieldGet(this, _HoverManager_node, "f"), __classPrivateFieldGet(this, _HoverManager_effectMaterialToken, "f"));
            __classPrivateFieldSet(this, _HoverManager_effectMaterialToken, undefined, "f");
            if (__classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"))
                __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f").forEach((n, i) => this.interactionEffectUtils.removeEffectMaterial(n, __classPrivateFieldGet(this, _HoverManager_groupEffectMaterialToken, "f")[i]));
            __classPrivateFieldSet(this, _HoverManager_groupEffectMaterialToken, undefined, "f");
        }
        this.viewport.updateNode(__classPrivateFieldGet(this, _HoverManager_node, "f"));
        if (__classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"))
            __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f").forEach((n) => this.viewport.updateNode(n));
        this.viewport.render();
        __classPrivateFieldGet(this, _HoverManager_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE.INTERACTION.HOVER_OFF, {
            viewportId: this.viewport.id,
            node: __classPrivateFieldGet(this, _HoverManager_node, "f"),
            event,
            manager: this,
            groupedNodes: __classPrivateFieldGet(this, _HoverManager_groupedNodes, "f"),
        });
        __classPrivateFieldSet(this, _HoverManager_intersection, null, "f");
        __classPrivateFieldSet(this, _HoverManager_node, null, "f");
        __classPrivateFieldSet(this, _HoverManager_groupedNodes, undefined, "f");
        __classPrivateFieldSet(this, _HoverManager_groupEffectMaterialToken, undefined, "f");
    }
    getInteractionData(node) {
        for (let i = 0; i < node.data.length; i++) {
            if (node.data[i] instanceof InteractionData_1.InteractionData) {
                if ((node.data[i].restrictedManagers
                    .length === 0 ||
                    (node.data[i]).restrictedManagers.includes(this.id)) &&
                    node.data[i].interactionTypes.hover)
                    return node.data[i];
            }
        }
    }
}
exports.HoverManager = HoverManager;
_HoverManager_eventEngine = new WeakMap(), _HoverManager_logger = new WeakMap(), _HoverManager_tree = new WeakMap(), _HoverManager_effectMaterialToken = new WeakMap(), _HoverManager_filter = new WeakMap(), _HoverManager_groupEffectMaterialToken = new WeakMap(), _HoverManager_groupedNodes = new WeakMap(), _HoverManager_intersection = new WeakMap(), _HoverManager_node = new WeakMap(), _HoverManager_dragEventTokenStart = new WeakMap(), _HoverManager_currentlyDragging = new WeakMap(), _HoverManager_dragEventTokenEnd = new WeakMap();
//# sourceMappingURL=HoverManager.js.map
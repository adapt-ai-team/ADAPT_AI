"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntersectionManager = void 0;
const viewer_rendering_engine_intersection_engine_1 = require("@shapediver/viewer.rendering-engine.intersection-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const InteractionData_1 = require("./InteractionData");
class IntersectionManager {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor() {
        // #region Properties (5)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._intersectionEngine = viewer_rendering_engine_intersection_engine_1.IntersectionEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._intersectNodes = [];
        this.gatherNodes();
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => {
            this.gatherNodes();
        });
    }
    // #endregion Constructors (1)
    // #region Public Static Getters And Setters (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Getters And Setters (1)
    // #region Public Methods (1)
    intersect(ray, viewportId, filterCriteria = [], rayCasterParams) {
        let intersections = [];
        // intersect all nodes
        this._intersectNodes.forEach((i) => {
            const currentIntersection = this._intersectionEngine.intersectNode(ray, i.node, i.geometryData, viewportId, filterCriteria, rayCasterParams);
            if (currentIntersection)
                intersections = intersections.concat(currentIntersection);
        });
        intersections.sort((a, b) => {
            const distanceDiff = a.distance - b.distance;
            if (distanceDiff !== 0)
                return distanceDiff;
            // if the distance is the same, sort by the closest InteractionData within the sceneTree
            let depthA = -1;
            let depthB = -1;
            const computeDepth = (targetNode, node, depth = 0) => {
                if (targetNode === node)
                    return depth;
                if (node.parent)
                    return computeDepth(targetNode, node.parent, depth + 1);
                return -1;
            };
            if (a.geometryData) {
                a.node.traverse((node) => {
                    if (a.geometryData && node.data.includes(a.geometryData))
                        depthA = computeDepth(a.node, node);
                });
            }
            if (b.geometryData) {
                b.node.traverse((node) => {
                    if (b.geometryData && node.data.includes(b.geometryData))
                        depthB = computeDepth(b.node, node);
                });
            }
            return depthA - depthB;
        });
        return intersections;
    }
    // #endregion Public Methods (1)
    // #region Private Methods (1)
    gatherNodes() {
        this._intersectNodes = [];
        this._tree.root.traverse((node) => {
            if (node.visible === false)
                return;
            if (node.intersectionTest === false)
                return;
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof InteractionData_1.InteractionData) {
                    const geometryData = {};
                    node.traverseData((d) => {
                        if (d instanceof viewer_shared_types_1.GeometryData) {
                            geometryData[`${d.id}_${d.version}`] = d;
                        }
                    });
                    this._intersectNodes.push({
                        node: node,
                        geometryData: geometryData,
                    });
                }
            }
        });
    }
}
exports.IntersectionManager = IntersectionManager;
//# sourceMappingURL=IntersectionManager.js.map
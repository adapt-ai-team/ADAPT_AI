import { DraggingParameterValue, ISessionApi, ITreeNode } from "@shapediver/viewer";
import { vec3 } from "gl-matrix";
/**
 * Type declaration for a filter pattern used to hierarchically filter nodes of the scene tree by name.
 */
export declare type NodeNameFilterPattern = string[];
/**
 * Dictionary type declaration for filter patterns used to filter nodes of the scene tree by name.
 * The dictionary keys correspond to the IDs of outputs of a ShapeDiver model.
 * The dictionary values are arrays of patterns for hierarchical matching of node names of the output.
 * Each pattern is defined by an array of strings, which represent regular expressions
 * that are applied to nodes of the hierarchy.
 *
 * Example (simplified, disregarding the regular expression syntax):
 * ```json
 * {
 *    "OUTPUT_ID": [
 * 	 	["Node_a", "Node_b"], // matches nodes with the name "Node_a.Node_b" in the output with the ID "OUTPUT_ID"
 * 	 	["Node_a", "Node_c"], // matches nodes with the name "Node_a.Node_c" in the output with the ID "OUTPUT_ID"
 * 	 	["Node_a", "Node_d", "Node_e"] // matches nodes with the name "Node_a.Node_d.Node_e" in the output with the ID "OUTPUT_ID"
 *   ]
 * }
 *
 */
export declare type OutputNodeNameFilterPatterns = {
    [outputId: string]: NodeNameFilterPattern[];
};
/**
 * Recurse the scene tree downwards starting from the given node, gather all nodes that match the pattern,
 * and add them to the result array.
 *
 * @param node The node to start traversing from. Typically this is the node of an output of a ShapeDiver model.
 * @param pattern The hierarchical pattern to check for.
 *                Each string of the pattern represents a regular expression for matching the node name.
 * @param outputApiName The name of the output API to be used for the concatenated node name.
 * @param result The result object, matching nodes will be added here.
 * @param count The current index into the pattern array.
 */
export declare const gatherNodesForPattern: (node: ITreeNode, pattern: NodeNameFilterPattern, outputApiName: string, result: {
    [nodeId: string]: {
        node: ITreeNode;
        name: string;
    };
}, count?: number, strictNaming?: boolean) => void;
/**
 * Convert the user-defined name-filters to filter patterns as used by useNodeInteractionData.
 *
 * The name filter is an array of dot-separated strings.
 * Each string represents a pattern to hierarchically match node names.
 * The first part of the pattern is the output name.
 * The rest of the pattern correspond to hierarchical node names, which may contain the "*"
 * character as a wildcard to match any node name or any part of the node name.
 *
 * @param nameFilter The user-defined name filters to convert.
 * @param outputIdsToNamesMapping A mapping of output IDs to output names for the session to be used.
 *
 * @returns The filter pattern object to be used with useNodeInteractionData, useSelection, and other interaction hooks.
 */
export declare const convertUserDefinedNameFilters: (nameFilter: string[], outputIdsToNamesMapping: {
    [key: string]: string;
}) => OutputNodeNameFilterPatterns;
/**
 * Convert the user-defined name-filters to filter patterns as used by useNodeInteractionData.
 *
 * The name filter is an array of dot-separated strings.
 * Each string represents a pattern to hierarchically match node names.
 * The first part of the pattern is the instance ID.
 * The rest of the pattern correspond to hierarchical node names, which may contain the "*"
 * character as a wildcard to match any node name or any part of the node name.
 *
 * @param nameFilter The user-defined name filters to convert.
 * @param instanceIds The IDs of the instances to be used.
 *
 * @returns The filter pattern object to be used with useNodeInteractionData, useSelection, and other interaction hooks.
 */
export declare const convertUserDefinedNameFiltersForInstances: (nameFilter: string[], instanceIds: string[]) => OutputNodeNameFilterPatterns;
/**
 * Traverse the node hierarchy upwards to find the node that corresponds to an output
 * of the ShapeDiver model.
 * Return the node itself, the corresponding output id and name, and the original names
 * concatenated using dots.
 *
 * @param node The node to start the upwards traversal from.
 * @returns
 */
export declare const getNodeData: (node: ITreeNode, strictNaming?: boolean) => {
    outputId: string;
    outputName?: string;
    nodeName: string;
} | undefined;
/**
 * Traverse the node hierarchy upwards to find the node that corresponds to an instance node.
 * Return the instance id, and the original names concatenated using dots.
 *
 * We know that it is an instance node if it has a session API data in its parent.
 * We return the instanceId as the outputId to be used in the other functions.
 *
 * @param node
 * @param strictNaming
 * @returns
 */
export declare const getInstanceNodeData: (node: ITreeNode, strictNaming?: boolean) => {
    outputId: string;
    nodeName: string;
} | undefined;
/**
 * Try to match the given nodes with the patterns.
 * For matching nodes, return the concatenated names of the nodes as required
 * for setting values of interaction parameters.
 *
 * @param patterns The patterns to match the node names.
 * @param nodes The nodes to process.
 * @returns The concatenated names of the nodes that match the pattern.
 */
export declare const matchNodesWithPatterns: (patterns: OutputNodeNameFilterPatterns, nodes: ITreeNode[], strictNaming?: boolean) => string[];
/**
 * Add interaction data to the node.
 *
 * If the node already has interaction data, the function will remove the interaction data and add the new interaction data.
 * Then the function will update the version of the node.
 *
 * @param node
 * @param interactionDataSettings
 */
export declare const addInteractionData: (node: ITreeNode, interactionDataSettings: {
    select?: boolean;
    hover?: boolean;
    drag?: boolean;
    dragOrigin?: vec3;
    dragAnchors?: {
        id: string;
        position: vec3;
        rotation?: {
            angle: number;
            axis: vec3;
        };
    }[];
}, componentId: string) => void;
/**
 * Get the nodes within the session API by their names.
 *
 * @param sessionApi The session API.
 * @param names The names of the nodes.
 * @returns
 */
export declare const getNodesByName: (sessionApis: ISessionApi[], names: string[], strictNaming?: boolean) => {
    name: string;
    node: ITreeNode;
}[];
export declare const calculateCombinedDraggedNodes: (currentState: DraggingParameterValue["objects"], draggedNodes: DraggingParameterValue["objects"]) => DraggingParameterValue["objects"];
/**
 * This function checks if the name of the node matches the given name.
 * The name is provided without the display component in the beginning.
 * It is assumed that the node is in the correct display component.
 *
 * @param node
 * @param nameWithoutDisplayComponent
 */
export declare const checkNodeNameMatch: (node: ITreeNode, nameWithoutDisplayComponent: string, strictNaming?: boolean) => boolean;
//# sourceMappingURL=PatternUtils.d.ts.map
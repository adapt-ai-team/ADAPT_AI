"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InteractionEffectUtils_uuidGenerator;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionEffectUtils = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
class InteractionEffectUtils {
    constructor() {
        // #region Properties (2)
        _InteractionEffectUtils_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        // #endregion Public Methods (2)
    }
    // #endregion Properties (2)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (2)
    /**
     * Apply the effect material to the node and all descendents.
     *
     * @param node
     * @param material
     * @returns
     */
    applyEffectMaterial(node, material) {
        const token = __classPrivateFieldGet(this, _InteractionEffectUtils_uuidGenerator, "f").create();
        const applyEffect = (node) => {
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometryData = node.data[i];
                    geometryData.effectMaterials.push({ material, token });
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                applyEffect(node.children[i]);
            }
        };
        applyEffect(node);
        return token;
    }
    /**
     * Remove the effect material with the specified token from the node and all descendents.
     *
     * @param node
     * @param token
     */
    removeEffectMaterial(node, token) {
        const removeEffect = (node) => {
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometryData = node.data[i];
                    const index = geometryData.effectMaterials.findIndex((e) => e.token === token);
                    if (index !== -1)
                        geometryData.effectMaterials.splice(index, 1);
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                removeEffect(node.children[i]);
            }
        };
        removeEffect(node);
    }
}
exports.InteractionEffectUtils = InteractionEffectUtils;
_InteractionEffectUtils_uuidGenerator = new WeakMap();
//# sourceMappingURL=InteractionEffectUtils.js.map
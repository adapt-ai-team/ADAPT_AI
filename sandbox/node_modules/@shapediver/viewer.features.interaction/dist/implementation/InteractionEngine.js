"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InteractionEngine_canvasEventListenerToken, _InteractionEngine_eventEngine, _InteractionEngine_intersectionManager, _InteractionEngine_managers, _InteractionEngine_rayCasterParams, _InteractionEngine_uuidGenerator, _InteractionEngine_viewport, _InteractionEngine_closed, _InteractionEngine_intersectionOpacity, _InteractionEngine_lineIntersectionPercentage, _InteractionEngine_pointIntersectionPercentage, _InteractionEngine_sceneBoundingSphereRadius, _InteractionEngine_sceneBoundingBoxChangeToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionEngine = void 0;
const viewer_1 = require("@shapediver/viewer");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const IInteractionEngine_1 = require("../interfaces/IInteractionEngine");
const IntersectionManager_1 = require("./IntersectionManager");
// #endregion Interfaces (1)
// #region Classes (1)
class InteractionEngine {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(viewport, props) {
        // #region Properties (12)
        _InteractionEngine_canvasEventListenerToken.set(this, void 0);
        _InteractionEngine_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _InteractionEngine_intersectionManager.set(this, IntersectionManager_1.IntersectionManager.instance);
        _InteractionEngine_managers.set(this, {});
        _InteractionEngine_rayCasterParams.set(this, {
            Line: { threshold: 1 },
            Line2: { threshold: 1 },
            Points: { threshold: 1 },
            Mesh: {},
            LOD: {},
            Sprite: {},
        });
        _InteractionEngine_uuidGenerator.set(this, viewer_shared_services_1.UuidGenerator.instance);
        _InteractionEngine_viewport.set(this, void 0);
        _InteractionEngine_closed.set(this, false);
        _InteractionEngine_intersectionOpacity.set(this, 0);
        _InteractionEngine_lineIntersectionPercentage.set(this, 0.025);
        _InteractionEngine_pointIntersectionPercentage.set(this, 0.025);
        _InteractionEngine_sceneBoundingSphereRadius.set(this, 0);
        _InteractionEngine_sceneBoundingBoxChangeToken.set(this, "");
        __classPrivateFieldSet(this, _InteractionEngine_viewport, viewport, "f");
        __classPrivateFieldSet(this, _InteractionEngine_canvasEventListenerToken, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").addCanvasEventListener(this), "f");
        if (props) {
            if (props.intersectionOpacity !== undefined)
                __classPrivateFieldSet(this, _InteractionEngine_intersectionOpacity, props.intersectionOpacity, "f");
            if (props.lineIntersectionPercentage !== undefined)
                __classPrivateFieldSet(this, _InteractionEngine_lineIntersectionPercentage, props.lineIntersectionPercentage, "f");
            if (props.pointIntersectionPercentage !== undefined)
                __classPrivateFieldSet(this, _InteractionEngine_pointIntersectionPercentage, props.pointIntersectionPercentage, "f");
        }
        /**
         * When the scene bounding box changes, the intersection thresholds need to be updated.
         * We do this by listening to the scene bounding box change event.
         * In the beginning, we set the scene bounding sphere radius to the root bounding box.
         * This is the initial value and will be updated when the scene bounding box changes.
         * The intersection thresholds are then updated accordingly.
         */
        __classPrivateFieldSet(this, _InteractionEngine_sceneBoundingSphereRadius, viewer_1.sceneTree.root.boundingBox.boundingSphere.radius, "f");
        this.updateIntersectionThresholds();
        __classPrivateFieldSet(this, _InteractionEngine_sceneBoundingBoxChangeToken, __classPrivateFieldGet(this, _InteractionEngine_eventEngine, "f").addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const event = e;
            if (event.viewportId === __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id) {
                const boundingBox = new viewer_shared_math_1.Box(event.boundingBox.min, event.boundingBox.max);
                __classPrivateFieldSet(this, _InteractionEngine_sceneBoundingSphereRadius, boundingBox.boundingSphere.radius, "f");
                this.updateIntersectionThresholds();
            }
        }), "f");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (7)
    get closed() {
        return __classPrivateFieldGet(this, _InteractionEngine_closed, "f");
    }
    get intersectionOpacity() {
        return __classPrivateFieldGet(this, _InteractionEngine_intersectionOpacity, "f");
    }
    set intersectionOpacity(value) {
        __classPrivateFieldSet(this, _InteractionEngine_intersectionOpacity, value, "f");
    }
    get lineIntersectionPercentage() {
        return __classPrivateFieldGet(this, _InteractionEngine_lineIntersectionPercentage, "f");
    }
    set lineIntersectionPercentage(value) {
        __classPrivateFieldSet(this, _InteractionEngine_lineIntersectionPercentage, value, "f");
        this.updateIntersectionThresholds();
    }
    get managers() {
        return __classPrivateFieldGet(this, _InteractionEngine_managers, "f");
    }
    get pointIntersectionPercentage() {
        return __classPrivateFieldGet(this, _InteractionEngine_pointIntersectionPercentage, "f");
    }
    set pointIntersectionPercentage(value) {
        __classPrivateFieldSet(this, _InteractionEngine_pointIntersectionPercentage, value, "f");
        this.updateIntersectionThresholds();
    }
    // #endregion Public Getters And Setters (7)
    // #region Public Methods (11)
    addInteractionManager(manager) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError("The InteractionEngine has already been closed.");
        const token = __classPrivateFieldGet(this, _InteractionEngine_uuidGenerator, "f").create();
        __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token] = manager;
        manager.add(__classPrivateFieldGet(this, _InteractionEngine_viewport, "f"));
        return token;
    }
    close() {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError("The InteractionEngine has already been closed.");
        __classPrivateFieldGet(this, _InteractionEngine_eventEngine, "f").removeListener(__classPrivateFieldGet(this, _InteractionEngine_sceneBoundingBoxChangeToken, "f"));
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            this.removeInteractionManager(m);
        __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").removeCanvasEventListener(__classPrivateFieldGet(this, _InteractionEngine_canvasEventListenerToken, "f"));
        __classPrivateFieldSet(this, _InteractionEngine_closed, true, "f");
    }
    onKeyDown(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onKeyUp(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onMouseWheel(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onPointerDown(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").pointerEventToRay(event);
        this.onDown(event, ray);
    }
    onPointerEnd(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
    }
    onPointerMove(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").pointerEventToRay(event);
        this.onMove(event, ray);
    }
    onPointerOut(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").pointerEventToRay(event);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.OUT);
    }
    onPointerUp(event) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            return;
        const ray = __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").pointerEventToRay(event);
        this.onEnd(event, ray, IInteractionEngine_1.INTERACTION_STATE.UP);
    }
    removeInteractionManager(token) {
        if (__classPrivateFieldGet(this, _InteractionEngine_closed, "f"))
            throw new viewer_shared_services_1.ShapeDiverViewerInteractionError("The InteractionEngine has already been closed.");
        if (!__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token])
            return false;
        __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token].remove();
        delete __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[token];
        return true;
    }
    // #endregion Public Methods (11)
    // #region Private Methods (4)
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onDown(event, ray) {
        const filters = [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.DOWN));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionManager, "f").intersect(ray, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id, filters, __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f")) || [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onDown(event, ray, intersections);
    }
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onEnd(event, ray, endState) {
        const filters = [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(endState));
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.END));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionManager, "f").intersect(ray, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id, filters, __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f")) || [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onEnd(event, ray, intersections, endState);
    }
    /**
     * Apply all filters for the intersection of the scene.
     * Call all according interaction managers with the results.
     *
     * @param ray
     */
    onMove(event, ray) {
        const filters = [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            filters.push(__classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].filter(IInteractionEngine_1.INTERACTION_STATE.MOVE));
        const intersections = __classPrivateFieldGet(this, _InteractionEngine_intersectionManager, "f").intersect(ray, __classPrivateFieldGet(this, _InteractionEngine_viewport, "f").id, filters, __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f")) || [];
        for (const m in __classPrivateFieldGet(this, _InteractionEngine_managers, "f"))
            __classPrivateFieldGet(this, _InteractionEngine_managers, "f")[m].onMove(event, ray, intersections);
    }
    updateIntersectionThresholds() {
        __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f").Points.threshold =
            __classPrivateFieldGet(this, _InteractionEngine_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _InteractionEngine_pointIntersectionPercentage, "f");
        __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f").Line.threshold =
            __classPrivateFieldGet(this, _InteractionEngine_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _InteractionEngine_lineIntersectionPercentage, "f");
        __classPrivateFieldGet(this, _InteractionEngine_rayCasterParams, "f").Line2.threshold =
            __classPrivateFieldGet(this, _InteractionEngine_sceneBoundingSphereRadius, "f") * __classPrivateFieldGet(this, _InteractionEngine_lineIntersectionPercentage, "f");
    }
}
exports.InteractionEngine = InteractionEngine;
_InteractionEngine_canvasEventListenerToken = new WeakMap(), _InteractionEngine_eventEngine = new WeakMap(), _InteractionEngine_intersectionManager = new WeakMap(), _InteractionEngine_managers = new WeakMap(), _InteractionEngine_rayCasterParams = new WeakMap(), _InteractionEngine_uuidGenerator = new WeakMap(), _InteractionEngine_viewport = new WeakMap(), _InteractionEngine_closed = new WeakMap(), _InteractionEngine_intersectionOpacity = new WeakMap(), _InteractionEngine_lineIntersectionPercentage = new WeakMap(), _InteractionEngine_pointIntersectionPercentage = new WeakMap(), _InteractionEngine_sceneBoundingSphereRadius = new WeakMap(), _InteractionEngine_sceneBoundingBoxChangeToken = new WeakMap();
// #endregion Classes (1)
//# sourceMappingURL=InteractionEngine.js.map
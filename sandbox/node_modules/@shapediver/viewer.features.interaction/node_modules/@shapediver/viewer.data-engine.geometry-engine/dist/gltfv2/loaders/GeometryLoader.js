"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryLoader = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const GLTFLoader_1 = require("../GLTFLoader");
class GeometryLoader {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(_content, _accessorLoader, _bufferViewLoader, _materialLoader, _dracoModule) {
        this._content = _content;
        this._accessorLoader = _accessorLoader;
        this._bufferViewLoader = _bufferViewLoader;
        this._materialLoader = _materialLoader;
        this._dracoModule = _dracoModule;
        // #region Properties (1)
        this._logger = viewer_shared_services_1.Logger.instance;
        this._materialVariantsData = new viewer_shared_types_1.MaterialVariantsData();
        this._loaded = {};
    }
    // #endregion Constructors (1)
    // #region Public Accessors (1)
    get materialVariantsData() {
        return this._materialVariantsData;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (1)
    loadMesh(meshId, weights, instanceTransformations = []) {
        if (!this._content.meshes)
            throw new Error("GeometryLoader.loadMesh: Meshes not available.");
        if (!this._content.meshes[meshId])
            throw new Error("GeometryLoader.loadMesh: Mesh not available.");
        const mesh = this._content.meshes[meshId];
        const meshNode = new viewer_shared_node_tree_1.TreeNode(mesh.name || "mesh_" + meshId);
        meshNode.originalName = mesh.name;
        if (instanceTransformations.length > 0)
            meshNode.addData(new viewer_shared_types_1.InstanceData(instanceTransformations));
        if (mesh.primitives)
            for (let i = 0, len = mesh.primitives.length; i < len; i++)
                meshNode.addChild(this.loadPrimitive(meshId, mesh.primitives, i, mesh.weights || weights));
        return meshNode;
    }
    // #endregion Public Methods (1)
    // #region Private Methods (1)
    /**
     * Check if the material has maps defined and if so, if there are texture coordinates available. If not, remove all maps from the material.
     * Otherwise, return the material as is.
     *
     * @param attributes
     * @param material
     * @returns
     */
    cleanMaterial(attributes, material) {
        // check if the material has maps defined
        let hasMaps = false;
        if (material) {
            for (const key in material) {
                if (material[key] instanceof
                    viewer_shared_types_1.MapData) {
                    hasMaps = true;
                    break;
                }
            }
        }
        // check if there are texture coordinates available
        let hasTexCoords = false;
        for (const key in attributes) {
            if (key.includes("TEXCOORD")) {
                hasTexCoords = true;
                break;
            }
        }
        // if there are maps but no texture coordinates, remove all maps from the material
        let assignedMaterial = material;
        if (material && hasMaps === true && hasTexCoords === false) {
            this._logger.warn("GeometryLoader.loadPrimitive: Material has maps but no texture coordinates are defined. Removing all maps from material.");
            assignedMaterial = material.clone();
            for (const key in assignedMaterial) {
                if (assignedMaterial[key] instanceof viewer_shared_types_1.MapData)
                    assignedMaterial[key] = undefined;
            }
        }
        return assignedMaterial;
    }
    loadPrimitive(meshId, primitives, index, weights = []) {
        const primitive = primitives[index];
        const primitiveNode = new viewer_shared_node_tree_1.TreeNode("primitive_" + index);
        if (this._loaded["mesh_" + meshId + "_primitive_" + index]) {
            primitiveNode.data.push(this._loaded["mesh_" + meshId + "_primitive_" + index].clone());
            return primitiveNode;
        }
        const attributes = {};
        let indices = null;
        const convertedNames = {};
        if (primitive.extensions &&
            primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            const dracoDef = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
            const arrayBuffer = this._bufferViewLoader.getBufferView(dracoDef.bufferView);
            const decoder = new this._dracoModule.Decoder();
            const array = new Int8Array(arrayBuffer);
            const geometryType = decoder.GetEncodedGeometryType(array);
            let dracoGeometry;
            if (geometryType === this._dracoModule.TRIANGULAR_MESH) {
                dracoGeometry = new this._dracoModule.Mesh();
                decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
            }
            else if (geometryType === this._dracoModule.POINT_CLOUD) {
                dracoGeometry = new this._dracoModule.PointCloud();
                decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
            }
            if (dracoDef.attributes["POSITION"] === undefined) {
                const errorMsg = "No position attribute found in the mesh.";
                this._dracoModule.destroy(decoder);
                this._dracoModule.destroy(dracoGeometry);
                throw new Error(errorMsg);
            }
            for (const a in dracoDef.attributes) {
                const attribute = decoder.GetAttributeByUniqueId(dracoGeometry, dracoDef.attributes[a]);
                const attributeData = new this._dracoModule.DracoFloat32Array();
                decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
                const byteOffset = attribute.byte_offset();
                const normalized = attribute.normalized();
                const numComponents = attribute.num_components();
                const numPoints = dracoGeometry.num_points();
                const numValues = numPoints * numComponents;
                const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;
                const ptr = this._dracoModule._malloc(byteLength);
                decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, this._dracoModule.DT_FLOAT32, byteLength, ptr);
                const array = new Float32Array(this._dracoModule.HEAPF32.buffer, ptr, numValues).slice();
                this._dracoModule._free(ptr);
                if (a.includes("COLOR"))
                    array.forEach((n, i) => (array[i] = Math.max(0, Math.min(1, n))));
                attributes[a] = new viewer_shared_types_1.AttributeData(array, numComponents, // itemSize
                array.BYTES_PER_ELEMENT * numComponents, // itemBytes = elementBytes * itemSize
                byteOffset, // byteOffset
                array.BYTES_PER_ELEMENT, // elementBytes
                normalized, // normalized
                array.length / numComponents);
            }
            if (geometryType == this._dracoModule.TRIANGULAR_MESH) {
                const numFaces = dracoGeometry.num_faces();
                const numIndices = numFaces * 3;
                const byteLength = numIndices * 4;
                const ptr = this._dracoModule._malloc(byteLength);
                decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
                const indexArray = new Uint32Array(this._dracoModule.HEAPF32.buffer, ptr, numIndices).slice();
                this._dracoModule._free(ptr);
                indices = new viewer_shared_types_1.AttributeData(indexArray, 1, // itemSize
                indexArray.BYTES_PER_ELEMENT * 1, // itemBytes = elementBytes * itemSize
                0, // byteOffset
                indexArray.BYTES_PER_ELEMENT, // elementBytes
                false, // normalized
                indexArray.length);
            }
            this._dracoModule.destroy(decoder);
            this._dracoModule.destroy(dracoGeometry);
        }
        for (const attribute in primitive.attributes) {
            if (attributes[attribute]) {
                convertedNames[attribute] = attribute;
                continue;
            }
            let attributeName = attribute;
            // attribute name conversion to be consistent with gltf
            if (/\d/.test(attributeName) && !attributeName.includes("_")) {
                const index = attributeName.search(/\d/);
                attributeName =
                    attributeName.substring(0, index) +
                        "_" +
                        attributeName.substring(index, attributeName.length);
            }
            else if (attributeName === "TEXCOORD" ||
                attributeName === "COLOR" ||
                attributeName === "JOINTS" ||
                attributeName === "WEIGHTS") {
                attributeName += "_0";
            }
            else if (attributeName === "UV") {
                attributeName = "TEXCOORD_0";
            }
            convertedNames[attribute] = attributeName;
            const accessor = this._accessorLoader.getAccessor(primitive.attributes[attribute]);
            if (accessor)
                attributes[attributeName] = accessor;
        }
        if ((primitive.indices || primitive.indices === 0) && !indices) {
            const accessor = this._accessorLoader.getAccessor(primitive.indices);
            if (accessor)
                indices = accessor;
        }
        // reading and assigning morph targets
        if (primitive.targets) {
            for (let i = 0; i < primitive.targets.length; i++) {
                for (const target in primitive.targets[i]) {
                    if (!attributes[target])
                        continue;
                    const accessor = this._accessorLoader.getAccessor(primitive.targets[i][target]);
                    if (accessor)
                        attributes[convertedNames[target]].morphAttributeData.push(accessor);
                }
            }
        }
        let material = null;
        if (primitive.material || primitive.material === 0)
            material = this._materialLoader.getMaterial(primitive.material);
        // if there are no attributes, return a primitive node without geometry data
        if (Object.values(attributes).length === 0) {
            this._logger.warn("GeometryLoader.loadPrimitive: No attributes found. Primitive will be ignored.");
            return primitiveNode;
        }
        // check if the material has maps defined and if so, if there are texture coordinates available
        const assignedMaterial = this.cleanMaterial(attributes, material);
        const primitiveData = new viewer_shared_types_1.PrimitiveData(attributes, indices);
        const geometryData = new viewer_shared_types_1.GeometryData(primitiveData, primitive.mode, assignedMaterial);
        if (primitive.extensions &&
            primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {
            this._materialVariantsData.geometryData.push(geometryData);
            const variantsExtension = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS];
            for (let i = 0; i < variantsExtension.mappings.length; i++) {
                const mapping = variantsExtension.mappings[i];
                const material = this._materialLoader.getMaterial(mapping.material);
                for (let j = 0; j < mapping.variants.length; j++)
                    geometryData.materialVariants.push({
                        variant: mapping.variants[j],
                        material,
                    });
            }
        }
        geometryData.morphWeights = weights;
        this._loaded["mesh_" + meshId + "_primitive_" + index] = geometryData;
        primitiveNode.data.push(geometryData);
        return primitiveNode;
    }
}
exports.GeometryLoader = GeometryLoader;
//# sourceMappingURL=GeometryLoader.js.map
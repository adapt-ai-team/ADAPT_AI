"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputLoader = void 0;
const viewer_shared_global_access_objects_1 = require("@shapediver/viewer.shared.global-access-objects");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const OutputDelayException_1 = require("./OutputDelayException");
const SessionOutputData_1 = require("./SessionOutputData");
const SessionTreeNode_1 = require("./SessionTreeNode");
// #endregion Type aliases (1)
// #region Classes (1)
class OutputLoader {
    // #endregion Properties (6)
    // #region Constructors (1)
    /**
     * The output loader takes care of loading the outputs of a session, storing them and returning stored or newly loaded nodes.
     *
     * @param _session the session for this output loader
     */
    constructor(_sessionEngine) {
        this._sessionEngine = _sessionEngine;
        // #region Properties (6)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._globalAccessObjects = viewer_shared_global_access_objects_1.GlobalAccessObjects.instance;
        this._lastOutputNodes = {};
        this._loadedOutputNodes = {};
        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;
        this._reloadSdtf = false;
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    set reloadSdtf(value) {
        this._reloadSdtf = value;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (2)
    getCurrentOutputVersions() {
        const versions = {};
        for (const o in this._lastOutputNodes)
            versions[o] = Object.keys(this._lastOutputNodes[o])[0];
        return versions;
    }
    /**
     * Load the outputs and return the scene graph node of the result.
     * In case the outputs have a delay property, it throws an OutputDelayException.
     *
     * @param outputs the outputs to load
     * @returns promise with a scene graph node
     */
    loadOutputs(nodeName, outputs, outputsFreeze, taskEventInfo, throwDelay = true, cloneNodes = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection("outputLoading");
            const node = new SessionTreeNode_1.SessionTreeNode(nodeName);
            const currentNodes = {};
            const outputInfo = {};
            const promises = [];
            const promisesNodes = [];
            let maxDelay = 0;
            const progress = {};
            const outputIDs = Object.keys(outputs);
            const cb = (e) => {
                const taskEvent = e;
                if (outputIDs.find((oId) => taskEvent.id.startsWith(oId))) {
                    progress[taskEvent.id] = taskEvent.progress;
                    let sum = 0;
                    Object.values(progress).forEach((p) => {
                        sum += p;
                    });
                    const outputLoadingProgress = (taskEventInfo.progressRange.max -
                        taskEventInfo.progressRange.min) *
                        (sum / outputIDs.length) +
                        taskEventInfo.progressRange.min;
                    const eventProgressUpdate = {
                        type: taskEventInfo.type,
                        id: taskEventInfo.eventId,
                        progress: outputLoadingProgress,
                        data: taskEventInfo.data,
                        status: "Output content loading progress.",
                    };
                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressUpdate);
                }
            };
            const listenerTokens = [];
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, cb));
            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, cb));
            for (const outputID in outputs) {
                // we store some necessary information as this data may have been changed after the await (see warning below)
                outputInfo[outputID] = {
                    version: outputs[outputID].version,
                    contentFormat: outputs[outputID].content
                        ? outputs[outputID].content.map((c) => c.format)
                        : [],
                };
                currentNodes[outputID] = {};
                if (!this._loadedOutputNodes[outputID])
                    this._loadedOutputNodes[outputID] = {};
                if (this._reloadSdtf && outputs[outputID].content) {
                    const sdtfContents = (_a = outputs[outputID].content) === null || _a === void 0 ? void 0 : _a.filter((c) => c.format === "sdtf");
                    if (sdtfContents && sdtfContents.length > 0)
                        delete this._loadedOutputNodes[outputID][outputInfo[outputID].version];
                }
                if (outputsFreeze[outputID]) {
                    currentNodes[outputID][outputInfo[outputID].version] =
                        this._lastOutputNodes[outputID][outputInfo[outputID].version];
                    // no loading necessary, progress done
                    progress[outputID] = 1;
                }
                else if (outputs[outputID].delay) {
                    maxDelay = Math.max(maxDelay, outputs[outputID].delay);
                }
                else if (!this._loadedOutputNodes[outputID][outputInfo[outputID].version]) {
                    currentNodes[outputID][outputInfo[outputID].version] =
                        new SessionTreeNode_1.SessionTreeNode(outputID);
                    currentNodes[outputID][outputInfo[outputID].version].data.push(new SessionOutputData_1.SessionOutputData(outputs[outputID]));
                    if (outputs[outputID].content) {
                        for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                            if (outputs[outputID].content[i].format === "sdtf" &&
                                !this._sessionEngine.loadSdtf)
                                continue;
                            if (this._globalAccessObjects.loadContent)
                                promises.push(this._globalAccessObjects.loadContent(outputs[outputID].content[i], this._sessionEngine.jwtToken, outputID +
                                    "_" +
                                    outputInfo[outputID].version +
                                    "_" +
                                    i));
                            promisesNodes.push(currentNodes[outputID][outputInfo[outputID].version]);
                        }
                    }
                }
                else {
                    currentNodes[outputID][outputInfo[outputID].version] =
                        this._loadedOutputNodes[outputID][outputInfo[outputID].version];
                    // no loading necessary, progress done
                    progress[outputID] = 1;
                }
            }
            if (maxDelay && throwDelay)
                throw new OutputDelayException_1.OutputDelayException(maxDelay);
            /**
             * WARNING: After this point outputs object cannot be used anymore.
             * This can happen when fast consecutive scene updates are done.
             * Therefore, we stored the data in the outputInfo.
             */
            yield Promise.all(promises);
            listenerTokens.forEach((t) => this._eventEngine.removeListener(t));
            // all promises are resolved, await in the next lines is just for structural purposes
            for (let i = 0; i < promises.length; i++)
                promisesNodes[i].addChild(yield promises[i]);
            // here we assign all outputs just to the node and return it
            for (const outputID in outputInfo) {
                if (currentNodes[outputID][outputInfo[outputID].version]) {
                    // when using parallel customization we need to clone the node
                    // as a node can only be added to one parent
                    // and this node might be added to multiple parents
                    if (cloneNodes) {
                        const clonedNode = currentNodes[outputID][outputInfo[outputID].version].clone();
                        node.addChild(clonedNode);
                    }
                    else {
                        node.addChild(currentNodes[outputID][outputInfo[outputID].version]);
                    }
                }
            }
            // save the nodes as the last available version
            for (const outputID in outputInfo) {
                if (!currentNodes[outputID][outputInfo[outputID].version])
                    continue;
                this._loadedOutputNodes[outputID] = {};
                this._loadedOutputNodes[outputID][outputInfo[outputID].version] =
                    currentNodes[outputID][outputInfo[outputID].version];
                this._lastOutputNodes[outputID] = {};
                this._lastOutputNodes[outputID][outputInfo[outputID].version] =
                    currentNodes[outputID][outputInfo[outputID].version];
            }
            for (const outputID in outputInfo) {
                if (!currentNodes[outputID][outputInfo[outputID].version])
                    continue;
                if (currentNodes[outputID][outputInfo[outputID].version].children
                    .length > 1) {
                    for (let i = 0, len = outputInfo[outputID].contentFormat.length; i < len; i++) {
                        if (outputInfo[outputID].contentFormat[i] === "sdtf" &&
                            this._sessionEngine.loadSdtf === true) {
                            this.mergeContentNodes(currentNodes[outputID][outputInfo[outputID].version]);
                            break;
                        }
                    }
                }
            }
            this.assignMaterials(node);
            this._performanceEvaluator.endSection("outputLoading");
            return node;
        });
    }
    // #endregion Public Methods (2)
    // #region Private Methods (2)
    assignMaterials(node) {
        const addMaterialToGeometry = (node, material) => {
            for (let i = 0; i < node.data.length; i++) {
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                    const geometry = node.data[i];
                    const currentMaterial = geometry.material;
                    if (currentMaterial === null ||
                        currentMaterial.materialOutput === true) {
                        geometry.material = material;
                    }
                }
            }
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (child)
                    addMaterialToGeometry(child, material);
            }
        };
        const getMaterialData = (node, materials = []) => {
            for (let k = 0; k < node.data.length; k++) {
                if (node.data[k] instanceof viewer_shared_types_1.AbstractMaterialData) {
                    const material = node.data[k];
                    material.materialOutput = true;
                    materials.push(material);
                }
            }
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                materials.push(...getMaterialData(child));
            }
            return materials;
        };
        for (let m = 0; m < node.children.length; m++) {
            // per output node, we go through the material assignment process
            const outputNode = node.children[m];
            if (!outputNode)
                continue;
            // we go through all data properties, normally, there should ony one, but we just make sure
            for (let i = 0; i < outputNode.data.length; i++) {
                if (!(outputNode.data[i] instanceof SessionOutputData_1.SessionOutputData))
                    continue;
                // the session output data contains information about this Output
                // most importantly the SessionOutput property with the material and content in it
                const sessionOutputData = outputNode.data[i];
                // case 1: we have a specific material id defined, let's use that
                if (sessionOutputData.responseOutput.material) {
                    let materialNodes = [];
                    // now we have id
                    // get material with it
                    for (let n = 0; n < node.children.length; n++) {
                        const materialNode = node.children[n];
                        if (!materialNode)
                            continue;
                        if (materialNode.name ===
                            sessionOutputData.responseOutput.material)
                            materialNodes = materialNode.children;
                    }
                    const geometryNodes = outputNode.children;
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
                // case 2: there is no specific material id defined, maybe in the content we can match geometries to ids
                else {
                    // now we hope that in our content, there are exactly the amount of geometries and material, this will be interesting :)
                    const sessionOutputContent = sessionOutputData.responseOutput.content;
                    if (sessionOutputContent === undefined)
                        continue;
                    const materialNodes = [];
                    const geometryNodes = [];
                    for (let i = 0; i < sessionOutputContent.length; i++) {
                        if (sessionOutputContent[i].format === "material") {
                            if (outputNode.children[i])
                                materialNodes.push(outputNode.children[i]);
                        }
                        else {
                            if (outputNode.children[i])
                                geometryNodes.push(outputNode.children[i]);
                        }
                    }
                    if (materialNodes.length >= geometryNodes.length) {
                        for (let n = 0; n < geometryNodes.length; n++) {
                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);
                        }
                    }
                    else {
                        if (materialNodes.length >= 1)
                            for (let n = 0; n < geometryNodes.length; n++) {
                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);
                            }
                    }
                }
            }
        }
    }
    mergeContentNodes(node) {
        if (!(node.children.length > 1))
            return;
        const children = [];
        while (node.children.length > 0) {
            children.push(...node.children[0].children);
            node.removeChild(node.children[0]);
        }
        const mergeNodes = (node1, node2) => {
            for (let i = 0; i < node1.data.length; i++)
                node2.data.push(node1.data[i]);
            for (let i = 0; i < node1.children.length; i++) {
                let childNode;
                for (let j = 0; j < node2.children.length; j++) {
                    if (node1.children[i].name === node2.children[j].name) {
                        childNode = node2.children[j];
                        break;
                    }
                }
                if (!childNode) {
                    childNode = new viewer_shared_node_tree_1.TreeNode(node1.children[i].name);
                    node2.addChild(childNode);
                }
                mergeNodes(node1.children[i], childNode);
            }
        };
        const newChild = new viewer_shared_node_tree_1.TreeNode("content_array");
        node.addChild(newChild);
        for (let i = 0; i < children.length; i++)
            mergeNodes(children[i], newChild);
    }
}
exports.OutputLoader = OutputLoader;
// #endregion Classes (1)
//# sourceMappingURL=OutputLoader.js.map
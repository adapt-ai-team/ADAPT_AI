"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraEngine = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const ICameraEngine_1 = require("../interfaces/ICameraEngine");
const AbstractCamera_1 = require("./camera/AbstractCamera");
const PerspectiveCamera_1 = require("./camera/PerspectiveCamera");
const OrthographicCamera_1 = require("./camera/OrthographicCamera");
class CameraEngine {
    // #endregion Properties (10)
    // #region Constructors (1)
    constructor(_viewerId, _canvas, _domEventEngine) {
        this._viewerId = _viewerId;
        this._canvas = _canvas;
        this._domEventEngine = _domEventEngine;
        // #region Properties (10)
        this._cameras = {};
        this._camerasDomEventListenerToken = {};
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._settingsEngine = tsyringe_1.container.resolve(viewer_shared_services_1.SettingsEngine);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._camera = null;
        this._settingsApplied = false;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewerId === this._viewerId) {
                this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                const cameras = this.cameras;
                for (let c in cameras)
                    cameras[c].boundingBox = this._boundingBox.clone();
            }
        });
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWER.VIEWER_UPDATED, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewerId === this._viewerId) {
                this.searchForNewCameras();
            }
        });
    }
    // #endregion Constructors (1)
    // #region Public Accessors (2)
    get camera() {
        return this._camera;
    }
    get cameras() {
        this.searchForNewCameras();
        return this._cameras;
    }
    // #endregion Public Accessors (2)
    // #region Public Methods (7)
    activateCameraEvents() {
        const cameras = this.cameras;
        for (let c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.activateCameraEvents();
    }
    applySettings() {
        const cameras = this.cameras;
        for (let c in cameras)
            this.removeCamera(c);
        for (let id in this._settingsEngine.settings.camera.cameras) {
            const cameraSetting = this._settingsEngine.settings.camera.cameras[id];
            if (cameraSetting.type === 'perspective') {
                this.createCamera(ICameraEngine_1.CAMERATYPE.PERSPECTIVE, id);
            }
            else {
                const camera = this.createCamera(ICameraEngine_1.CAMERATYPE.ORTHOGRAPHIC, id);
                camera.direction = cameraSetting.type;
            }
        }
        if (!this._settingsApplied)
            for (let c in cameras)
                cameras[c].applySettings();
        const cameraKeys = Object.keys(this._settingsEngine.settings.camera.cameras);
        if (cameraKeys.length > 0) {
            if (!this._settingsEngine.settings.camera.cameraId) {
                this.assignCamera(cameraKeys[0]);
            }
            else {
                this.assignCamera(this._settingsEngine.settings.camera.cameraId);
            }
        }
        else {
            const camera = this.createCamera(ICameraEngine_1.CAMERATYPE.PERSPECTIVE, 'standard');
            this.assignCamera(camera.id);
            camera.applySettings();
        }
        this._settingsApplied = true;
    }
    assignCamera(id) {
        const camera = this.cameras[id];
        if (!camera)
            return;
        this._camera = camera;
    }
    createCamera(type, id) {
        const cameras = this.cameras;
        const cameraId = id || this._uuidGenerator.create();
        if (cameras[cameraId]) {
            const error = new viewer_shared_services_1.ShapeDiverViewerCameraError(`CameraEngine.createCamera: Camera (${type}) with this id (${cameraId}) already exists.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.CAMERA, `CameraEngine.createCamera`, error, false);
        }
        const camera = ICameraEngine_1.CAMERATYPE.PERSPECTIVE === type ? new PerspectiveCamera_1.PerspectiveCamera(cameraId) : new OrthographicCamera_1.OrthographicCamera(cameraId);
        camera.assignViewer(this._viewerId);
        cameras[cameraId] = camera;
        if (this._settingsApplied) {
            camera.applySettings();
        }
        else {
            camera.zoomTo(undefined, { duration: 0 });
        }
        return camera;
    }
    deactivateCameraEvents() {
        const cameras = this.cameras;
        for (let c in cameras)
            cameras[c].controls.cameraControlsEventDistribution.deactivateCameraEvents();
    }
    removeCamera(id) {
        const cameras = this.cameras;
        const camera = cameras[id];
        if (!camera)
            return false;
        this._domEventEngine.removeDomEventListener(this._camerasDomEventListenerToken[id]);
        if (this._camera && this._camera.id === id)
            this._camera = null;
        delete cameras[id];
        delete this._camerasDomEventListenerToken[id];
        return true;
    }
    saveSettings() {
        this._settingsEngine.settings.camera.cameraId = this._camera ? this._camera.id : 'standard';
        this._settingsEngine.settings.camera.cameras = {};
        // TODO: once the platform is ready for it, save all cameras
        // for (let c in this.cameras) {
        if (!this._camera)
            return;
        const camera = this._camera;
        if (camera.type === ICameraEngine_1.CAMERATYPE.PERSPECTIVE) {
            const controls = camera.controls;
            this._settingsEngine.camera.cameras[camera.id] = {
                autoAdjust: camera.autoAdjust,
                cameraMovementDuration: camera.cameraMovementDuration,
                enableCameraControls: camera.enableCameraControls,
                revertAtMouseUp: camera.revertAtMouseUp,
                revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                zoomExtentsFactor: camera.zoomExtentsFactor,
                position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                type: camera.type,
                fov: camera.fov,
                controls: {
                    autoRotationSpeed: controls.autoRotationSpeed,
                    damping: controls.damping,
                    enableAutoRotation: controls.enableAutoRotation,
                    enableKeyPan: controls.enableKeyPan,
                    enablePan: controls.enablePan,
                    enableRotation: controls.enableRotation,
                    enableZoom: controls.enableZoom,
                    input: controls.input,
                    keyPanSpeed: controls.keyPanSpeed,
                    movementSmoothness: controls.movementSmoothness,
                    rotationSpeed: controls.rotationSpeed,
                    panSpeed: controls.panSpeed,
                    zoomSpeed: controls.zoomSpeed,
                    restrictions: {
                        position: {
                            cube: {
                                min: { x: controls.cubePositionRestriction.min[0], y: controls.cubePositionRestriction.min[1], z: controls.cubePositionRestriction.min[2] },
                                max: { x: controls.cubePositionRestriction.max[0], y: controls.cubePositionRestriction.max[1], z: controls.cubePositionRestriction.max[2] },
                            },
                            sphere: {
                                center: { x: controls.spherePositionRestriction.center[0], y: controls.spherePositionRestriction.center[1], z: controls.spherePositionRestriction.center[2] },
                                radius: controls.spherePositionRestriction.radius,
                            },
                        },
                        target: {
                            cube: {
                                min: { x: controls.cubeTargetRestriction.min[0], y: controls.cubeTargetRestriction.min[1], z: controls.cubeTargetRestriction.min[2] },
                                max: { x: controls.cubeTargetRestriction.max[0], y: controls.cubeTargetRestriction.max[1], z: controls.cubeTargetRestriction.max[2] },
                            },
                            sphere: {
                                center: { x: controls.sphereTargetRestriction.center[0], y: controls.sphereTargetRestriction.center[1], z: controls.sphereTargetRestriction.center[2] },
                                radius: controls.sphereTargetRestriction.radius,
                            },
                        },
                        rotation: controls.rotationRestriction,
                        zoom: controls.zoomRestriction,
                    }
                }
            };
        }
        else {
            if (this._settingsEngine.camera.cameras[camera.id]) {
                const previousDirection = this._settingsEngine.camera.cameras[camera.id].type;
                // if the direction changed, but the default position & target did not, there is an issue
                if (previousDirection !== camera.type && (this._settingsEngine.camera.cameras[camera.id].position.x === camera.defaultPosition[0] &&
                    this._settingsEngine.camera.cameras[camera.id].position.y === camera.defaultPosition[1] &&
                    this._settingsEngine.camera.cameras[camera.id].position.z === camera.defaultPosition[2] &&
                    this._settingsEngine.camera.cameras[camera.id].target.x === camera.defaultTarget[0] &&
                    this._settingsEngine.camera.cameras[camera.id].target.y === camera.defaultTarget[1] &&
                    this._settingsEngine.camera.cameras[camera.id].target.z === camera.defaultTarget[2])) {
                    camera.defaultPosition = gl_matrix_1.vec3.clone(camera.position);
                    camera.defaultTarget = gl_matrix_1.vec3.clone(camera.target);
                }
            }
            const controls = camera.controls;
            this._settingsEngine.camera.cameras[camera.id] = {
                autoAdjust: camera.autoAdjust,
                cameraMovementDuration: camera.cameraMovementDuration,
                enableCameraControls: camera.enableCameraControls,
                revertAtMouseUp: camera.revertAtMouseUp,
                revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                zoomExtentsFactor: camera.zoomExtentsFactor,
                position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                type: camera.direction,
                controls: {
                    damping: controls.damping,
                    enableKeyPan: controls.enableKeyPan,
                    enablePan: controls.enablePan,
                    enableZoom: controls.enableZoom,
                    input: controls.input,
                    keyPanSpeed: controls.keyPanSpeed,
                    movementSmoothness: controls.movementSmoothness,
                    panSpeed: controls.panSpeed,
                    zoomSpeed: controls.zoomSpeed,
                }
            };
        }
    }
    // #endregion Public Methods (7)
    // #region Private Methods (1)
    searchForNewCameras() {
        const getCameraData = (node) => {
            for (let i = 0; i < node.data.length; i++)
                if ((node.data[i] instanceof AbstractCamera_1.AbstractCamera) && !this._cameras[node.data[i].id]) {
                    const camera = node.data[i];
                    if (camera.viewerId === this._viewerId)
                        this._cameras[camera.id] = camera;
                }
            for (let i = 0; i < node.children.length; i++)
                getCameraData(node.children[i]);
        };
        getCameraData(this._tree.root);
    }
}
exports.CameraEngine = CameraEngine;
//# sourceMappingURL=CameraEngine.js.map
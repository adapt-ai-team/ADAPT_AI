"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrthographicCamera = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const ICameraEngine_1 = require("../../interfaces/ICameraEngine");
const AbstractCamera_1 = require("./AbstractCamera");
const OrthographicCameraControls_1 = require("../controls/OrthographicCameraControls");
const IOrthographicCamera_1 = require("../../interfaces/camera/IOrthographicCamera");
class OrthographicCamera extends AbstractCamera_1.AbstractCamera {
    // #endregion Properties (7)
    // #region Constructors (1)
    constructor(id) {
        super(id, ICameraEngine_1.CAMERATYPE.ORTHOGRAPHIC);
        // #region Properties (7)
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._bottom = 100;
        this._direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP;
        this._left = 100;
        this._right = 100;
        this._top = 100;
        this._up = gl_matrix_1.vec3.fromValues(0, 1, 0);
        this._controls = new OrthographicCameraControls_1.OrthographicCameraControls(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Accessors (12)
    get bottom() {
        return this._bottom;
    }
    set bottom(value) {
        this._bottom = value;
    }
    get direction() {
        return this._direction;
    }
    set direction(value) {
        const changedDirection = this._direction !== value;
        this._direction = value;
        switch (this._direction) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                this.up = gl_matrix_1.vec3.fromValues(0, 1, 0);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            default:
                this.up = gl_matrix_1.vec3.fromValues(0, -1, 0);
        }
        if (changedDirection) {
            const { position, target } = this.calculateZoomTo(undefined);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
        }
    }
    get left() {
        return this._left;
    }
    set left(value) {
        this._left = value;
    }
    get right() {
        return this._right;
    }
    set right(value) {
        this._right = value;
    }
    get top() {
        return this._top;
    }
    set top(value) {
        this._top = value;
    }
    get up() {
        return this._up;
    }
    set up(value) {
        this._up = value;
    }
    // #endregion Public Accessors (12)
    // #region Public Methods (6)
    applySettings() {
        const cameraSetting = this._settingsEngine.camera.cameras[this.id];
        if (cameraSetting) {
            this.autoAdjust = cameraSetting.autoAdjust;
            this.cameraMovementDuration = cameraSetting.cameraMovementDuration;
            this.enableCameraControls = cameraSetting.enableCameraControls;
            this.revertAtMouseUp = cameraSetting.revertAtMouseUp;
            this.revertAtMouseUpDuration = cameraSetting.revertAtMouseUpDuration;
            this.zoomExtentsFactor = cameraSetting.zoomExtentsFactor;
            let position = this._converter.toVec3(cameraSetting.position);
            let target = this._converter.toVec3(cameraSetting.target);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = position;
            this.target = target;
        }
        if (this.position[0] === this.target[0] && this.position[1] === this.target[1] && this.position[2] === this.target[2]) {
            this._stateEngine.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
                yield this.zoomTo(undefined, { duration: 0 });
                this.defaultPosition = gl_matrix_1.vec3.clone(this._controls.position);
                this.defaultTarget = gl_matrix_1.vec3.clone(this._controls.target);
            }));
        }
        this._controls.applySettings();
    }
    assignViewer(viewerId) {
        const renderingEngines = tsyringe_1.container.resolveAll('renderingEngine');
        let renderingEngine = renderingEngines.find(r => r.id === viewerId && r.closed === false);
        if (!renderingEngine) {
            const error = new viewer_shared_services_1.ShapeDiverViewerCameraError(`OrthographicCamera(${this.id}).assignViewer: Viewer with ID ${viewerId} not found.`);
            throw this._logger.handleError(viewer_shared_services_1.LOGGINGTOPIC.CAMERA, `OrthographicCamera(${this.id}).assignViewer`, error);
        }
        this.assignViewerInternal(viewerId, renderingEngine.canvas);
        this._controls.assignViewer(viewerId, renderingEngine.canvas);
        if (this._domEventListenerToken && this._domEventEngine)
            this._domEventEngine.removeDomEventListener(this._domEventListenerToken);
        this._domEventEngine = renderingEngine.domEventEngine;
        this._domEventListenerToken = this._domEventEngine.addDomEventListener(this._controls.cameraControlsEventDistribution);
        this.boundingBox = this._tree.root.boundingBox.clone();
    }
    clone() {
        return new OrthographicCamera(this.id);
    }
    calculateZoomTo(zoomTarget, startingPosition, startingTarget) {
        let box;
        // Part 1 - calculate the bounding box that we should zoom to
        if (!zoomTarget) {
            // complete scene
            box = this._boundingBox.clone();
        }
        else {
            // specified Box
            box = zoomTarget.clone();
        }
        const factor = 2 * box.boundingSphere.radius * this.zoomExtentsFactor;
        const center = gl_matrix_1.vec3.clone(box.boundingSphere.center);
        switch (this._direction) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0], center[1], center[2] + factor),
                    target: gl_matrix_1.vec3.clone(center)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0], center[1], center[2] - factor),
                    target: gl_matrix_1.vec3.clone(center)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0] + factor, center[1], center[2]),
                    target: gl_matrix_1.vec3.clone(center)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0] - factor, center[1], center[2]),
                    target: gl_matrix_1.vec3.clone(center)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0], center[1] + factor, center[2]),
                    target: gl_matrix_1.vec3.clone(center)
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0], center[1] - factor, center[2]),
                    target: gl_matrix_1.vec3.clone(center)
                };
            default:
                return {
                    position: gl_matrix_1.vec3.fromValues(center[0], center[1], center[2] + factor),
                    target: gl_matrix_1.vec3.clone(center)
                };
        }
    }
    project(pos) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        gl_matrix_1.vec3.transformMat4(pos, pos, gl_matrix_1.mat4.invert(m, m));
        gl_matrix_1.vec3.transformMat4(pos, pos, p);
        return gl_matrix_1.vec2.fromValues(pos[0], pos[1]);
    }
    unproject(pos, position = this.position, target = this.target) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        gl_matrix_1.vec3.transformMat4(pos, pos, gl_matrix_1.mat4.invert(p, p));
        gl_matrix_1.vec3.transformMat4(pos, pos, m);
        return gl_matrix_1.vec3.clone(pos);
    }
}
exports.OrthographicCamera = OrthographicCamera;
//# sourceMappingURL=OrthographicCamera.js.map
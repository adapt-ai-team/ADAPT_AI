"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _OrthographicCamera_converter, _OrthographicCamera_logger, _OrthographicCamera_tree, _OrthographicCamera_bottom, _OrthographicCamera_direction, _OrthographicCamera_domEventEngine, _OrthographicCamera_left, _OrthographicCamera_right, _OrthographicCamera_top, _OrthographicCamera_up;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrthographicCamera = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const IOrthographicCamera_1 = require("../../interfaces/camera/IOrthographicCamera");
const ICameraEngine_1 = require("../../interfaces/ICameraEngine");
const OrthographicCameraControls_1 = require("../controls/OrthographicCameraControls");
const AbstractCamera_1 = require("./AbstractCamera");
class OrthographicCamera extends AbstractCamera_1.AbstractCamera {
    // #endregion Properties (11)
    // #region Constructors (1)
    constructor(id, version, isDefault = false) {
        super(id, ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, version, isDefault);
        // #region Properties (11)
        _OrthographicCamera_converter.set(this, viewer_shared_services_1.Converter.instance);
        _OrthographicCamera_logger.set(this, viewer_shared_services_1.Logger.instance);
        _OrthographicCamera_tree.set(this, viewer_shared_node_tree_1.Tree.instance);
        _OrthographicCamera_bottom.set(this, -100);
        _OrthographicCamera_direction.set(this, IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.CUSTOM);
        _OrthographicCamera_domEventEngine.set(this, void 0);
        _OrthographicCamera_left.set(this, -100);
        _OrthographicCamera_right.set(this, 100);
        _OrthographicCamera_top.set(this, 100);
        _OrthographicCamera_up.set(this, gl_matrix_1.vec3.fromValues(0, 0, 1));
        this._controls = new OrthographicCameraControls_1.OrthographicCameraControls(this, true);
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (14)
    get bottom() {
        return __classPrivateFieldGet(this, _OrthographicCamera_bottom, "f");
    }
    set bottom(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_bottom, value, "f");
    }
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
    }
    get direction() {
        return __classPrivateFieldGet(this, _OrthographicCamera_direction, "f");
    }
    set direction(value) {
        const changedDirection = __classPrivateFieldGet(this, _OrthographicCamera_direction, "f") !== value;
        __classPrivateFieldSet(this, _OrthographicCamera_direction, value, "f");
        switch (__classPrivateFieldGet(this, _OrthographicCamera_direction, "f")) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                this.up = gl_matrix_1.vec3.fromValues(0, 1, 0);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
                break;
            default:
                this.up = gl_matrix_1.vec3.fromValues(0, 0, 1);
        }
        if (changedDirection) {
            const { position, target } = this.calculateZoomTo(undefined);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = gl_matrix_1.vec3.clone(position);
            this.target = gl_matrix_1.vec3.clone(target);
        }
    }
    get left() {
        return __classPrivateFieldGet(this, _OrthographicCamera_left, "f");
    }
    set left(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_left, value, "f");
    }
    get right() {
        return __classPrivateFieldGet(this, _OrthographicCamera_right, "f");
    }
    set right(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_right, value, "f");
    }
    get top() {
        return __classPrivateFieldGet(this, _OrthographicCamera_top, "f");
    }
    set top(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_top, value, "f");
    }
    get up() {
        return __classPrivateFieldGet(this, _OrthographicCamera_up, "f");
    }
    set up(value) {
        __classPrivateFieldSet(this, _OrthographicCamera_up, value, "f");
    }
    // #endregion Public Getters And Setters (14)
    // #region Public Methods (6)
    applySettings(settingsEngine) {
        var _a;
        const cameraSetting = (settingsEngine.camera.cameras[this.id]);
        if (cameraSetting) {
            this.name = cameraSetting.name;
            this.autoAdjust = cameraSetting.autoAdjust;
            this.cameraMovementDuration = cameraSetting.cameraMovementDuration;
            this.enableCameraControls = cameraSetting.enableCameraControls;
            this.revertAtMouseUp = cameraSetting.revertAtMouseUp;
            this.revertAtMouseUpDuration =
                cameraSetting.revertAtMouseUpDuration;
            this.sceneRotation = gl_matrix_1.vec2.fromValues(cameraSetting.sceneRotation.x, cameraSetting.sceneRotation.y);
            this.zoomExtentsFactor = cameraSetting.zoomExtentsFactor;
            const position = __classPrivateFieldGet(this, _OrthographicCamera_converter, "f").toVec3(cameraSetting.position);
            const target = __classPrivateFieldGet(this, _OrthographicCamera_converter, "f").toVec3(cameraSetting.target);
            this.defaultPosition = gl_matrix_1.vec3.clone(position);
            this.defaultTarget = gl_matrix_1.vec3.clone(target);
            this.position = position;
            this.target = target;
        }
        if (this.position[0] === this.target[0] &&
            this.position[1] === this.target[1] &&
            this.position[2] === this.target[2]) {
            if (this._viewportId) {
                (_a = this._stateEngine.viewportEngines[this._viewportId]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.zoomTo(undefined, { duration: 0 });
                    this.defaultPosition = gl_matrix_1.vec3.clone(this._controls.position);
                    this.defaultTarget = gl_matrix_1.vec3.clone(this._controls.target);
                }));
            }
        }
        this._controls.applySettings(settingsEngine);
    }
    assignViewer(renderingEngine) {
        var _a;
        if (renderingEngine.closed)
            throw new viewer_shared_services_1.ShapeDiverViewerCameraError(`OrthographicCamera(${this.id}).assignViewer: Viewer with id ${renderingEngine.id} not found.`);
        this.assignViewerInternal(renderingEngine.id);
        this._controls.assignViewer(renderingEngine.id, renderingEngine.canvas);
        if (this.domEventListenerToken && __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f"))
            __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f").removeDomEventListener(this.domEventListenerToken);
        __classPrivateFieldSet(this, _OrthographicCamera_domEventEngine, renderingEngine.domEventEngine, "f");
        this.domEventListenerToken = __classPrivateFieldGet(this, _OrthographicCamera_domEventEngine, "f").addDomEventListener(this._controls
            .cameraControlsEventDistribution);
        this.boundingBox = __classPrivateFieldGet(this, _OrthographicCamera_tree, "f").root.boundingBox.clone();
        (_a = this._stateEngine.viewportEngines[renderingEngine.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.then(() => __awaiter(this, void 0, void 0, function* () {
            if (this.position[0] === this.target[0] &&
                this.position[1] === this.target[1] &&
                this.position[2] === this.target[2])
                yield this.zoomTo(undefined, { duration: 0 });
        }));
    }
    calculateZoomTo(zoomTarget, startingPosition = this.position, startingTarget = this.target) {
        let box;
        // Part 1 - calculate the bounding box that we should zoom to
        if (!zoomTarget) {
            // complete scene
            box = this._boundingBox.clone();
        }
        else {
            // specified Box
            box = zoomTarget.clone();
        }
        if (box.isEmpty())
            return { position: gl_matrix_1.vec3.create(), target: gl_matrix_1.vec3.create() };
        const target = gl_matrix_1.vec3.fromValues((box.max[0] + box.min[0]) / 2, (box.max[1] + box.min[1]) / 2, (box.max[2] + box.min[2]) / 2);
        if (startingPosition[0] === startingTarget[0] &&
            startingPosition[1] === startingTarget[1] &&
            startingPosition[2] === startingTarget[2])
            startingPosition = gl_matrix_1.vec3.fromValues(target[0], target[1] - 7.5, target[2] + 5);
        const factor = 2 * box.boundingSphere.radius * this.zoomExtentsFactor;
        switch (__classPrivateFieldGet(this, _OrthographicCamera_direction, "f")) {
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1], target[2] + factor),
                    target: gl_matrix_1.vec3.clone(target),
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1], target[2] - factor),
                    target: gl_matrix_1.vec3.clone(target),
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0] + factor, target[1], target[2]),
                    target: gl_matrix_1.vec3.clone(target),
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0] - factor, target[1], target[2]),
                    target: gl_matrix_1.vec3.clone(target),
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1] + factor, target[2]),
                    target: gl_matrix_1.vec3.clone(target),
                };
            case IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT:
                return {
                    position: gl_matrix_1.vec3.fromValues(target[0], target[1] - factor, target[2]),
                    target: gl_matrix_1.vec3.clone(target),
                };
            default: {
                // get the direction from the starting position to the starting target
                const direction = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), startingPosition, target);
                // normalize the direction
                gl_matrix_1.vec3.normalize(direction, direction);
                // get the new position
                return {
                    position: gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), target, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), direction, factor)),
                    target: gl_matrix_1.vec3.clone(target),
                };
            }
        }
    }
    clone() {
        return new OrthographicCamera(this.id, this.version);
    }
    project(pos) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), m);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, p);
        return gl_matrix_1.vec2.fromValues(pos[0], pos[1]);
    }
    unproject(pos) {
        const m = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this.position, this.target, this.up);
        const p = gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), this.left, this.right, this.bottom, this.top, this.near, this.far);
        let inverse = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), p);
        if (!inverse)
            inverse = gl_matrix_1.mat4.create();
        gl_matrix_1.vec3.transformMat4(pos, pos, inverse);
        gl_matrix_1.vec3.transformMat4(pos, pos, m);
        return gl_matrix_1.vec3.clone(pos);
    }
    // #endregion Public Methods (6)
    // #region Protected Methods (1)
    getProjectionMatrix() {
        const distance = gl_matrix_1.vec3.distance(this.position, this.target) / 2;
        if (distance === 0)
            return;
        return gl_matrix_1.mat4.ortho(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _OrthographicCamera_left, "f"), __classPrivateFieldGet(this, _OrthographicCamera_right, "f"), __classPrivateFieldGet(this, _OrthographicCamera_bottom, "f"), __classPrivateFieldGet(this, _OrthographicCamera_top, "f"), this.near, this.far);
    }
}
exports.OrthographicCamera = OrthographicCamera;
_OrthographicCamera_converter = new WeakMap(), _OrthographicCamera_logger = new WeakMap(), _OrthographicCamera_tree = new WeakMap(), _OrthographicCamera_bottom = new WeakMap(), _OrthographicCamera_direction = new WeakMap(), _OrthographicCamera_domEventEngine = new WeakMap(), _OrthographicCamera_left = new WeakMap(), _OrthographicCamera_right = new WeakMap(), _OrthographicCamera_top = new WeakMap(), _OrthographicCamera_up = new WeakMap();
//# sourceMappingURL=OrthographicCamera.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraEngine = void 0;
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const IOrthographicCamera_1 = require("../interfaces/camera/IOrthographicCamera");
const ICameraEngine_1 = require("../interfaces/ICameraEngine");
const AbstractCamera_1 = require("./camera/AbstractCamera");
const OrthographicCamera_1 = require("./camera/OrthographicCamera");
const PerspectiveCamera_1 = require("./camera/PerspectiveCamera");
class CameraEngine {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._cameraNode = new viewer_shared_node_tree_1.TreeNode("cameras");
        this._cameras = {};
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._camera = null;
        this._settingsApplied = false;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._tree.root.addChild(this._cameraNode);
        this._cameraNode.restrictViewports = [this._renderingEngine.id];
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                const cameras = this.cameras;
                for (const c in cameras)
                    cameras[c].boundingBox = this._boundingBox.clone();
                if (!this._boundingBox.isEmpty() && this.camera) {
                    // check if the at least a part of the bounding box is visible
                    // if not zoom to the bounding box
                    if (!this.camera.boundingSphereVisible(this._boundingBox.boundingSphere)) {
                        this.camera.zoomTo(this._boundingBox, {
                            duration: 0,
                        });
                    }
                }
            }
        });
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this.searchForNewCameras();
            }
        });
    }
    get camera() {
        return this._camera;
    }
    get cameras() {
        return this._cameras;
    }
    get update() {
        return this._update;
    }
    set update(value) {
        this._update = value;
    }
    activateCameraEvents() {
        const cameras = this.cameras;
        for (const c in cameras)
            (cameras[c].controls).cameraControlsEventDistribution.activateCameraEvents();
    }
    applySettings(settingsEngine) {
        var _a;
        const cameras = this.cameras;
        for (const c in cameras)
            this.removeCamera(c);
        /**
         * Due to some inconsistency in the behavior of saving settings
         * we save the orthographic default cameras, even if they were never changed.
         * Now we check if the six cameras exist and were not change and if so, we never add them
         */
        const defaultCameras = [
            "top",
            "bottom",
            "left",
            "right",
            "front",
            "back",
        ];
        let defaultCamerasInSettings = true;
        for (const cameraId of defaultCameras) {
            if (settingsEngine.settings.camera.cameraId === cameraId) {
                // the camera was set as the default, don't remove it
                defaultCamerasInSettings = false;
                break;
            }
            if (!settingsEngine.settings.camera.cameras[cameraId])
                defaultCamerasInSettings = false;
        }
        for (const id in settingsEngine.settings.camera.cameras) {
            const cameraSetting = settingsEngine.settings.camera.cameras[id];
            if (cameraSetting.type === "perspective") {
                this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, id);
            }
            else {
                const isDefault = defaultCamerasInSettings && defaultCameras.includes(id);
                const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, id, isDefault);
                camera.direction = cameraSetting.type;
            }
        }
        for (const c in cameras)
            cameras[c].applySettings(settingsEngine);
        const cameraKeys = Object.keys(settingsEngine.settings.camera.cameras);
        if (cameraKeys.length > 0) {
            if (!settingsEngine.settings.camera.cameraId) {
                this.assignCamera(cameraKeys[0]);
            }
            else {
                this.assignCamera(settingsEngine.settings.camera.cameraId);
            }
            // create the default orthographic cameras if there are no cameras with the default names
            if (!defaultCamerasInSettings &&
                cameraKeys.every((key) => !defaultCameras.includes(key)))
                this.createDefaultCameras(true);
        }
        else {
            this.createDefaultCameras();
            this.camera.applySettings(settingsEngine);
        }
        this._settingsApplied = true;
        // If the camera is set to auto adjust, we call zoomTo once when the bounding box is available
        // this is needed as the default position and target might not make sense if the model is loaded with a different modelState
        // or different initial parameters
        if ((_a = this.camera) === null || _a === void 0 ? void 0 : _a.autoAdjust) {
            const token = this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
                var _a;
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id) {
                    this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                    if (this._boundingBox.isEmpty() || !this.camera)
                        return;
                    (_a = this.camera) === null || _a === void 0 ? void 0 : _a.zoomTo(this._boundingBox, { duration: 0 });
                    this._eventEngine.removeListener(token);
                }
            });
        }
        if (this._update)
            this._update();
    }
    assignCamera(id) {
        const camera = this.cameras[id];
        if (!camera)
            return false;
        for (const c in this.cameras)
            this.cameras[c].active = false;
        this._camera = camera;
        this._camera.active = true;
        return true;
    }
    close() {
        this._tree.root.removeChild(this._cameraNode);
    }
    createCamera(type, id, isDefault = false) {
        const cameras = this.cameras;
        const cameraId = id || this._uuidGenerator.create();
        if (cameras[cameraId])
            throw new viewer_shared_services_1.ShapeDiverViewerCameraError(`CameraEngine.createCamera: Camera (${type}) with this id (${cameraId}) already exists.`);
        const initialAspectRatio = this._renderingEngine.canvas.parentNode
            .clientWidth /
            this._renderingEngine.canvas.parentNode
                .clientHeight;
        const camera = ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE === type
            ? new PerspectiveCamera_1.PerspectiveCamera(cameraId, undefined, initialAspectRatio, isDefault)
            : new OrthographicCamera_1.OrthographicCamera(cameraId, undefined, isDefault);
        camera.assignViewer(this._renderingEngine);
        cameras[cameraId] = camera;
        if (this._settingsApplied && this._renderingEngine.settingsEngine) {
            camera.applySettings(this._renderingEngine.settingsEngine);
        }
        else {
            camera.zoomTo(undefined, { duration: 0 });
        }
        this._cameraNode.addData(camera);
        if (this._update)
            this._update();
        return camera;
    }
    createDefaultCameras(createOnlyOrthographic = false) {
        const topCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "top", true));
        topCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP;
        const bottomCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "bottom", true));
        bottomCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM;
        const leftCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "left", true));
        leftCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT;
        const rightCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "right", true));
        rightCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT;
        const frontCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "front", true));
        frontCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT;
        const backCamera = (this.createCamera(ICameraEngine_1.CAMERA_TYPE.ORTHOGRAPHIC, "back", true));
        backCamera.direction = IOrthographicCamera_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK;
        if (createOnlyOrthographic === false) {
            const camera = this.createCamera(ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE, "perspective");
            this.assignCamera(camera.id);
        }
    }
    deactivateCameraEvents() {
        const cameras = this.cameras;
        for (const c in cameras)
            (cameras[c].controls).cameraControlsEventDistribution.deactivateCameraEvents();
    }
    removeCamera(id) {
        const cameras = this.cameras;
        const camera = cameras[id];
        if (!camera)
            return false;
        camera.destroy();
        if (camera.domEventListenerToken)
            this._renderingEngine.domEventEngine.removeDomEventListener(camera.domEventListenerToken);
        if (this._camera && this._camera.id === id)
            this._camera = null;
        delete cameras[id];
        this._cameraNode.removeData(camera);
        if (this._update)
            this._update();
        return true;
    }
    saveSettings(settingsEngine) {
        settingsEngine.settings.camera.cameraId = this._camera
            ? this._camera.id
            : "perspective";
        settingsEngine.settings.camera.cameras = {};
        for (const c in this.cameras) {
            const camera = this.cameras[c];
            // don't save the default cameras
            if (camera.isDefault)
                continue;
            if (camera.type === ICameraEngine_1.CAMERA_TYPE.PERSPECTIVE) {
                const controls = (camera.controls);
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: {
                        x: camera.defaultPosition[0],
                        y: camera.defaultPosition[1],
                        z: camera.defaultPosition[2],
                    },
                    target: {
                        x: camera.defaultTarget[0],
                        y: camera.defaultTarget[1],
                        z: camera.defaultTarget[2],
                    },
                    type: camera.type,
                    fov: camera.fov,
                    sceneRotation: {
                        x: camera.sceneRotation[0],
                        y: camera.sceneRotation[1],
                    },
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: {
                                        x: controls.cubePositionRestriction
                                            .min[0],
                                        y: controls.cubePositionRestriction
                                            .min[1],
                                        z: controls.cubePositionRestriction
                                            .min[2],
                                    },
                                    max: {
                                        x: controls.cubePositionRestriction
                                            .max[0],
                                        y: controls.cubePositionRestriction
                                            .max[1],
                                        z: controls.cubePositionRestriction
                                            .max[2],
                                    },
                                },
                                sphere: {
                                    center: {
                                        x: controls.spherePositionRestriction
                                            .center[0],
                                        y: controls.spherePositionRestriction
                                            .center[1],
                                        z: controls.spherePositionRestriction
                                            .center[2],
                                    },
                                    radius: controls.spherePositionRestriction
                                        .radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: {
                                        x: controls.cubeTargetRestriction
                                            .min[0],
                                        y: controls.cubeTargetRestriction
                                            .min[1],
                                        z: controls.cubeTargetRestriction
                                            .min[2],
                                    },
                                    max: {
                                        x: controls.cubeTargetRestriction
                                            .max[0],
                                        y: controls.cubeTargetRestriction
                                            .max[1],
                                        z: controls.cubeTargetRestriction
                                            .max[2],
                                    },
                                },
                                sphere: {
                                    center: {
                                        x: controls.sphereTargetRestriction
                                            .center[0],
                                        y: controls.sphereTargetRestriction
                                            .center[1],
                                        z: controls.sphereTargetRestriction
                                            .center[2],
                                    },
                                    radius: controls.sphereTargetRestriction
                                        .radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        },
                        enableAzimuthRotation: controls.enableAzimuthRotation,
                        enablePolarRotation: controls.enablePolarRotation,
                        enableObjectControls: controls.enableObjectControls,
                        enableTurntableControls: controls.enableTurntableControls,
                        turntableCenter: {
                            x: controls.turntableCenter[0],
                            y: controls.turntableCenter[1],
                            z: controls.turntableCenter[2],
                        },
                        objectControlsCenter: {
                            x: controls.objectControlsCenter[0],
                            y: controls.objectControlsCenter[1],
                            z: controls.objectControlsCenter[2],
                        },
                    },
                };
            }
            else {
                if (settingsEngine.camera.cameras[camera.id]) {
                    const previousDirection = settingsEngine.camera.cameras[camera.id].type;
                    // if the direction changed, but the default position & target did not, there is an issue
                    if (previousDirection !== camera.type &&
                        settingsEngine.camera.cameras[camera.id].position.x ===
                            camera.defaultPosition[0] &&
                        settingsEngine.camera.cameras[camera.id].position.y ===
                            camera.defaultPosition[1] &&
                        settingsEngine.camera.cameras[camera.id].position.z ===
                            camera.defaultPosition[2] &&
                        settingsEngine.camera.cameras[camera.id].target.x ===
                            camera.defaultTarget[0] &&
                        settingsEngine.camera.cameras[camera.id].target.y ===
                            camera.defaultTarget[1] &&
                        settingsEngine.camera.cameras[camera.id].target.z ===
                            camera.defaultTarget[2]) {
                        camera.defaultPosition = gl_matrix_1.vec3.clone(camera.position);
                        camera.defaultTarget = gl_matrix_1.vec3.clone(camera.target);
                    }
                }
                const controls = (camera.controls);
                settingsEngine.camera.cameras[camera.id] = {
                    name: camera.name,
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: {
                        x: camera.defaultPosition[0],
                        y: camera.defaultPosition[1],
                        z: camera.defaultPosition[2],
                    },
                    target: {
                        x: camera.defaultTarget[0],
                        y: camera.defaultTarget[1],
                        z: camera.defaultTarget[2],
                    },
                    type: camera.direction,
                    sceneRotation: {
                        x: camera.sceneRotation[0],
                        y: camera.sceneRotation[1],
                    },
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: {
                                        x: controls.cubePositionRestriction
                                            .min[0],
                                        y: controls.cubePositionRestriction
                                            .min[1],
                                        z: controls.cubePositionRestriction
                                            .min[2],
                                    },
                                    max: {
                                        x: controls.cubePositionRestriction
                                            .max[0],
                                        y: controls.cubePositionRestriction
                                            .max[1],
                                        z: controls.cubePositionRestriction
                                            .max[2],
                                    },
                                },
                                sphere: {
                                    center: {
                                        x: controls.spherePositionRestriction
                                            .center[0],
                                        y: controls.spherePositionRestriction
                                            .center[1],
                                        z: controls.spherePositionRestriction
                                            .center[2],
                                    },
                                    radius: controls.spherePositionRestriction
                                        .radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: {
                                        x: controls.cubeTargetRestriction
                                            .min[0],
                                        y: controls.cubeTargetRestriction
                                            .min[1],
                                        z: controls.cubeTargetRestriction
                                            .min[2],
                                    },
                                    max: {
                                        x: controls.cubeTargetRestriction
                                            .max[0],
                                        y: controls.cubeTargetRestriction
                                            .max[1],
                                        z: controls.cubeTargetRestriction
                                            .max[2],
                                    },
                                },
                                sphere: {
                                    center: {
                                        x: controls.sphereTargetRestriction
                                            .center[0],
                                        y: controls.sphereTargetRestriction
                                            .center[1],
                                        z: controls.sphereTargetRestriction
                                            .center[2],
                                    },
                                    radius: controls.sphereTargetRestriction
                                        .radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        },
                        enableAzimuthRotation: controls.enableAzimuthRotation,
                        enablePolarRotation: controls.enablePolarRotation,
                        enableObjectControls: controls.enableObjectControls,
                        enableTurntableControls: controls.enableTurntableControls,
                        turntableCenter: {
                            x: controls.turntableCenter[0],
                            y: controls.turntableCenter[1],
                            z: controls.turntableCenter[2],
                        },
                        objectControlsCenter: {
                            x: controls.objectControlsCenter[0],
                            y: controls.objectControlsCenter[1],
                            z: controls.objectControlsCenter[2],
                        },
                    },
                };
            }
        }
    }
    searchForNewCameras() {
        const getCameraData = (node) => {
            for (let i = 0; i < node.data.length; i++)
                if (node.data[i] instanceof AbstractCamera_1.AbstractCamera &&
                    !this._cameras[node.data[i].id]) {
                    const camera = node.data[i];
                    if (camera.viewportId === this._renderingEngine.id)
                        this._cameras[camera.id] = camera;
                }
            for (let i = 0; i < node.children.length; i++)
                getCameraData(node.children[i]);
        };
        getCameraData(this._tree.root);
        if (this._update)
            this._update();
    }
}
exports.CameraEngine = CameraEngine;
//# sourceMappingURL=CameraEngine.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureLoader = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
class TextureLoader {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(_content, _bufferViewLoader, _baseUri) {
        this._content = _content;
        this._bufferViewLoader = _bufferViewLoader;
        this._baseUri = _baseUri;
        // #region Properties (3)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._httpClient = viewer_shared_services_1.HttpClient.instance;
        this._loaded = {};
    }
    // #endregion Constructors (1)
    // #region Public Methods (2)
    getTexture(textureId) {
        if (!this._content.textures)
            throw new Error("TextureLoader.getTexture: Textures not available.");
        if (!this._content.textures[textureId])
            throw new Error("TextureLoader.getTexture: Texture not available.");
        return this._loaded[textureId];
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.textures)
                return;
            const promises = [];
            for (let i = 0; i < this._content.textures.length; i++) {
                const textureId = i;
                const texture = this._content.textures[textureId];
                if (!this._content.images)
                    throw new Error("TextureLoader.load: Images not available.");
                const image = this._content.images[texture.source];
                const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;
                const HTTPS_URI_REGEX = /^https:\/\//;
                if (image.bufferView !== undefined) {
                    const bufferView = this._bufferViewLoader.getBufferView(image.bufferView);
                    const dataView = new DataView(bufferView);
                    const array = [];
                    for (let i = 0; i < dataView.byteLength; i += 1)
                        array[i] = dataView.getUint8(i);
                    const blob = new Blob([new Uint8Array(array)], {
                        type: image.mimeType,
                    });
                    const dataUri = URL.createObjectURL(blob);
                    const img = new Image();
                    promises.push(new Promise((resolve, reject) => {
                        img.onload = () => {
                            this._loaded[textureId] = {
                                image: img,
                                blob,
                            };
                            URL.revokeObjectURL(dataUri);
                            resolve();
                        };
                        img.onerror = reject;
                    }));
                    img.crossOrigin = "anonymous";
                    img.src = dataUri;
                }
                else {
                    const url = DATA_URI_REGEX.test(image.uri) ||
                        HTTPS_URI_REGEX.test(image.uri)
                        ? image.uri
                        : `${this._baseUri}/${image.uri}`;
                    promises.push(new Promise((resolve, reject) => {
                        this._httpClient
                            .loadTexture(url)
                            .then((response) => {
                            if (!response) {
                                resolve();
                            }
                            else {
                                if (response.data.image) {
                                    this._loaded[textureId] = {
                                        image: response.data.image,
                                        blob: response.data.blob,
                                    };
                                }
                                else {
                                    this._loaded[textureId] = {
                                        image: response.data.buffer,
                                        blob: response.data.blob,
                                    };
                                }
                                resolve();
                            }
                        })
                            .catch((e) => reject(e));
                    }));
                }
            }
            yield Promise.all(promises);
        });
    }
}
exports.TextureLoader = TextureLoader;
//# sourceMappingURL=TextureLoader.js.map
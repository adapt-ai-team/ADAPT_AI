"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorLoader = void 0;
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
class HTMLElementAnchorLoader {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (2)
        this._htmlElements = {};
        this._parentDiv = document.createElement("div");
        this._parentDiv.classList.add("sdv-anchor-container");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get parentDiv() {
        return this._parentDiv;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (5)
    adjustPositions(scaleWidth, scaleHeight) {
        for (const anchorId in this._htmlElements) {
            const anchor = this._htmlElements[anchorId].anchor;
            const { page, container, client, hidden } = this._renderingEngine.sceneTracingManager.convert3Dto2D(gl_matrix_1.vec3.clone(anchor.location));
            const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
            if (!htmlElement)
                continue;
            let node = this._htmlElements[anchorId].node;
            let visible = node.visible;
            while (node.parent) {
                node = node.parent;
                visible = node.visible && visible;
            }
            if (this._renderingEngine.show === false)
                visible = false;
            anchor.update({
                anchor,
                htmlElement,
                page,
                container,
                client,
                scale: gl_matrix_1.vec2.fromValues(scaleWidth, scaleHeight),
                hidden,
                visible,
            });
        }
    }
    init() {
        var _a;
        (_a = this._renderingEngine.canvas.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this._parentDiv);
    }
    load(node, anchor, isVisibleInHierarchy) {
        const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
        if (!htmlElement)
            return;
        // set the display property to "none" if the viewport is not shown or the node is not visible
        if (this._renderingEngine.show === false ||
            isVisibleInHierarchy === false)
            htmlElement.style.display = "none";
        // if the node is not visible return
        if (isVisibleInHierarchy === false)
            return;
        this._parentDiv.appendChild(htmlElement);
        this._htmlElements[anchor.id + "_" + anchor.version] = {
            node,
            anchor,
        };
    }
    removeData(id, version) {
        // since the data object might be there, but no data is loaded for this viewport
        // this check is needed
        if (!this._htmlElements[id + "_" + version])
            return;
        const anchor = this._htmlElements[id + "_" + version].anchor;
        if (anchor && anchor.getViewerHtmlElement(this._renderingEngine.id)) {
            this._parentDiv.removeChild(anchor.getViewerHtmlElement(this._renderingEngine.id));
            delete this._htmlElements[id + "_" + version];
        }
    }
    toggleBusyMode(toggle) {
        if (toggle &&
            this._renderingEngine.busyModeDisplay === viewer_shared_types_1.BUSY_MODE_DISPLAY.BLUR) {
            if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1 &&
                navigator.userAgent.toLowerCase().indexOf("android") > -1)
                return;
            this._parentDiv.style.filter = "blur(3px)";
        }
        else {
            this._parentDiv.style.filter = "";
        }
    }
}
exports.HTMLElementAnchorLoader = HTMLElementAnchorLoader;
//# sourceMappingURL=HTMLElementAnchorLoader.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureUnifierInjector = void 0;
const THREE = __importStar(require("three"));
class TextureUnifierInjector {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor() { }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    combineTextures(red, green, blue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!red && !green && !blue)
                throw new Error("No maps supplied.");
            if (red && red instanceof ArrayBuffer)
                return {
                    image: red,
                    blob: new Blob([new Uint8Array(red)], { type: "image/jpeg" }),
                };
            if (green && green instanceof ArrayBuffer)
                return {
                    image: green,
                    blob: new Blob([new Uint8Array(green)], { type: "image/jpeg" }),
                };
            if (blue && blue instanceof ArrayBuffer)
                return {
                    image: blue,
                    blob: new Blob([new Uint8Array(blue)], { type: "image/jpeg" }),
                };
            if (!this._renderer)
                this.createThreeJsUtils();
            let width = 0, height = 0;
            const textures = [red, green, blue];
            for (const t of textures) {
                if (t) {
                    if (width === 0 && height === 0) {
                        width = t.width;
                        height = t.height;
                    }
                    else if (t.width !== width && t.height !== height) {
                        throw new Error("Maps have different sizes. Combining not supported.");
                    }
                }
            }
            if (red) {
                const redTexture = new THREE.Texture(red);
                redTexture.needsUpdate = true;
                this._mergeShader.uniforms.tRed.value = redTexture;
                this._mergeShader.uniforms.activeRed.value = true;
            }
            else {
                this._mergeShader.uniforms.activeRed.value = false;
            }
            if (green) {
                const greenTexture = new THREE.Texture(green);
                greenTexture.needsUpdate = true;
                this._mergeShader.uniforms.tGreen.value = greenTexture;
                this._mergeShader.uniforms.activeGreen.value = true;
            }
            else {
                this._mergeShader.uniforms.activeGreen.value = false;
            }
            if (blue) {
                const blueTexture = new THREE.Texture(blue);
                blueTexture.needsUpdate = true;
                this._mergeShader.uniforms.tBlue.value = blueTexture;
                this._mergeShader.uniforms.activeBlue.value = true;
            }
            else {
                this._mergeShader.uniforms.activeBlue.value = false;
            }
            // The different render targets that are used by the passes
            const renderTarget = new THREE.WebGLRenderTarget(width, height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
            });
            renderTarget.texture.name = "target.rt";
            this._renderer.setRenderTarget(renderTarget);
            this._renderer.render(this._quadScene, this._quadCamera);
            const buffer = new Uint8ClampedArray(4 * width * height);
            this._renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);
            const imageData = new ImageData(buffer, width, height);
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            ctx.putImageData(imageData, 0, 0);
            const imageOut = new Image();
            const promises = [];
            promises.push(new Promise((resolve, reject) => {
                imageOut.onload = () => resolve();
                imageOut.onerror = reject;
            }));
            imageOut.crossOrigin = "anonymous";
            const mimeType = "image/jpeg";
            imageOut.src = canvas.toDataURL(mimeType, 1.0);
            let blob;
            promises.push(new Promise((resolve, reject) => {
                canvas.toBlob((b) => {
                    if (!b) {
                        reject("Could not create blob.");
                    }
                    else {
                        blob = b;
                    }
                    resolve();
                }, mimeType, 1.0);
            }));
            yield Promise.all(promises);
            return { image: imageOut, blob };
        });
    }
    // #endregion Public Methods (1)
    // #region Private Methods (1)
    createThreeJsUtils() {
        this._mergeShader = new THREE.ShaderMaterial({
            uniforms: {
                tRed: { value: null },
                activeRed: { value: false },
                defaultRed: { value: 1.0 },
                tGreen: { value: null },
                activeGreen: { value: false },
                defaultGreen: { value: 1.0 },
                tBlue: { value: null },
                activeBlue: { value: false },
                defaultBlue: { value: 1.0 },
            },
            vertexShader: `// @author Michael Oppitz 
        
            uniform sampler2D tRed;
            uniform bool activeRed;
            uniform float defaultRed;
            
            uniform sampler2D tGreen;		
            uniform bool activeGreen;
            uniform float defaultGreen;
            
            uniform sampler2D tBlue;		
            uniform bool activeBlue;
            uniform float defaultBlue;
        
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `// @author Michael Oppitz 
        
            uniform sampler2D tRed;
            uniform bool activeRed;
            uniform float defaultRed;
            
            uniform sampler2D tGreen;		
            uniform bool activeGreen;
            uniform float defaultGreen;
            
            uniform sampler2D tBlue;		
            uniform bool activeBlue;
            uniform float defaultBlue;
            
            varying vec2 vUv;
            
            void main() {
                vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);
        
                if(activeRed == true) {
                    outColor.r = texture2D(tRed, vUv).r;
                } else {
                    outColor.r = defaultRed;
                }
            
                if(activeGreen == true) {
                    outColor.g = texture2D(tGreen, vUv).g;
                } else {
                    outColor.g = defaultGreen;
                }
            
                if(activeBlue == true) {
                    outColor.b = texture2D(tBlue, vUv).b;
                } else {
                    outColor.b = defaultBlue;
                }
            
                gl_FragColor = outColor;
            }`,
        });
        this._quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this._quadScene = new THREE.Scene();
        this._quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this._mergeShader);
        this._quadScene.add(this._quad);
        this._renderer = new THREE.WebGLRenderer();
    }
}
exports.TextureUnifierInjector = TextureUnifierInjector;
//# sourceMappingURL=TextureUnifierInjector.js.map
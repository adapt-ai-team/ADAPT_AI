"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTracingManager = void 0;
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const THREE = __importStar(require("three"));
class SceneTracingManager {
    // #endregion Properties (1)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (1)
        this._raycaster = new THREE.Raycaster();
    }
    // #endregion Constructors (1)
    // #region Public Methods (3)
    convert3Dto2D(p) {
        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(), width = this._renderingEngine.canvas.width, height = this._renderingEngine.canvas.height;
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera)
            throw new viewer_shared_services_1.ShapeDiverViewerViewportError("SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.");
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.target, camera.position);
            const length = gl_matrix_1.vec3.length(direction);
            gl_matrix_1.vec3.divide(direction, direction, gl_matrix_1.vec3.fromValues(length, length, length));
            this._raycaster.ray.direction.set(direction[0], direction[1], direction[2]);
            // set the origin of the ray to the opposite direction of the camera with the start at the initial provided point
            this._raycaster.ray.origin.set(p[0] + direction[0] * length, p[1] + direction[1] * length, p[2] + direction[2] * length);
        }
        else {
            this._raycaster.ray.direction.set(p[0], p[1], p[2]);
            this._raycaster.ray.origin.set(0, 0, 0);
            camera.convertedObject[this._renderingEngine.id].localToWorld(this._raycaster.ray.origin);
            this._raycaster.ray.direction.sub(this._raycaster.ray.origin);
            this._raycaster.ray.direction.normalize();
        }
        let closestIntersectionDistance = Number.MAX_VALUE;
        this._renderingEngine.sceneTreeManager.scene.traverseVisible((obj) => {
            if (obj instanceof THREE.Mesh) {
                const curIntersections = this._raycaster.intersectObject(obj);
                if (curIntersections.length)
                    if (curIntersections[0].distance <
                        closestIntersectionDistance)
                        closestIntersectionDistance =
                            curIntersections[0].distance;
            }
        });
        const pos = camera.project(gl_matrix_1.vec3.clone(p));
        pos[0] = pos[0] * (width / 2) + width / 2;
        pos[1] = -(pos[1] * (height / 2)) + height / 2;
        // take care of correction by device pixel ratio
        pos[0] = pos[0] / devicePixelRatio;
        pos[1] = pos[1] / devicePixelRatio;
        // epsilon is added as a distance spacer as users tend to put the anchors of html elements directly at the vertices
        // with this we prevent flickering
        const eps = 0.0001;
        return {
            hidden: closestIntersectionDistance + eps <
                gl_matrix_1.vec3.distance(camera.position, p),
            container: gl_matrix_1.vec2.clone(pos),
            client: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),
            page: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset),
        };
    }
    init() { }
    /**
     * Calculate the ray that is created by the mouse event and the camera.
     *
     * @param event
     * @returns
     */
    pointerEventToRay(event) {
        const rect = this._renderingEngine.canvas.getBoundingClientRect();
        const camera = this._renderingEngine.cameraEngine.camera;
        if (!camera)
            throw new viewer_shared_services_1.ShapeDiverViewerViewportError("SceneTracingManager.pointerEventToRay: No camera is defined for this viewer.");
        const _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        let origin = gl_matrix_1.vec3.clone(camera.position);
        let direction;
        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {
            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));
            }
            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));
            }
            else {
                // for the custom camera, the origin is on the camera plane and needs to be rotated according to the direction
                direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.target, camera.position));
                const up = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), camera.up);
                const right = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), direction, up));
                const x = _mouse_x * camera.right;
                const y = _mouse_y * camera.top;
                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), right, x), gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), up, y)));
            }
        }
        if (!direction)
            direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));
        return { origin, direction };
    }
}
exports.SceneTracingManager = SceneTracingManager;
//# sourceMappingURL=SceneTracingManager.js.map
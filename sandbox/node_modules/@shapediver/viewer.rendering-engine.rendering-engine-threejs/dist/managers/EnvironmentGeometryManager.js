"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvironmentGeometryManager = void 0;
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const SDObject_1 = require("../objects/SDObject");
const ContactShadow_1 = require("./environmentGeometry/ContactShadow");
const Grid_1 = require("./environmentGeometry/Grid");
const GroundPlane_1 = require("./environmentGeometry/GroundPlane");
const GroundPlaneShadow_1 = require("./environmentGeometry/GroundPlaneShadow");
class EnvironmentGeometryManager {
    // #endregion Properties (9)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (9)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._initialized = false;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, () => {
            this.updateEnvironmentGeometryPosition();
        });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (5)
    get contactShadow() {
        return this._contactShadow;
    }
    get grid() {
        return this._grid;
    }
    get groundPlane() {
        return this._groundPlane;
    }
    get groundPlaneShadow() {
        return this._groundPlaneShadow;
    }
    // #endregion Public Getters And Setters (5)
    // #region Public Methods (3)
    changeSceneExtents(bb) {
        var _a, _b, _c, _d;
        if ((bb.min[0] === 0 &&
            bb.min[1] === 0 &&
            bb.min[2] === 0 &&
            bb.max[0] === 0 &&
            bb.max[1] === 0 &&
            bb.max[2] === 0) ||
            bb.isEmpty())
            return;
        this._initialized = true;
        const sceneExtents = gl_matrix_1.vec3.distance(bb.min, bb.max);
        const { divisions, gridExtents } = this.evaluateGridMeasurements(sceneExtents);
        const bs = bb.boundingSphere;
        const position = gl_matrix_1.vec3.fromValues(bs.center[0], bs.center[1], bb.min[2]);
        const eps = bb.boundingSphere.radius * 0.001;
        (_a = this._grid) === null || _a === void 0 ? void 0 : _a.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps)), divisions, gridExtents);
        (_b = this._groundPlaneShadow) === null || _b === void 0 ? void 0 : _b.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 3)), divisions, gridExtents);
        (_c = this._contactShadow) === null || _c === void 0 ? void 0 : _c.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 2)), divisions, gridExtents);
        (_d = this._groundPlane) === null || _d === void 0 ? void 0 : _d.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 4)), divisions, gridExtents);
    }
    init() {
        this._environmentGeometryObject = new SDObject_1.SDObject("environmentGeometry", "");
        this._renderingEngine.sceneTreeManager.scene.add(this._environmentGeometryObject);
        this._contactShadow = new ContactShadow_1.ContactShadow(this._renderingEngine, this._environmentGeometryObject);
        this._grid = new Grid_1.Grid(this._renderingEngine, this._environmentGeometryObject);
        this._groundPlaneShadow = new GroundPlaneShadow_1.GroundPlaneShadow(this._renderingEngine, this._environmentGeometryObject);
        this._groundPlane = new GroundPlane_1.GroundPlane(this._renderingEngine, this._environmentGeometryObject);
    }
    updateEnvironmentGeometryPosition() {
        var _a, _b, _c, _d;
        const bb = new viewer_shared_math_1.Box(this._renderingEngine.sceneTreeManager.boundingBox.min, this._renderingEngine.sceneTreeManager.boundingBox.max);
        if ((bb.min[0] === 0 &&
            bb.min[1] === 0 &&
            bb.min[2] === 0 &&
            bb.max[0] === 0 &&
            bb.max[1] === 0 &&
            bb.max[2] === 0) ||
            bb.isEmpty())
            return;
        if (!this._initialized) {
            this.changeSceneExtents(bb);
        }
        else {
            const bs = bb.boundingSphere;
            const eps = bb.boundingSphere.radius * 0.001;
            const sceneExtents = gl_matrix_1.vec3.distance(bb.min, bb.max);
            const { divisions, gridExtents } = this.evaluateGridMeasurements(sceneExtents);
            // only shadow plane needs to be updated
            const position = gl_matrix_1.vec3.fromValues(bs.center[0], bs.center[1], bb.min[2]);
            (_a = this._grid) === null || _a === void 0 ? void 0 : _a.updatePosition(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps)));
            (_b = this._contactShadow) === null || _b === void 0 ? void 0 : _b.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 3)), divisions, gridExtents);
            (_c = this._groundPlaneShadow) === null || _c === void 0 ? void 0 : _c.changeSceneExtents(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 2)), divisions, gridExtents);
            (_d = this._groundPlane) === null || _d === void 0 ? void 0 : _d.updatePosition(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, gl_matrix_1.vec3.fromValues(0, 0, eps * 4)));
        }
    }
    // #endregion Public Methods (3)
    // #region Private Methods (1)
    /**
     * Creates the grid extents and divisions with the specified scene extents.
     *
     * https://shapediver.atlassian.net/browse/SS-2961 evaluate this magic.
     */
    evaluateGridMeasurements(sceneExtents) {
        let divisions = 0.1;
        let gridExtents = 1.0;
        if (sceneExtents > 1) {
            const tmp = Math.floor(sceneExtents).toString();
            let temp = Math.pow(10, tmp.length - 1);
            gridExtents = Math.max(Math.ceil(sceneExtents / temp) * temp, 1);
            temp = temp / 10;
            divisions = gridExtents / temp;
        }
        else if (sceneExtents !== 0) {
            const zeros = 1 - Math.floor(Math.log(sceneExtents) / Math.log(10)) - 2;
            const r = sceneExtents.toFixed(zeros + 1);
            const firstDigit = parseInt(r.substr(r.length - 1)) + 1;
            let gridExtentsS = "0.";
            for (let i = 0; i < zeros; ++i)
                gridExtentsS = gridExtentsS + "0";
            gridExtents = parseFloat(gridExtentsS + firstDigit);
            divisions = firstDigit * 10;
        }
        return { divisions, gridExtents };
    }
}
exports.EnvironmentGeometryManager = EnvironmentGeometryManager;
//# sourceMappingURL=EnvironmentGeometryManager.js.map
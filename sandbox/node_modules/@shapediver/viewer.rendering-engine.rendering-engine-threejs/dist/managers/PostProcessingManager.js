"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostProcessingManager = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
const postprocessing_1 = require("postprocessing");
const THREE = __importStar(require("three"));
const IPostProcessingEffectDefinitions_1 = require("../interfaces/IPostProcessingEffectDefinitions");
const HBAOEffect_1 = require("./postprocessing/ao/hbao/HBAOEffect");
const PoissionDenoisePass_1 = require("./postprocessing/ao/poissionDenoise/PoissionDenoisePass");
const SSAOEffect_1 = require("./postprocessing/ao/ssao/SSAOEffect");
const ToneMappingEffect_1 = require("./postprocessing/effects/tone-mapping/ToneMappingEffect");
const GodRaysManager_1 = require("./postprocessing/GodRaysManager");
const OutlineManager_1 = require("./postprocessing/OutlineManager");
const SelectiveBloomManager_1 = require("./postprocessing/SelectiveBloomManager");
const SSAARenderPass_1 = require("./postprocessing/SSAARenderPass");
class PostProcessingManager {
    // #endregion Properties (23)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (23)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._systemInfo = viewer_shared_services_1.SystemInfo.instance;
        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;
        this._antiAliasingTechnique = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA;
        this._currentCameraId = "";
        this._effectDefinitions = [];
        this._effects = [];
        this._enablePostProcessingOnMobile = true;
        this._godRaysManagers = {};
        this._initialized = false;
        this._manualPostProcessing = false;
        this._outlineManagers = {};
        this._sceneExtents = 0;
        this._selectiveBloomManagers = {};
        this._suspendEffectPassUpdate = false;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewportId === this._renderingEngine.id) {
                this._sceneExtents = gl_matrix_1.vec3.distance(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                this.changeEffectPass();
            }
        });
        // const token = this._uuidGenerator.create();
        // this._effectDefinitions.push({
        //     token,
        //     definition: {
        //         type: POST_PROCESSING_EFFECT_TYPE.SSAO,
        //         properties: this.getDefaultEffectProperties(POST_PROCESSING_EFFECT_TYPE.SSAO)
        //     }
        // });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (16)
    get antiAliasingTechnique() {
        return this._antiAliasingTechnique;
    }
    set antiAliasingTechnique(value) {
        this._antiAliasingTechnique = value;
        this.changeEffectPass();
    }
    get antiAliasingTechniqueMobile() {
        return this._antiAliasingTechniqueMobile;
    }
    set antiAliasingTechniqueMobile(value) {
        this._antiAliasingTechniqueMobile = value;
        // we don't allow SSAA on mobile devices anymore as it is too slow
        if (this._antiAliasingTechniqueMobile === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA)
            this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this.changeEffectPass();
    }
    get effectComposer() {
        return this._composer;
    }
    get effects() {
        return this._effects;
    }
    get enablePostProcessingOnMobile() {
        return this._enablePostProcessingOnMobile;
    }
    set enablePostProcessingOnMobile(value) {
        this._enablePostProcessingOnMobile = value;
    }
    get godRaysManagers() {
        return this._godRaysManagers;
    }
    get initialized() {
        return this._initialized;
    }
    get manualPostProcessing() {
        return this._manualPostProcessing;
    }
    set manualPostProcessing(value) {
        this._manualPostProcessing = value;
        if (this._composer && this._manualPostProcessing === true)
            this._composer.removeAllPasses();
    }
    get outlineManagers() {
        return this._outlineManagers;
    }
    get selectiveBloomManagers() {
        return this._selectiveBloomManagers;
    }
    get ssaaSampleLevel() {
        return this._ssaaRenderPass ? this._ssaaRenderPass.sampleLevel : 2;
    }
    set ssaaSampleLevel(value) {
        if (this._ssaaRenderPass)
            this._ssaaRenderPass.sampleLevel = value;
    }
    // #endregion Public Getters And Setters (16)
    // #region Public Methods (13)
    addEffect(definition, t) {
        const token = t || this._uuidGenerator.create();
        this._effectDefinitions.push({ token, definition });
        switch (definition.type) {
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                if (!this._godRaysManagers[token])
                    this._godRaysManagers[token] = new GodRaysManager_1.GodRaysManager(this._renderingEngine);
                break;
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                if (!this._outlineManagers[token])
                    this._outlineManagers[token] = new OutlineManager_1.OutlineManager(this._renderingEngine);
                break;
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                if (!this._selectiveBloomManagers[token])
                    this._selectiveBloomManagers[token] =
                        new SelectiveBloomManager_1.SelectiveBloomManager(this._renderingEngine);
                break;
            default:
        }
        this.changeEffectPass();
        return token;
    }
    applySettings(settingsEngine) {
        this._suspendEffectPassUpdate = true;
        this.antiAliasingTechnique = settingsEngine.settings.postprocessing
            .antiAliasingTechnique;
        this.antiAliasingTechniqueMobile = settingsEngine.settings
            .postprocessing
            .antiAliasingTechniqueMobile;
        // we don't allow SSAA on mobile devices anymore as it is too slow
        if (this._antiAliasingTechniqueMobile === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA)
            this._antiAliasingTechniqueMobile = IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA;
        this.enablePostProcessingOnMobile =
            settingsEngine.settings.postprocessing.enablePostProcessingOnMobile;
        this.ssaaSampleLevel =
            settingsEngine.settings.postprocessing.ssaaSampleLevel;
        this._effectDefinitions = [];
        const effects = settingsEngine.settings.postprocessing.effects;
        for (let i = 0; i < effects.length; i++) {
            const token = this._uuidGenerator.create();
            this._effectDefinitions.push({
                token,
                definition: {
                    type: effects[i].type,
                    properties: effects[i].properties,
                },
            });
        }
        this._suspendEffectPassUpdate = false;
        this.changeEffectPass();
    }
    changeEffectPass() {
        if (!this._composer)
            return;
        if (this._suspendEffectPassUpdate === true)
            return;
        if (this._systemInfo.isMobile === true &&
            this._enablePostProcessingOnMobile === false)
            return;
        if (this._manualPostProcessing)
            return;
        for (let i = 0; i < this._composer.passes.length; i++)
            this._composer.passes[i].dispose();
        this._composer.removeAllPasses();
        const antiAliasingTechnique = this._systemInfo.isMobile === true
            ? this._antiAliasingTechniqueMobile
            : this._antiAliasingTechnique;
        if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SSAA) {
            this.addPassToEffectComposer(this._ssaaRenderPass);
        }
        else {
            this.addPassToEffectComposer(this._renderPass);
        }
        // remove the effects where the tokens are not in the effectDefinitions
        this._effects.forEach((e) => e.effect.dispose());
        this._effects = [];
        for (let i = 0; i < this._effectDefinitions.length; i++) {
            switch (this._effectDefinitions[i].definition.type) {
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.BloomEffect({
                                blendFunction: properties.blendFunction,
                                luminanceThreshold: properties.luminanceThreshold,
                                luminanceSmoothing: properties.luminanceSmoothing,
                                mipmapBlur: properties.mipmapBlur,
                                intensity: properties.intensity,
                                kernelSize: properties.kernelSize,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                    {
                        const definition = this._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        const offsetArray = properties.offset !== undefined
                            ? Array.isArray(properties.offset)
                                ? properties.offset
                                : [
                                    properties.offset.x,
                                    properties.offset.y,
                                ]
                            : undefined;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.ChromaticAberrationEffect({
                                blendFunction: properties.blendFunction,
                                offset: offsetArray
                                    ? new THREE.Vector2(...offsetArray)
                                    : undefined,
                                radialModulation: properties.radialModulation !== undefined
                                    ? properties.radialModulation
                                    : false,
                                modulationOffset: properties.modulationOffset !== undefined
                                    ? properties.modulationOffset
                                    : 0.15,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        const depthOfFieldEffect = new postprocessing_1.DepthOfFieldEffect(this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction,
                            focusDistance: properties.focusDistance !== undefined
                                ? properties.focusDistance
                                : 0,
                            focusRange: properties.focusRange !== undefined
                                ? properties.focusRange
                                : 0.01,
                            bokehScale: properties.bokehScale !== undefined
                                ? properties.bokehScale
                                : 5,
                            resolutionScale: 1,
                        });
                        depthOfFieldEffect.resolution.height = 1080;
                        depthOfFieldEffect.blurPass.kernelSize =
                            postprocessing_1.KernelSize.HUGE;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: depthOfFieldEffect,
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.DotScreenEffect({
                                blendFunction: properties.blendFunction,
                                scale: properties.scale,
                                angle: properties.angle,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        const godRaysEffect = new postprocessing_1.GodRaysEffect(this._renderingEngine.camera, new THREE.Mesh(), {
                            blendFunction: properties.blendFunction,
                            density: properties.density,
                            decay: properties.decay,
                            weight: properties.weight,
                            exposure: properties.exposure,
                            clampMax: properties.clampMax,
                            kernelSize: properties.kernelSize,
                            blur: properties.blur,
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: godRaysEffect,
                        });
                        this._godRaysManagers[this._effectDefinitions[i].token].setEffect(godRaysEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.GridEffect({
                                blendFunction: properties.blendFunction !== undefined
                                    ? properties.blendFunction
                                    : postprocessing_1.BlendFunction.MULTIPLY,
                                scale: properties.scale,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                    {
                        // we currently do not support devices with WebGL 1: https://shapediver.atlassian.net/browse/SS-7069
                        if (this._renderingEngine.renderer.capabilities
                            .isWebGL2 === false)
                            break;
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        // we adjust the scene size slightly to make the factor fit our requirements
                        // with this adjusted factor, a distance value of 1 fits well as a default
                        const sceneSizeFactor = this._sceneExtents / 10.0;
                        const hbaoEffect = new HBAOEffect_1.HBAOEffect(this._composer, this._renderingEngine.camera, this._renderingEngine.scene, {
                            resolutionScale: properties.resolutionScale !== undefined
                                ? properties.resolutionScale
                                : 1,
                            spp: properties.spp !== undefined
                                ? properties.spp
                                : 16,
                            distance: properties.distance !== undefined
                                ? properties.distance * sceneSizeFactor
                                : sceneSizeFactor,
                            distancePower: properties.distanceIntensity !== undefined
                                ? properties.distanceIntensity
                                : 1,
                            power: properties.intensity !== undefined
                                ? properties.intensity
                                : 2.5,
                            bias: properties.bias !== undefined
                                ? properties.bias
                                : 10,
                            thickness: properties.thickness !== undefined
                                ? properties.thickness
                                : 0.5,
                            color: properties.color !== undefined
                                ? new THREE.Color(this._converter
                                    .toHexColor(properties.color)
                                    .substring(0, 7))
                                : new THREE.Color("black"),
                            iterations: properties.iterations !== undefined
                                ? properties.iterations
                                : 1,
                            radius: properties.radius !== undefined
                                ? properties.radius
                                : 12,
                            rings: properties.rings !== undefined
                                ? properties.rings
                                : 11,
                            lumaPhi: properties.lumaPhi !== undefined
                                ? properties.lumaPhi
                                : 10,
                            depthPhi: properties.depthPhi !== undefined
                                ? properties.depthPhi
                                : 2,
                            normalPhi: properties.normalPhi !== undefined
                                ? properties.normalPhi
                                : 3.25,
                            samples: properties.samples !== undefined
                                ? properties.samples
                                : 16,
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: hbaoEffect,
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.HueSaturationEffect({
                                blendFunction: properties.blendFunction,
                                hue: properties.hue,
                                saturation: properties.saturation,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.NoiseEffect({
                                blendFunction: properties.blendFunction,
                                premultiply: properties.premultiply,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        const outlineEffect = new postprocessing_1.OutlineEffect(this._renderingEngine.scene, this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction !== undefined
                                ? properties.blendFunction
                                : postprocessing_1.BlendFunction.SCREEN,
                            edgeStrength: properties.edgeStrength,
                            pulseSpeed: properties.pulseSpeed,
                            visibleEdgeColor: (new THREE.Color(this._converter
                                .toHexColor(properties.visibleEdgeColor)
                                .substring(0, 7))),
                            hiddenEdgeColor: (new THREE.Color(this._converter
                                .toHexColor(properties.hiddenEdgeColor)
                                .substring(0, 7))),
                            kernelSize: properties.kernelSize,
                            blur: properties.blur,
                            xRay: properties.xRay,
                            multisampling: properties.multisampling,
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: outlineEffect,
                        });
                        this._outlineManagers[this._effectDefinitions[i].token].setEffect(outlineEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.PixelationEffect(properties.granularity),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                    {
                        // we currently do not support devices with WebGL 1: https://shapediver.atlassian.net/browse/SS-7069
                        if (this._renderingEngine.renderer.capabilities
                            .isWebGL2 === false)
                            break;
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        // we adjust the scene size slightly to make the factor fit our requirements
                        // with this adjusted factor, a distance value of 1 fits well as a default
                        const sceneSizeFactor = this._sceneExtents / 50.0;
                        const ssaoEffect = new SSAOEffect_1.SSAOEffect(this._composer, this._renderingEngine.camera, this._renderingEngine.scene, {
                            resolutionScale: properties.resolutionScale !== undefined
                                ? properties.resolutionScale
                                : 1,
                            spp: properties.spp !== undefined
                                ? properties.spp
                                : 16,
                            distance: properties.distance !== undefined
                                ? properties.distance * sceneSizeFactor
                                : sceneSizeFactor,
                            distancePower: properties.distanceIntensity !== undefined
                                ? properties.distanceIntensity
                                : 1,
                            power: properties.intensity !== undefined
                                ? properties.intensity
                                : 2.5,
                            color: properties.color !== undefined
                                ? new THREE.Color(this._converter
                                    .toHexColor(properties.color)
                                    .substring(0, 7))
                                : new THREE.Color("black"),
                            iterations: properties.iterations !== undefined
                                ? properties.iterations
                                : 1,
                            radius: properties.radius !== undefined
                                ? properties.radius
                                : 12,
                            rings: properties.rings !== undefined
                                ? properties.rings
                                : 11,
                            lumaPhi: properties.lumaPhi !== undefined
                                ? properties.lumaPhi
                                : 10,
                            depthPhi: properties.depthPhi !== undefined
                                ? properties.depthPhi
                                : 2,
                            normalPhi: properties.normalPhi !== undefined
                                ? properties.normalPhi
                                : 3.25,
                            samples: properties.samples !== undefined
                                ? properties.samples
                                : 16,
                        });
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: ssaoEffect,
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.ScanlineEffect({
                                blendFunction: properties.blendFunction,
                                density: properties.density,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        const selectiveBloomEffect = new postprocessing_1.SelectiveBloomEffect(this._renderingEngine.scene, this._renderingEngine.camera, {
                            blendFunction: properties.blendFunction,
                            mipmapBlur: properties.mipmapBlur,
                            luminanceThreshold: properties.luminanceThreshold,
                            luminanceSmoothing: properties.luminanceSmoothing,
                            intensity: properties.intensity,
                            kernelSize: properties.kernelSize,
                        });
                        selectiveBloomEffect.ignoreBackground =
                            properties.ignoreBackground !== undefined
                                ? properties.ignoreBackground
                                : true;
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: selectiveBloomEffect,
                        });
                        this._selectiveBloomManagers[this._effectDefinitions[i].token].setEffect(selectiveBloomEffect);
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.SepiaEffect({
                                blendFunction: properties.blendFunction,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.TiltShiftEffect({
                                blendFunction: properties.blendFunction,
                                offset: properties.offset,
                                rotation: properties.rotation,
                                focusArea: properties.focusArea,
                                feather: properties.feather,
                                kernelSize: properties.kernelSize,
                            }),
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        this._effects.push({
                            token: this._effectDefinitions[i].token,
                            effect: new postprocessing_1.VignetteEffect({
                                blendFunction: properties.blendFunction,
                                technique: properties.technique,
                                offset: properties.offset,
                                darkness: properties.darkness,
                            }),
                        });
                    }
                    break;
                default:
            }
        }
        // sort effects by order in effectDefinitions
        this._effects.sort((a, b) => this._effectDefinitions.indexOf(this._effectDefinitions.find((e) => e.token === a.token)) -
            this._effectDefinitions.indexOf(this._effectDefinitions.find((e) => e.token === b.token)));
        const effectArray = this._effects.map((v) => v.effect);
        if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA) {
            effectArray.unshift(this._fxaaEffect);
        }
        else if (antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.SMAA) {
            effectArray.unshift(this._smaaEffect);
        }
        this._effectPass = new postprocessing_1.EffectPass(this._renderingEngine.camera, ...this._effects.map((v) => v.effect));
        this.addPassToEffectComposer(this._effectPass);
        // for the AO effects we need to add a separate AA pass at the end that anti-aliases the AO effect
        if (this._effectDefinitions.find((e) => e.definition.type === IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO ||
            e.definition.type === IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO)) {
            // respect the AA choice if one of the effects was selected, use SMAA otherwise
            this.addPassToEffectComposer(new postprocessing_1.EffectPass(this._renderingEngine.camera, antiAliasingTechnique === IPostProcessingEffectDefinitions_1.ANTI_ALIASING_TECHNIQUE.FXAA
                ? this._fxaaEffect
                : this._smaaEffect));
        }
        if (this._renderingEngine.toneMapping !== viewer_shared_types_1.TONE_MAPPING.NONE) {
            const mode = (() => {
                switch (this._renderingEngine.toneMapping) {
                    case viewer_shared_types_1.TONE_MAPPING.ACES_FILMIC:
                        return postprocessing_1.ToneMappingMode.ACES_FILMIC;
                    case viewer_shared_types_1.TONE_MAPPING.CINEON:
                        return postprocessing_1.ToneMappingMode.OPTIMIZED_CINEON;
                    case viewer_shared_types_1.TONE_MAPPING.REINHARD:
                        return postprocessing_1.ToneMappingMode.REINHARD;
                    default:
                        return postprocessing_1.ToneMappingMode.LINEAR;
                }
            })();
            this._toneMappingEffect = new ToneMappingEffect_1.ToneMappingEffect({ mode });
            const effectPass = new postprocessing_1.EffectPass(this._renderingEngine.camera, this._toneMappingEffect);
            this.addPassToEffectComposer(effectPass);
        }
    }
    getDefaultEffectProperties(type) {
        switch (type) {
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                return {
                    blendFunction: postprocessing_1.BlendFunction.ADD,
                    intensity: 1.0,
                    kernelSize: postprocessing_1.KernelSize.LARGE,
                    luminanceSmoothing: 0.025,
                    luminanceThreshold: 0.9,
                    mipmapBlur: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    modulationOffset: 0.15,
                    offset: { x: 0.001, y: 0.0005 },
                    radialModulation: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    bokehScale: 5.0,
                    focusDistance: 0.0,
                    focusRange: 0.01,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                return {
                    angle: 1.57,
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    scale: 1.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GOD_RAYS:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    blur: true,
                    clampMax: 1.0,
                    decay: 0.9,
                    density: 0.96,
                    exposure: 0.6,
                    kernelSize: postprocessing_1.KernelSize.SMALL,
                    weight: 0.4,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                return {
                    blendFunction: postprocessing_1.BlendFunction.MULTIPLY,
                    scale: 1.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                return {
                    resolutionScale: 1,
                    spp: 16,
                    distance: 1,
                    distanceIntensity: 1,
                    intensity: 2.5,
                    color: "#000000",
                    bias: 10,
                    thickness: 0.5,
                    iterations: 1,
                    radius: 12,
                    rings: 11,
                    lumaPhi: 10,
                    depthPhi: 2,
                    normalPhi: 3.25,
                    samples: 16,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    hue: 0.0,
                    saturation: 0.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    premultiply: false,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.OUTLINE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.SCREEN,
                    blur: false,
                    edgeStrength: 1.0,
                    hiddenEdgeColor: "#22090a",
                    kernelSize: postprocessing_1.KernelSize.VERY_SMALL,
                    multisampling: 0,
                    pulseSpeed: 0.0,
                    resolution: 480,
                    visibleEdgeColor: "#ffffff",
                    xRay: true,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                return {
                    granularity: 30.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                return {
                    resolutionScale: 1,
                    spp: 16,
                    distance: 1,
                    distanceIntensity: 1,
                    intensity: 2.5,
                    color: "#000000",
                    iterations: 1,
                    radius: 12,
                    rings: 11,
                    lumaPhi: 10,
                    depthPhi: 2,
                    normalPhi: 3.25,
                    samples: 16,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.OVERLAY,
                    density: 1.25,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SELECTIVE_BLOOM:
                return {
                    blendFunction: postprocessing_1.BlendFunction.ADD,
                    intensity: 1.0,
                    kernelSize: postprocessing_1.KernelSize.LARGE,
                    luminanceSmoothing: 0.025,
                    luminanceThreshold: 0.9,
                    mipmapBlur: false,
                    ignoreBackground: true,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    feather: 0.3,
                    focusArea: 0.4,
                    kernelSize: postprocessing_1.KernelSize.MEDIUM,
                    offset: 0.0,
                    rotation: 0.0,
                };
            case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                return {
                    blendFunction: postprocessing_1.BlendFunction.NORMAL,
                    darkness: 0.5,
                    offset: 0.5,
                    technique: postprocessing_1.VignetteTechnique.DEFAULT,
                };
            default:
                return {};
        }
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initialized)
                return;
            // wait for the blue noise texture to be loaded before initializing the composer
            yield PoissionDenoisePass_1.PoissionDenoisePass.loadBlueNoiseTexture();
            yield new Promise((resolve) => setTimeout(resolve, 0));
            this._initialized = true;
            return;
        });
    }
    getEffect(token) {
        return this._effects.find((e) => e.token === token).effect;
    }
    getEffectTokens() {
        return Object.assign({}, ...this._effectDefinitions.map((e) => ({
            [e.token]: e.definition.type,
        })));
    }
    getPostProcessingEffectsArray() {
        const effects = [];
        for (let i = 0; i < this._effectDefinitions.length; i++) {
            switch (this._effectDefinitions[i].definition.type) {
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.BLOOM,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                luminanceThreshold: properties.luminanceThreshold,
                                luminanceSmoothing: properties.luminanceSmoothing,
                                mipmapBlur: properties.mipmapBlur,
                                intensity: properties.intensity,
                                kernelSize: properties.kernelSize,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION:
                    {
                        const definition = this._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.CHROMATIC_ABERRATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                offset: properties.offset
                                    ? Array.isArray(properties.offset)
                                        ? {
                                            x: properties.offset[0],
                                            y: properties.offset[1],
                                        }
                                        : properties.offset
                                    : undefined,
                                radialModulation: properties.radialModulation,
                                modulationOffset: properties.modulationOffset,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DEPTH_OF_FIELD,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                focusDistance: properties.focusDistance,
                                focusRange: properties.focusRange,
                                bokehScale: properties.bokehScale,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.DOT_SCREEN,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                scale: properties.scale,
                                angle: properties.angle,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.GRID,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                scale: properties.scale,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HBAO,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                resolutionScale: properties.resolutionScale,
                                spp: properties.spp,
                                distance: properties.distance,
                                distanceIntensity: properties.distanceIntensity,
                                intensity: properties.intensity,
                                bias: properties.bias,
                                thickness: properties.thickness,
                                color: properties.color !== undefined
                                    ? this._converter.toHexColor(properties.color)
                                    : undefined,
                                iterations: properties.iterations,
                                radius: properties.radius,
                                rings: properties.rings,
                                lumaPhi: properties.lumaPhi,
                                depthPhi: properties.depthPhi,
                                normalPhi: properties.normalPhi,
                                samples: properties.samples,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.HUE_SATURATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                hue: properties.hue,
                                saturation: properties.saturation,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.NOISE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                premultiply: properties.premultiply,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.PIXELATION,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                granularity: properties.granularity,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SSAO,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                resolutionScale: properties.resolutionScale,
                                spp: properties.spp,
                                distance: properties.distance,
                                distanceIntensity: properties.distanceIntensity,
                                intensity: properties.intensity,
                                color: properties.color !== undefined
                                    ? this._converter.toHexColor(properties.color)
                                    : undefined,
                                iterations: properties.iterations,
                                radius: properties.radius,
                                rings: properties.rings,
                                lumaPhi: properties.lumaPhi,
                                depthPhi: properties.depthPhi,
                                normalPhi: properties.normalPhi,
                                samples: properties.samples,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SCANLINE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                density: properties.density,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.SEPIA,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.TILT_SHIFT,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                offset: properties.offset,
                                rotation: properties.rotation,
                                focusArea: properties.focusArea,
                                feather: properties.feather,
                                kernelSize: properties.kernelSize,
                            },
                        });
                    }
                    break;
                case IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE:
                    {
                        const definition = this
                            ._effectDefinitions[i]
                            .definition;
                        const properties = definition.properties || {};
                        effects.push({
                            type: IPostProcessingEffectDefinitions_1.POST_PROCESSING_EFFECT_TYPE.VIGNETTE,
                            token: this._effectDefinitions[i].token,
                            properties: {
                                blendFunction: properties.blendFunction,
                                technique: properties.technique,
                                offset: properties.offset,
                                darkness: properties.darkness,
                            },
                        });
                    }
                    break;
                default:
            }
        }
        return effects;
    }
    init() {
        postprocessing_1.OverrideMaterialManager.workaroundEnabled = true;
        const initComposer = () => {
            this._composer = new postprocessing_1.EffectComposer(this._renderingEngine.renderer);
            // EffectComposer disables autoClear, we enable/disable this in the postprocessing render loop
            this._renderingEngine.renderer.autoClear = true;
            // create anti-aliasing effects and passes
            this._fxaaEffect = new postprocessing_1.FXAAEffect();
            this._smaaEffect = new postprocessing_1.SMAAEffect({ preset: postprocessing_1.SMAAPreset.ULTRA });
            this._renderPass = new postprocessing_1.RenderPass(this._renderingEngine.scene, this._renderingEngine.camera);
            this._ssaaRenderPass = new SSAARenderPass_1.SSAARenderPass(this._renderingEngine.scene, this._renderingEngine.camera);
        };
        if (this._sceneExtents === 0) {
            const token = this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => __awaiter(this, void 0, void 0, function* () {
                const viewerEvent = e;
                if (viewerEvent.viewportId === this._renderingEngine.id) {
                    if (gl_matrix_1.vec3.distance(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max) > 0) {
                        initComposer();
                        this.changeEffectPass();
                        this._eventEngine.removeListener(token);
                    }
                }
            }));
        }
        else {
            initComposer();
        }
    }
    removeEffect(token) {
        const effectToRemove = this._effectDefinitions.find((e) => e.token === token);
        if (effectToRemove)
            this._effectDefinitions.splice(this._effectDefinitions.indexOf(effectToRemove), 1);
        this.changeEffectPass();
        return true;
    }
    render(deltaTime, camera) {
        if (!this._composer)
            return;
        const cameraId = `${camera.id}_${camera.type}${camera.type === "PerspectiveCamera" ? "" : "_" + camera.up.toArray().toString()}`;
        if (cameraId !== this._currentCameraId) {
            this._currentCameraId = cameraId;
            this.changeEffectPass();
        }
        const currentToneMapping = this._renderingEngine.renderer.toneMapping;
        const currentClearColor = this._renderingEngine.renderer.getClearColor(new THREE.Color());
        const convertedClearColor = currentClearColor
            .clone()
            .convertSRGBToLinear();
        this._renderingEngine.renderer.toneMapping = THREE.NoToneMapping;
        this._renderingEngine.renderer.setClearColor(convertedClearColor);
        this._renderingEngine.renderer.setClearAlpha(this._renderingEngine.clearAlpha);
        this._renderingEngine.renderer.autoClear = false;
        this._composer.setMainCamera(camera);
        this._composer.render();
        this._renderingEngine.renderer.toneMapping = currentToneMapping;
        this._renderingEngine.renderer.autoClear = true;
        this._renderingEngine.renderer.setClearColor(currentClearColor);
    }
    resize(width, height) {
        var _a;
        if (!this._composer)
            return;
        this.effects.forEach((e) => {
            if (e.effect.setSize)
                e.effect.setSize(width, height);
        });
        this._renderPass.setSize(width, height);
        this._ssaaRenderPass.setSize(width, height);
        (_a = this._effectPass) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
        this._composer.setSize(width, height);
    }
    saveSettings(settingsEngine) {
        settingsEngine.settings.postprocessing.antiAliasingTechnique =
            this.antiAliasingTechnique;
        settingsEngine.settings.postprocessing.antiAliasingTechniqueMobile =
            this.antiAliasingTechniqueMobile;
        settingsEngine.settings.postprocessing.enablePostProcessingOnMobile =
            this.enablePostProcessingOnMobile;
        settingsEngine.settings.postprocessing.ssaaSampleLevel =
            this.ssaaSampleLevel;
        const effects = this.getPostProcessingEffectsArray();
        // delete the tokens as we don't want to save them
        effects.forEach((e) => delete e.token);
        settingsEngine.settings.postprocessing.effects = effects;
    }
    updateEffect(token, definition) {
        const effectDefinition = this._effectDefinitions.find((e) => e.token === token);
        if (!effectDefinition)
            return;
        this.removeEffect(token);
        this.addEffect(definition, token);
    }
    // #endregion Public Methods (13)
    // #region Private Methods (1)
    addPassToEffectComposer(pass) {
        if (this._composer) {
            try {
                this._composer.addPass(pass);
            }
            catch (e) {
                // in this case a WebGL error is thrown, when the WebGL context is lost
                // as we already throw an error in the rendering engine, we can ignore this error here
                // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getContextAttributes
            }
        }
    }
}
exports.PostProcessingManager = PostProcessingManager;
//# sourceMappingURL=PostProcessingManager.js.map
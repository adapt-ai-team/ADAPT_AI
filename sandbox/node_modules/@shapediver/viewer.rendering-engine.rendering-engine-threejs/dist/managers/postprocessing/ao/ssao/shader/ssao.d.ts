export declare const ssao = "\nvarying vec2 vUv;\n\nuniform highp sampler2D depthTexture;\nuniform mat4 projectionViewMatrix;\nuniform mat4 cameraMatrixWorld;\n\nuniform sampler2D blueNoiseTexture;\nuniform vec2 blueNoiseRepeat;\nuniform vec2 texSize;\nuniform float aoDistance;\nuniform float distancePower;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform int frame;\n\nuniform vec3[spp] samples;\nuniform float[spp] samplesR;\n\n#include <common>\n#include <packing>\n#include <sampleBlueNoise>\n#include <ao_utils>\n\nhighp float linearize_depth(highp float d, highp float zNear, highp float zFar) {\n    highp float z_n = 2.0 * d - 1.0;\n    return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));\n}\n\nvoid main() {\n    float depth = textureLod(depthTexture, vUv, 0.).x;\n    vec3 normal = computeNormal(vUv);\n\n    // filter out background\n    if (depth == 1.0) {\n        gl_FragColor = vec4(normal, 1.0);\n        return;\n    }\n\n    vec3 worldPos = computeWorldPosition(depth, vUv);\n    vec3 screenSpaceNormal = getUnpackedNormal(vUv);\n\n    #ifdef animatedNoise\n        int seed = frame;\n    #else\n        int seed = 0;\n    #endif\n\n    vec4 noise = sampleBlueNoise(blueNoiseTexture, seed, blueNoiseRepeat, texSize);\n\n    vec3 randomVec = normalize(noise.rgb * 2.0 - 1.0);\n    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 tbn = mat3(tangent, bitangent, normal);\n\n    float occluded = 0.0;\n    float totalWeight = 0.0;\n\n    vec3 samplePos;\n\n    float sppF = float(spp);\n\n    for (float i = 0.0; i < sppF; i++) {\n        vec3 sampleDirection = tbn * samples[int(i)];\n\n        // make sure sample direction is in the same hemisphere as the normal\n        if (dot(sampleDirection, normal) < 0.0) sampleDirection *= -1.0;\n\n        float moveAmt = samplesR[int(mod(i + noise.a * sppF, sppF))];\n        samplePos = worldPos + aoDistance * moveAmt * sampleDirection;\n\n        vec4 offset = projectionViewMatrix * vec4(samplePos, 1.0);\n        offset.xyz /= offset.w;\n        offset.xyz = offset.xyz * 0.5 + 0.5;\n\n        float sampleDepth = textureLod(depthTexture, offset.xy, 0.0).x;\n\n        if(sampleDepth == 1.0) {\n            occluded += 0.0;\n            totalWeight += 1.0;\n            continue;\n        }\n\n        vec3 sampleNormal = getUnpackedNormal(offset.xy);\n\n        float distSample = linearize_depth(sampleDepth, cameraNear, cameraFar);\n        float distWorld = linearize_depth(offset.z, cameraNear, cameraFar);\n\n        float depthBias = 0.001;\n        float rangeCheck = smoothstep(0.0, 1.0, aoDistance / (abs(distSample - distWorld) + depthBias));\n        rangeCheck = pow(rangeCheck, distancePower);\n        rangeCheck = clamp(rangeCheck, 0.0, 1.0);\n        float weight = dot(sampleDirection, normal);\n        weight = clamp(weight, 0.0, 1.0);\n\n        \n        // check if the normals are in the same direction\n        float dotProduct = dot(screenSpaceNormal, normalize(sampleNormal));\n        if (dotProduct < 0.9999) {\n            occluded += rangeCheck * weight * (distSample < distWorld ? 1.0 : 0.0);\n            totalWeight += weight;\n        } else {\n            if(areDepthsOnSamePlane(depth, sampleDepth, vUv, offset.xy, normal, 0.1)) {\n                occluded += 0.0;\n                totalWeight += 1.0;\n            } else {\n                occluded += rangeCheck * weight * (distSample < distWorld ? 1.0 : 0.0);\n                totalWeight += weight;\n            }\n        }\n    }\n\n    float occ = clamp(1.0 - occluded / totalWeight, 0.0, 1.0);\n    gl_FragColor = vec4(normal, occ);\n}\n";
//# sourceMappingURL=ssao.d.ts.map
export declare const hbao_utils = "\n#include <sampleBlueNoise>\n\nuniform sampler2D normalTexture;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 projectionMatrixInverse;\nuniform mat4 cameraMatrixWorld;\n\n// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123\nfloat getViewZ(const float depth) {\n#ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n#else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n#endif\n}\n\n// source: https://github.com/N8python/ssao/blob/master/EffectShader.js#L52\nvec3 getWorldPos(const float depth, const vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = projectionMatrixInverse * clipSpacePosition;\n\n    // Perspective division\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    worldSpacePosition.xyz /= worldSpacePosition.w;\n\n    return worldSpacePosition.xyz;\n}\n\nvec3 slerp(const vec3 a, const vec3 b, const float t) {\n    float cosAngle = dot(a, b);\n    float angle = acos(cosAngle);\n\n    if (abs(angle) < 0.001) {\n        return mix(a, b, t);\n    }\n\n    float sinAngle = sin(angle);\n    float t1 = sin((1.0 - t) * angle) / sinAngle;\n    float t2 = sin(t * angle) / sinAngle;\n\n    return (a * t1) + (b * t2);\n}\n\nvec3 computeWorldNormal() {\n    vec2 size = vec2(textureSize(depthTexture, 0));\n    ivec2 p = ivec2(vUv * size);\n    float c0 = texelFetch(depthTexture, p, 0).x;\n    float l2 = texelFetch(depthTexture, p - ivec2(2, 0), 0).x;\n    float l1 = texelFetch(depthTexture, p - ivec2(1, 0), 0).x;\n    float r1 = texelFetch(depthTexture, p + ivec2(1, 0), 0).x;\n    float r2 = texelFetch(depthTexture, p + ivec2(2, 0), 0).x;\n    float b2 = texelFetch(depthTexture, p - ivec2(0, 2), 0).x;\n    float b1 = texelFetch(depthTexture, p - ivec2(0, 1), 0).x;\n    float t1 = texelFetch(depthTexture, p + ivec2(0, 1), 0).x;\n    float t2 = texelFetch(depthTexture, p + ivec2(0, 2), 0).x;\n    float dl = abs((2.0 * l1 - l2) - c0);\n    float dr = abs((2.0 * r1 - r2) - c0);\n    float db = abs((2.0 * b1 - b2) - c0);\n    float dt = abs((2.0 * t1 - t2) - c0);\n    vec3 ce = getWorldPos(c0, vUv).xyz;\n    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / size.x, 0.0))).xyz\n                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / size.x, 0.0))).xyz;\n    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / size.y))).xyz\n                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / size.y))).xyz;\n    return normalize(cross(dpdx, dpdy));\n}\n\nvec3 getWorldNormal(const vec2 uv) {\n#ifdef useNormalTexture\n    vec3 worldNormal = unpackRGBToNormal(textureLod(normalTexture, uv, 0.).rgb);\n\n    worldNormal = (vec4(worldNormal, 1.) * viewMatrix).xyz;  // view-space to world-space\n    return normalize(worldNormal);\n#else\n    return computeWorldNormal();  // compute world normal from depth\n#endif\n}\n\n#define PI 3.14159265358979323846264338327950288\n\n// source: https://www.shadertoy.com/view/cll3R4\nvec3 cosineSampleHemisphere(const vec3 n, const vec2 u) {\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n\n    vec3 b = normalize(cross(n, vec3(0.0, 1.0, 1.0)));\n    vec3 t = cross(b, n);\n\n    return normalize(r * sin(theta) * b + sqrt(1.0 - u.x) * n + r * cos(theta) * t);\n}\n\n";
//# sourceMappingURL=hbao_utils.d.ts.map
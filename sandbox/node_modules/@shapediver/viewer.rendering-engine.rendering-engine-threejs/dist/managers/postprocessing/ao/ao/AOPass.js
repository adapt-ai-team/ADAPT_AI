"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AOPass = void 0;
const postprocessing_1 = require("postprocessing");
const three_1 = require("three");
const PoissionDenoisePass_1 = require("../poissionDenoise/PoissionDenoisePass");
const basic_1 = require("../utils/shader/basic");
const sampleBlueNoise_1 = require("../utils/shader/sampleBlueNoise");
// a general AO pass that can be used for any AO algorithm
class AOPass extends postprocessing_1.Pass {
    // #endregion Properties (3)
    // #region Constructors (1)
    constructor(camera, scene, fragmentShader) {
        super();
        this._camera = camera;
        this._scene = scene;
        this.renderTarget = new three_1.WebGLRenderTarget(1, 1, {
            type: three_1.HalfFloatType,
            depthBuffer: false,
        });
        const finalFragmentShader = fragmentShader.replace("#include <sampleBlueNoise>", sampleBlueNoise_1.sampleBlueNoise);
        this.fullscreenMaterial = new three_1.ShaderMaterial({
            fragmentShader: finalFragmentShader,
            vertexShader: basic_1.basic,
            uniforms: {
                depthTexture: { value: null },
                normalTexture: { value: null },
                cameraNear: { value: 0 },
                cameraFar: { value: 0 },
                viewMatrix: { value: this._camera.matrixWorldInverse },
                projectionViewMatrix: { value: new three_1.Matrix4() },
                projectionMatrixInverse: {
                    value: this._camera.projectionMatrixInverse,
                },
                cameraMatrixWorld: { value: this._camera.matrixWorld },
                texSize: { value: new three_1.Vector2() },
                blueNoiseTexture: { value: null },
                blueNoiseRepeat: { value: new three_1.Vector2() },
                aoDistance: { value: 0 },
                distancePower: { value: 0 },
                bias: { value: 0 },
                thickness: { value: 0 },
                power: { value: 0 },
                frame: { value: 0 },
            },
            blending: three_1.NoBlending,
            depthWrite: false,
            depthTest: false,
            toneMapped: false,
        });
        if (PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture) {
            this.fullscreenMaterial.uniforms.blueNoiseTexture.value =
                PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture;
        }
        else {
            PoissionDenoisePass_1.PoissionDenoisePass.loadBlueNoiseTexture().then(() => {
                this.fullscreenMaterial.uniforms.blueNoiseTexture.value =
                    PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture;
            });
        }
    }
    // #endregion Constructors (1)
    // #region Public Accessors (1)
    get texture() {
        return this.renderTarget.texture;
    }
    // #endregion Public Accessors (1)
    // #region Public Methods (2)
    render(renderer) {
        const spp = +this.fullscreenMaterial.defines.spp;
        this.fullscreenMaterial.uniforms.frame.value =
            (this.fullscreenMaterial.uniforms.frame.value +
                spp) %
                65536;
        this.fullscreenMaterial.uniforms.cameraNear.value =
            this._camera.near;
        this.fullscreenMaterial.uniforms.cameraFar.value =
            this._camera.far;
        this.fullscreenMaterial.uniforms.projectionViewMatrix.value.multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse);
        const noiseTexture = this.fullscreenMaterial
            .uniforms.blueNoiseTexture.value;
        if (noiseTexture) {
            const { width, height } = noiseTexture.source.data;
            this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height);
        }
        else {
            if (PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture) {
                this.fullscreenMaterial.uniforms.blueNoiseTexture.value =
                    PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture;
                const { width, height } = PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture.source.data;
                this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height);
            }
            else {
                PoissionDenoisePass_1.PoissionDenoisePass.loadBlueNoiseTexture().then(() => {
                    this.fullscreenMaterial.uniforms.blueNoiseTexture.value =
                        PoissionDenoisePass_1.PoissionDenoisePass.blueNoiseTexture;
                });
            }
        }
        renderer.setRenderTarget(this.renderTarget);
        renderer.render(this.scene, this.camera);
    }
    setSize(width, height) {
        this.renderTarget.setSize(width, height);
        this.fullscreenMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height);
    }
}
exports.AOPass = AOPass;
//# sourceMappingURL=AOPass.js.map
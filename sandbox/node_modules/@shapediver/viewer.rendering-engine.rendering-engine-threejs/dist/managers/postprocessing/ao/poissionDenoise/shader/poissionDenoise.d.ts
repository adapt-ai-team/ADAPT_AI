export declare const poissionDenoise = "\nvarying vec2 vUv;\n\nuniform sampler2D inputTexture;\nuniform highp sampler2D depthTexture;\nuniform highp sampler2D normalTexture;\nuniform mat4 projectionMatrixInverse;\nuniform mat4 viewMatrixInverse;\nuniform mat4 cameraMatrixWorld;\nuniform float lumaPhi;\nuniform float depthPhi;\nuniform float normalPhi;\nuniform float distance;\nuniform sampler2D blueNoiseTexture;\nuniform vec2 blueNoiseRepeat;\nuniform int index;\nuniform vec2 resolution;\n\n#include <common>\n#include <sampleBlueNoise>\n\nvec3 computeWorldPosition(float depth, vec2 coord, bool useCameraMatrixWorld) {\n    // Convert depth to normalized device coordinates (NDC)\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n\n    // Transform to view space\n    vec4 viewSpacePosition = projectionMatrixInverse * clipSpacePosition;\n\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n\n    // Transform to world space using the selected method\n    vec4 worldSpacePosition;\n    if (useCameraMatrixWorld) {\n        // Use cameraMatrixWorld directly\n        worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    } else {\n        // Use viewMatrixInverse\n        worldSpacePosition = viewMatrixInverse * viewSpacePosition;\n    }\n\n    return worldSpacePosition.xyz;\n}\n\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\n\nvec3 getNormal(vec2 uv, vec4 texel) {\n#ifdef NORMAL_IN_RGB\n    // in case the normal is stored in the RGB channels of the texture\n    return texel.rgb;\n#else\n    return normalize(textureLod(normalTexture, uv, 0.).xyz * 2.0 - 1.0);\n#endif\n}\n\nfloat distToPlane(const vec3 worldPos, const vec3 neighborWorldPos, const vec3 worldNormal) {\n    vec3 toCurrent = worldPos - neighborWorldPos;\n    float distToPlane = abs(dot(toCurrent, worldNormal));\n\n    return distToPlane;\n}\n\nvoid main() {\n    vec4 depthTexel = textureLod(depthTexture, vUv, 0.);\n    vec4 texel = textureLod(inputTexture, vUv, 0.0);\n    vec3 normal = getNormal(vUv, texel);\n\n    if (depthTexel.r == 1.0 || dot(depthTexel.rgb, depthTexel.rgb) == 0.) {\n        #ifdef NORMAL_IN_RGB\n            gl_FragColor = vec4(normal, 1.0);\n        #else\n            gl_FragColor = vec4(1.0);\n        #endif\n\n        return;\n    }\n\n    #ifdef NORMAL_IN_RGB\n        float inputTexel = texel.a;\n        float center = texel.a;\n    #else\n        vec3 inputTexel = texel.rgb;\n        vec3 center = texel.rgb;\n    #endif\n\n    float depth = depthTexel.x;\n    vec3 worldPos = computeWorldPosition(depth, vUv, true);\n\n    float totalWeight = 1.0;\n\n    vec4 blueNoise = sampleBlueNoise(blueNoiseTexture, 0, blueNoiseRepeat, resolution);\n    float angle = blueNoise[index];\n\n    float s = sin(angle), c = cos(angle);\n\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n\n    \n    #ifdef NORMAL_IN_RGB\n        float denoised = inputTexel;\n    #else\n        vec3 denoised = inputTexel;\n    #endif\n\n    for (int i = 0; i < samples; i++) {\n        vec2 offset = rotationMatrix * poissonDisk[i];\n        vec2 neighborUv = vUv + offset;\n\n        vec4 neighborTexel = textureLod(inputTexture, neighborUv, 0.0);\n\n        vec3 neighborNormal = getNormal(neighborUv, neighborTexel);\n        #ifdef NORMAL_IN_RGB\n            float neighborColor = neighborTexel.a;\n        #else\n            vec3 neighborColor = neighborTexel.rgb;\n        #endif\n\n        float sampleDepth = textureLod(depthTexture, neighborUv, 0.0).x;\n\n        vec3 worldPosSample = computeWorldPosition(sampleDepth, neighborUv, true);\n        float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));\n\n        if (sampleDepth < 1.0) {\n            float normalDiff = dot(normal, neighborNormal);\n            float normalSimilarity = pow(max(normalDiff, 0.), normalPhi);\n\n            #ifdef NORMAL_IN_RGB\n                float lumaDiff = abs(neighborColor - center);\n            #else\n                float lumaDiff = abs(luminance(neighborColor) - luminance(center));\n            #endif\n            float lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);\n\n            float depthDiff = 1. - (distToPlane(worldPos, worldPosSample, normal) / distance);\n            float depthSimilarity = max(depthDiff / depthPhi, 0.);\n\n            float w = lumaSimilarity * depthSimilarity * normalSimilarity;\n\n            denoised += w * neighborColor;\n            totalWeight += w;\n        }\n    }\n\n    if (totalWeight > 0.) denoised /= totalWeight;\n\n    #ifdef NORMAL_IN_RGB\n        gl_FragColor = vec4(normal, denoised);\n    #else\n        gl_FragColor = vec4(denoised, 1.);\n    #endif\n}\n";
//# sourceMappingURL=poissionDenoise.d.ts.map
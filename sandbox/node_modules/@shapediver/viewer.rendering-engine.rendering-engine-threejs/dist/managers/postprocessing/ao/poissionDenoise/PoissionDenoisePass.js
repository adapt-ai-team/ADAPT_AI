"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoissionDenoisePass = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const postprocessing_1 = require("postprocessing");
const three_1 = require("three");
const basic_1 = require("../utils/shader/basic");
const sampleBlueNoise_1 = require("../utils/shader/sampleBlueNoise");
const poissionDenoise_1 = require("./shader/poissionDenoise");
const finalFragmentShader = poissionDenoise_1.poissionDenoise.replace("#include <sampleBlueNoise>", sampleBlueNoise_1.sampleBlueNoise);
const defaultPoissonBlurOptions = {
    iterations: 1,
    radius: 12,
    rings: 11,
    lumaPhi: 10,
    depthPhi: 2,
    normalPhi: 3.25,
    samples: 16,
    distance: 1,
    normalTexture: null,
};
class PoissionDenoisePass extends postprocessing_1.Pass {
    // #endregion Properties (11)
    // #region Constructors (1)
    constructor(camera, inputTexture, depthTexture, options = defaultPoissonBlurOptions) {
        super("PoissionBlurPass");
        this.index = 0;
        this.iterations = defaultPoissonBlurOptions.iterations;
        this.radius = 12;
        this.rings = 11;
        this.samples = 16;
        if (PoissionDenoisePass.blueNoiseTexture === undefined) {
            PoissionDenoisePass.loadBlueNoiseTexture().then(() => {
                this.fullscreenMaterial.uniforms.blueNoiseTexture.value =
                    PoissionDenoisePass.blueNoiseTexture;
            });
        }
        options = Object.assign(Object.assign({}, defaultPoissonBlurOptions), options);
        this.inputTexture = inputTexture;
        this.fullscreenMaterial = new three_1.ShaderMaterial({
            fragmentShader: finalFragmentShader,
            vertexShader: basic_1.basic,
            uniforms: {
                depthTexture: { value: null },
                inputTexture: { value: null },
                projectionMatrixInverse: { value: new three_1.Matrix4() },
                cameraMatrixWorld: { value: new three_1.Matrix4() },
                lumaPhi: { value: 5.0 },
                depthPhi: { value: 5.0 },
                normalPhi: { value: 5.0 },
                distance: { value: 1.0 },
                resolution: { value: new three_1.Vector2() },
                blueNoiseTexture: { value: null },
                index: { value: 0 },
                blueNoiseRepeat: { value: new three_1.Vector2() },
            },
        });
        const renderTargetOptions = {
            type: three_1.HalfFloatType,
            depthBuffer: false,
        };
        this.renderTargetA = new three_1.WebGLRenderTarget(1, 1, renderTargetOptions);
        this.renderTargetB = new three_1.WebGLRenderTarget(1, 1, renderTargetOptions);
        const { uniforms } = this.fullscreenMaterial;
        uniforms["inputTexture"].value = this.inputTexture;
        uniforms["depthTexture"].value = depthTexture;
        uniforms["projectionMatrixInverse"].value =
            camera.projectionMatrixInverse;
        uniforms["cameraMatrixWorld"].value = camera.matrixWorld;
        uniforms["depthPhi"].value = options.depthPhi;
        uniforms["normalPhi"].value = options.normalPhi;
        uniforms["distance"].value = options.distance;
        if (options.normalTexture) {
            uniforms["normalTexture"] = { value: options.normalTexture };
        }
        else {
            this.fullscreenMaterial.defines.NORMAL_IN_RGB =
                "";
        }
        // these properties need the shader to be recompiled
        for (const prop of ["radius", "rings", "samples"]) {
            Object.defineProperty(this, prop, {
                get: () => options[prop],
                set: (value) => {
                    options[prop] = value;
                    this.setSize(this.renderTargetA.width, this.renderTargetA.height);
                },
            });
        }
    }
    static loadBlueNoiseTexture() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield viewer_shared_services_1.HttpClient.instance.loadTexture("https://viewer.shapediver.com/v3/graphics/LDR_RGBA_0.png");
            if (result) {
                const url = URL.createObjectURL(result.data.blob);
                new three_1.TextureLoader().load(url, (texture) => {
                    URL.revokeObjectURL(url);
                    PoissionDenoisePass.blueNoiseTexture = texture;
                    PoissionDenoisePass.blueNoiseTexture.minFilter = three_1.NearestFilter;
                    PoissionDenoisePass.blueNoiseTexture.magFilter = three_1.NearestFilter;
                    PoissionDenoisePass.blueNoiseTexture.wrapS = three_1.RepeatWrapping;
                    PoissionDenoisePass.blueNoiseTexture.wrapT = three_1.RepeatWrapping;
                    PoissionDenoisePass.blueNoiseTexture.colorSpace = three_1.NoColorSpace;
                    PoissionDenoisePass.blueNoiseTexture.needsUpdate = true;
                });
            }
            else {
                viewer_shared_services_1.Logger.instance.warn("The blue noise texture could not be loaded. This may result in a suboptimal denoising quality. Retrying in 1 second...");
                // if there was an issue loading the texture
                // set a timeout with 1 second to try again
                setTimeout(() => {
                    this.loadBlueNoiseTexture();
                }, 1000);
            }
        });
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (1)
    get texture() {
        return this.renderTargetB.texture;
    }
    // #endregion Public Getters And Setters (1)
    // #region Public Methods (4)
    generateDenoiseSamples(numSamples, numRings, r, texelSize) {
        const angleStep = (2 * Math.PI * numRings) / numSamples;
        const invNumSamples = 1.0 / numSamples;
        const radiusStep = invNumSamples;
        const samples = [];
        let radius = invNumSamples;
        let angle = 0;
        for (let i = 0; i < numSamples; i++) {
            const v = new three_1.Vector2(Math.cos(angle), Math.sin(angle))
                .multiplyScalar(Math.pow(radius, 0.75))
                .multiply(texelSize)
                .multiplyScalar(r);
            if (isNaN(v.x) || v.x === Infinity || v.x === -Infinity)
                v.x = 0;
            if (isNaN(v.y) || v.y === Infinity || v.y === -Infinity)
                v.y = 0;
            samples.push(v);
            radius += radiusStep;
            angle += angleStep;
        }
        return samples;
    }
    generatePoissonDiskConstant(poissonDisk) {
        const samples = poissonDisk.length;
        let glslCode = "const vec2 poissonDisk[samples] = vec2[samples](\n";
        for (let i = 0; i < samples; i++) {
            const sample = poissonDisk[i];
            glslCode += `    vec2(${sample.x}, ${sample.y})`;
            if (i < samples - 1) {
                glslCode += ",";
            }
            glslCode += "\n";
        }
        glslCode += ");";
        return glslCode;
    }
    render(renderer) {
        this.fullscreenMaterial.uniforms.index.value = 0;
        const noiseTexture = this.fullscreenMaterial
            .uniforms.blueNoiseTexture.value;
        if (noiseTexture !== undefined &&
            noiseTexture !== null &&
            noiseTexture instanceof three_1.Texture) {
            const { width, height } = noiseTexture.source.data;
            this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTargetA.width / width, this.renderTargetA.height / height);
        }
        for (let i = 0; i < 2 * this.iterations; i++) {
            const horizontal = i % 2 === 0;
            const inputRenderTarget = horizontal
                ? this.renderTargetB
                : this.renderTargetA;
            this.fullscreenMaterial.uniforms["inputTexture"].value = i === 0 ? this.inputTexture : inputRenderTarget.texture;
            const renderTarget = horizontal
                ? this.renderTargetA
                : this.renderTargetB;
            renderer.setRenderTarget(renderTarget);
            renderer.render(this.scene, this.camera);
            this.fullscreenMaterial.uniforms.index.value =
                (this.fullscreenMaterial.uniforms.index
                    .value +
                    1) %
                    4;
        }
    }
    setSize(width, height) {
        this.renderTargetA.setSize(width, height);
        this.renderTargetB.setSize(width, height);
        this.fullscreenMaterial.uniforms.resolution.value.set(width, height);
        const poissonDisk = this.generateDenoiseSamples(this.samples, this.rings, this.radius, new three_1.Vector2(1 / width, 1 / height));
        const sampleDefine = `const int samples = ${this.samples};\n`;
        const poissonDiskConstant = this.generatePoissonDiskConstant(poissonDisk);
        this.fullscreenMaterial.fragmentShader =
            sampleDefine + poissonDiskConstant + "\n" + finalFragmentShader;
        this.fullscreenMaterial.needsUpdate = true;
    }
}
exports.PoissionDenoisePass = PoissionDenoisePass;
// #region Properties (11)
PoissionDenoisePass.DefaultOptions = defaultPoissonBlurOptions;
//# sourceMappingURL=PoissionDenoisePass.js.map
export declare const hbao = "\n#define PI 3.14159265358979323846264338327950288\n\nvarying vec2 vUv;\n\nuniform highp sampler2D depthTexture;\n\nuniform mat4 projectionViewMatrix;\nuniform int frame;\n\nuniform sampler2D blueNoiseTexture;\nuniform vec2 blueNoiseRepeat;\nuniform vec2 texSize;\n\nuniform float aoDistance;\nuniform float distancePower;\nuniform float bias;\nuniform float thickness;\n\n#include <packing>\n#include <sampleBlueNoise>\n\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraMatrixWorld;\n\n#include <ao_utils>\n\n// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123\nfloat getViewZ(const float depth) {\n#ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n#else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n#endif\n}\n\nvec3 slerp(const vec3 a, const vec3 b, const float t) {\n    float cosAngle = dot(a, b);\n    float angle = acos(cosAngle);\n\n    if (abs(angle) < 0.001) {\n        return mix(a, b, t);\n    }\n\n    float sinAngle = sin(angle);\n    float t1 = sin((1.0 - t) * angle) / sinAngle;\n    float t2 = sin(t * angle) / sinAngle;\n\n    return (a * t1) + (b * t2);\n}\n\n// source: https://www.shadertoy.com/view/cll3R4\nvec3 cosineSampleHemisphere(const vec3 n, const vec2 u) {\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n\n    vec3 b = normalize(cross(n, vec3(0.0, 1.0, 1.0)));\n    vec3 t = cross(b, n);\n\n    return normalize(r * sin(theta) * b + sqrt(1.0 - u.x) * n + r * cos(theta) * t);\n}\n\nvoid main() {\n    float depth = textureLod(depthTexture, vUv, 0.0).r;\n    vec3 normal = computeNormal(vUv);\n\n    // filter out background\n    if (depth == 1.0) {\n        gl_FragColor = vec4(normal, 1.0);\n        return;\n    }\n\n    vec4 cameraPosition = cameraMatrixWorld * vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 worldPos = computeWorldPosition(depth, vUv);\n    vec3 screenSpaceNormal = getUnpackedNormal(vUv);\n\n    float ao = 0.0, totalWeight = 0.0;\n\n    for (int i = 0; i < spp; i++) {\n        int seed = i;\n        #ifdef animatedNoise\n            seed += frame;\n        #endif\n\n        vec4 blueNoise = sampleBlueNoise(blueNoiseTexture, seed, blueNoiseRepeat, texSize);\n\n        vec3 sampleWorldDir = cosineSampleHemisphere(normal, blueNoise.rg);\n\n        vec3 sampleWorldPos = worldPos + aoDistance * pow(blueNoise.b, distancePower + 1.0) * sampleWorldDir;\n\n        // Project the sample position to screen space\n        vec4 sampleUv = projectionViewMatrix * vec4(sampleWorldPos, 1.);\n        sampleUv.xy /= sampleUv.w;\n        sampleUv.xy = sampleUv.xy * 0.5 + 0.5;\n\n        // Get the depth of the sample position\n        float sampleDepth = textureLod(depthTexture, sampleUv.xy, 0.0).r;\n\n        if(sampleDepth < 1.0) {\n            vec3 sampleNormal = getUnpackedNormal(sampleUv.xy);\n\n            // Compute the horizon line\n            float deltaDepth = depth - sampleDepth;\n\n            // distance based bias\n            float d = distance(sampleWorldPos, cameraPosition.xyz) / aoDistance;\n            deltaDepth *= 0.001 * d * d;\n\n            float th = thickness * 0.01;\n\n            float theta = dot(normal, sampleWorldDir);\n            totalWeight += theta;\n\n            if (deltaDepth < th) {\n\n\n                float horizon = sampleDepth + deltaDepth * bias * 1000.;\n\n                float occlusion = max(0.0, horizon - depth) * theta;\n\n                float m = max(0., 1. - deltaDepth / th);\n                occlusion = 10. * occlusion * m / d;\n\n                occlusion = max(0.0, occlusion);\n                \n                // check if the normals are in the same direction\n                float dotProduct = dot(screenSpaceNormal, sampleNormal);\n                if (dotProduct < 0.9999) {\n                    \n                    occlusion = sqrt(occlusion);\n                    ao += occlusion;\n                } else {\n                    if(areDepthsOnSamePlane(depth, sampleDepth, vUv, sampleUv.xy, screenSpaceNormal, 0.1)) {\n                        // occluded += 0.0;\n                        // totalWeight += 1.0;\n                    } else {\n                    \n                        occlusion = sqrt(occlusion);\n                        ao += occlusion;\n                    }\n                }\n            }\n        }\n    }\n\n    if (totalWeight > 0.) ao /= totalWeight;\n\n    // clamp ao to [0, 1]\n    ao = clamp(1. - ao, 0., 1.);\n\n    gl_FragColor = vec4(normal, ao);\n}\n";
//# sourceMappingURL=hbao.d.ts.map
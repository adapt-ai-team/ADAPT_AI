"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NormalPass = void 0;
const postprocessing_1 = require("postprocessing");
const three_1 = require("three");
const RenderPass_1 = require("./RenderPass");
/**
 * A pass that renders the normals of a given scene.
 */
class NormalPass extends postprocessing_1.Pass {
    /**
     * Constructs a new normal pass.
     *
     * @param {Scene} scene - The scene to render.
     * @param {Camera} camera - The camera to use to render the scene.
     * @param {Object} [options] - The options.
     * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
     * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
     * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
     * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
     * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
     * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
     */
    constructor(scene, camera, { renderTarget, resolutionScale = 1.0, width = postprocessing_1.Resolution.AUTO_SIZE, height = postprocessing_1.Resolution.AUTO_SIZE, resolutionX = width, resolutionY = height, } = {}) {
        super("NormalPass");
        this.needsSwap = false;
        /**
         * A render pass.
         *
         * @type {RenderPass}
         * @private
         */
        this.renderPass = new RenderPass_1.RenderPass(scene, camera, new three_1.MeshNormalMaterial());
        const renderPass = this.renderPass;
        renderPass.ignoreBackground = true;
        renderPass.skipShadowMapUpdate = true;
        const clearPass = renderPass.getClearPass();
        clearPass.overrideClearColor = new three_1.Color(0x7777ff);
        clearPass.overrideClearAlpha = 1.0;
        /**
         * A render target for the scene normals.
         *
         * @type {WebGLRenderTarget}
         * @readonly
         */
        this.renderTarget = renderTarget;
        if (this.renderTarget === undefined) {
            this.renderTarget = new three_1.WebGLRenderTarget(1, 1, {
                minFilter: three_1.NearestFilter,
                magFilter: three_1.NearestFilter,
            });
            this.renderTarget.texture.name = "NormalPass.Target";
        }
        this.dTexture = new three_1.DepthTexture(1, 1);
        // Hack: Make sure the input buffer uses the depth texture.
        this.renderTarget.depthTexture = this.dTexture;
        this.renderTarget.dispose();
        if (this.renderTarget.stencilBuffer) {
            this.dTexture.format = three_1.DepthStencilFormat;
            this.dTexture.type = three_1.UnsignedInt248Type;
        }
        else {
            this.dTexture.type = three_1.UnsignedIntType;
        }
        /**
         * The resolution.
         *
         * @type {Resolution}
         * @readonly
         */
        const resolution = (this.resolution = new postprocessing_1.Resolution(this, resolutionX, resolutionY, resolutionScale));
        resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    }
    set mainScene(value) {
        this.renderPass.mainScene = value;
    }
    set mainCamera(value) {
        this.renderPass.mainCamera = value;
    }
    /**
     * The normal texture.
     *
     * @type {Texture}
     */
    get texture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.texture;
    }
    get depthTexture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.depthTexture;
    }
    /**
     * The normal texture.
     *
     * @deprecated Use texture instead.
     * @return {Texture} The texture.
     */
    getTexture() {
        var _a;
        return (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.texture;
    }
    /**
     * Returns the resolution settings.
     *
     * @deprecated Use resolution instead.
     * @return {Resolution} The resolution.
     */
    getResolution() {
        return this.resolution;
    }
    /**
     * Returns the current resolution scale.
     *
     * @return {Number} The resolution scale.
     * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
     */
    getResolutionScale() {
        return this.resolution.scale;
    }
    /**
     * Sets the resolution scale.
     *
     * @param {Number} scale - The new resolution scale.
     * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
     */
    setResolutionScale(scale) {
        this.resolution.scale = scale;
    }
    /**
     * Renders the scene normals.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */
    render(renderer) {
        const renderTarget = this.renderToScreen ? null : this.renderTarget;
        this.renderPass.render(renderer, renderTarget, renderTarget, 0, true);
    }
    /**
     * Updates the size of this pass.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */
    setSize(width, height) {
        var _a;
        const resolution = this.resolution;
        resolution.setBaseSize(width, height);
        (_a = this.renderTarget) === null || _a === void 0 ? void 0 : _a.setSize(resolution.width, resolution.height);
    }
}
exports.NormalPass = NormalPass;
//# sourceMappingURL=NormalPass.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTreeManager = void 0;
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
const THREE = __importStar(require("three"));
const SDBone_1 = require("../objects/SDBone");
const SDData_1 = require("../objects/SDData");
const SDObject_1 = require("../objects/SDObject");
const ThreejsData_1 = require("../types/ThreejsData");
/* eslint-disable @typescript-eslint/no-empty-function */
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
// #endregion Type aliases (1)
// #region Classes (1)
class SceneTreeManager {
    // #endregion Properties (12)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (12)
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._inputValidator = viewer_shared_services_1.InputValidator.instance;
        this._scene = new THREE.Scene();
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._boundingBoxSensitiveData = [];
        this._hiddenCamera = new THREE.PerspectiveCamera();
        this._lastRendererType = viewer_shared_types_1.RENDERER_TYPE.STANDARD;
        this._lastRootVersion = "";
        this._suspendSceneUpdates = false;
        this._scene.background = new THREE.Color("#ffffff");
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (4)
    get boundingBox() {
        return this._boundingBox;
    }
    get lastRendererType() {
        return this._lastRendererType;
    }
    get lastRootVersion() {
        return this._lastRootVersion;
    }
    get scene() {
        return this._scene;
    }
    get suspendSceneUpdates() {
        return this._suspendSceneUpdates;
    }
    set suspendSceneUpdates(value) {
        this._suspendSceneUpdates = value;
    }
    // #endregion Public Getters And Setters (4)
    // #region Public Methods (6)
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 &&
            this._boundingBox.min[1] === 0 &&
            this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 &&
            this._boundingBox.max[1] === 0 &&
            this._boundingBox.max[2] === 0) ||
            this._boundingBox.isEmpty());
    }
    /**
     * Convert the data of the scene graph node into the format of the implementation.
     *
     * @param data the data element
     * @param obj the corresponding type node
     */
    updateData(node, obj, data, filter, isVisibleInHierarchy, skeleton) {
        var _a;
        let dataChild = (obj.children.find((oc) => oc.SDid === data.id &&
            oc.SDversion === data.version));
        let newChild = false;
        if (!dataChild) {
            newChild = true;
            dataChild = new SDData_1.SDData(data.id, data.version);
            obj.add(dataChild);
        }
        if (this._renderingEngine.type === viewer_shared_types_1.RENDERER_TYPE.ATTRIBUTES) {
            this.injectAttributeData(node, data);
        }
        else {
            const sdtfTransform = node.getTransformation("sdtf");
            if (sdtfTransform)
                node.removeTransformation(sdtfTransform);
            if (data instanceof viewer_shared_types_1.GeometryData)
                data.attributeMaterial = null;
        }
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                {
                    dataChild.SDtype = SDData_1.SD_DATA_TYPE.GEOMETRY;
                    // We search for the instance matrices data in the parent of our current node
                    // We are currently at the primitive level and the instance matrices are stored at the mesh level
                    const instanceTransformationData = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.data.find((d) => d instanceof viewer_shared_types_1.InstanceData);
                    if (filter.transformationOnly === false)
                        this._renderingEngine.geometryLoader.load(data, dataChild, newChild, skeleton, instanceTransformationData);
                    let bb = new viewer_shared_math_1.Box();
                    if (skeleton) {
                        bb = data.primitive.computeBoundingBox(node.worldMatrix);
                    }
                    else {
                        const clone = dataChild.clone();
                        clone.applyTransformation(node.worldMatrix);
                        const threeBox = new THREE.Box3().setFromObject(clone, true);
                        bb = new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(threeBox.min.x, threeBox.min.y, threeBox.min.z), gl_matrix_1.vec3.fromValues(threeBox.max.x, threeBox.max.y, threeBox.max.z));
                    }
                    // adjust the general BB
                    node.boundingBox.union(bb);
                    // create the specific BB if it doesn't exist yet
                    if (!node.boundingBoxViewport[this._renderingEngine.id])
                        node.boundingBoxViewport[this._renderingEngine.id] =
                            new viewer_shared_math_1.Box();
                    // adjust the specific BB
                    node.boundingBoxViewport[this._renderingEngine.id].union(bb);
                }
                break;
            case data instanceof ThreejsData_1.ThreejsData:
                {
                    dataChild.SDtype = SDData_1.SD_DATA_TYPE.THREEJS;
                    dataChild.add(data.obj);
                    const bbThree = new THREE.Box3().setFromObject(data.obj);
                    // adjust the general BB
                    node.boundingBox.union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                    // create the specific BB if it doesn't exist yet
                    if (!node.boundingBoxViewport[this._renderingEngine.id])
                        node.boundingBoxViewport[this._renderingEngine.id] =
                            new viewer_shared_math_1.Box();
                    // adjust the specific BB
                    node.boundingBoxViewport[this._renderingEngine.id].union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                }
                break;
            case data instanceof viewer_shared_types_1.AbstractMaterialData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.MATERIAL;
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.LIGHT;
                if (filter.transformationOnly === false)
                    this._renderingEngine.lightLoader.load(data, dataChild);
                if (data instanceof viewer_rendering_engine_light_engine_1.DirectionalLight &&
                    data.useNodeData === false)
                    this._boundingBoxSensitiveData.push({
                        data: data,
                        dataChild,
                    });
                break;
            case data instanceof viewer_rendering_engine_camera_engine_1.AbstractCamera:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.CAMERA;
                if (filter.transformationOnly === false)
                    this._renderingEngine.cameraManager.load(data, dataChild);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR;
                if (filter.transformationOnly === false)
                    this._renderingEngine.htmlElementAnchorLoader.load(node, data, isVisibleInHierarchy);
                break;
            case data instanceof viewer_shared_types_1.AnimationData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.ANIMATION;
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
    updateMorphWeights(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        for (let i = 0, len = node.data.length; i < len; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                const data = node.data[i];
                const dataChild = (obj.children.find((oc) => oc.SDid === data.id &&
                    oc.SDversion === data.version));
                if (dataChild)
                    dataChild.traverse((o) => {
                        if (o instanceof THREE.Points ||
                            o instanceof THREE.LineSegments ||
                            o instanceof THREE.LineLoop ||
                            o instanceof THREE.Line ||
                            o instanceof THREE.Mesh)
                            o.morphTargetInfluences = data.morphWeights;
                    });
            }
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = (obj.children.find((oc) => oc.SDid === nodeChild.id));
            if (objChild)
                this.updateMorphWeights(nodeChild, objChild);
        }
    }
    /**
     * Update the current node via the scene graph node.
     * Convert the data if needed.
     *
     * @param node the scene graph node
     * @param obj the current type object
     */
    updateNode(node = this._tree.root, obj, filter = { transformationOnly: false }, visibleInHierarchy = true, skeleton) {
        if (obj === undefined) {
            // check if there is a converted object
            if (node.convertedObject[this._renderingEngine.id]) {
                obj = node.convertedObject[this._renderingEngine.id];
            }
            else {
                // the node has not been converted yet
                // go up the hierarchy until a converted object is found
                let parent = node.parent;
                while (parent) {
                    if (parent.convertedObject[this._renderingEngine.id]) {
                        this.updateNode(parent, parent.convertedObject[this._renderingEngine.id], filter, visibleInHierarchy, skeleton);
                        return;
                    }
                    else {
                        parent = parent.parent;
                    }
                }
                // no converted object found in the hierarchy
                // update the whole scene tree
                this.updateSceneTree(this._tree.root);
                return;
            }
        }
        const convertedObject = obj;
        // reset the general bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBox.reset();
        // create the specific BB if it doesn't exist yet
        if (!node.boundingBoxViewport[this._renderingEngine.id])
            node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
        // reset the specific bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBoxViewport[this._renderingEngine.id].reset();
        if (filter.transformationOnly === false) {
            // remove all data items that do not exist anymore
            const dataIds = node.data.map((d) => d.id);
            const dataToRemove = convertedObject.children.filter((oc) => {
                if (oc instanceof SDData_1.SDData) {
                    if (dataIds.includes(oc.SDid)) {
                        const data = node.data.find((d) => d.id === oc.SDid);
                        if (data && data.version !== oc.SDversion) {
                            // version is different
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        // id not included anymore
                        return true;
                    }
                }
                else {
                    return false;
                }
            });
            dataToRemove.forEach((dTR) => {
                this.removeData(dTR);
                convertedObject.remove(dTR);
            });
            // remove all child nodes in the transformed object that do not exist anymore
            // the filter goes also through the data items as they were already added
            const nodeIds = node.children
                .filter((d) => !d.excludeViewports.includes(this._renderingEngine.id))
                .map((d) => d.id);
            const childrenToRemove = convertedObject.children.filter((oc) => {
                if (oc instanceof SDObject_1.SDObject && !(oc instanceof SDData_1.SDData)) {
                    if (nodeIds.includes(oc.SDid)) {
                        return false;
                    }
                    else {
                        // id not included anymore
                        return true;
                    }
                }
                else {
                    return false;
                }
            });
            childrenToRemove.forEach((cTR) => {
                cTR.traverse((o) => {
                    if (o instanceof SDData_1.SDData)
                        this.removeData(o);
                });
                convertedObject.remove(cTR);
            });
        }
        // create the skeleton if the node is marked as the skin node (root node of the skeleton)
        if (node.skinNode === true) {
            const bones = [];
            for (let i = 0; i < node.bones.length; i++)
                bones.push(this.getBone(node.bones[i]));
            const boneInverses = [];
            for (let i = 0; i < node.boneInverses.length; i++)
                boneInverses.push(new THREE.Matrix4().fromArray(node.boneInverses[i]));
            skeleton = new THREE.Skeleton(bones, boneInverses);
        }
        const isVisible = node.visible &&
            !node.excludeViewports.includes(this._renderingEngine.id) &&
            !(node.restrictViewports.length > 0 &&
                !node.restrictViewports.includes(this._renderingEngine.id));
        const isVisibleInHierarchy = visibleInHierarchy && isVisible;
        // convert all data items of the current node
        // old versions will be replaced by new ones
        for (let i = 0, len = node.data.length; i < len; i++)
            this.updateData(node, convertedObject, node.data[i], filter, isVisibleInHierarchy, skeleton);
        // add new children and update the ones that have a different version
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            const objChild = (convertedObject.children.find((oc) => oc.SDid === nodeChild.id));
            if (!objChild) {
                const newChild = node.data.find((d) => d instanceof viewer_shared_types_1.BoneData)
                    ? new SDBone_1.SDBone(nodeChild.id, nodeChild.version)
                    : new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                const oldChild = nodeChild.convertedObject[this._renderingEngine.id];
                nodeChild.convertedObject[this._renderingEngine.id] = newChild;
                if (nodeChild.updateCallbackConvertedObject)
                    nodeChild.updateCallbackConvertedObject(newChild, oldChild, this._renderingEngine.id);
                convertedObject.add(newChild);
                this.updateNode(nodeChild, newChild, filter, isVisibleInHierarchy, skeleton);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                // if the version is different, update the child
                this.updateNode(nodeChild, objChild, filter, isVisibleInHierarchy, skeleton);
                objChild.SDversion = nodeChild.version;
            }
            else {
                this.updateNode(nodeChild, objChild, filter, isVisibleInHierarchy, skeleton);
            }
            // adjust the general BB
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
            // adjust the specific BB
            if (nodeChild.boundingBoxViewport[this._renderingEngine.id] &&
                !nodeChild.boundingBoxViewport[this._renderingEngine.id].isEmpty()) {
                // only do this if the node is
                // 1. visible
                // 2. no included in the "excludeViewports"
                // 3. if there are "restrictViewports", it needs to be in them
                if (isVisible)
                    node.boundingBoxViewport[this._renderingEngine.id].union(nodeChild.boundingBoxViewport[this._renderingEngine.id]);
            }
        }
        convertedObject.visible =
            node.visible &&
                !node.excludeViewports.includes(this._renderingEngine.id) &&
                !(node.restrictViewports.length > 0 &&
                    !node.restrictViewports.includes(this._renderingEngine.id));
        convertedObject.applyTransformation(node.nodeMatrix);
    }
    updateSceneTree(root) {
        var _a, _b;
        // check if we currently have the same root version
        if (this._tree.root.version === this._lastRootVersion)
            return;
        // check if scene tree updates are currently suspended
        if (this._suspendSceneUpdates)
            return;
        this._lastRootVersion = this._tree.root.version;
        this._lastRendererType = this._renderingEngine.type;
        if (this._renderingEngine.closed)
            return;
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            const oldObj = root.convertedObject[this._renderingEngine.id];
            root.convertedObject[this._renderingEngine.id] = this._mainNode;
            if (root.updateCallbackConvertedObject)
                root.updateCallbackConvertedObject(this._mainNode, oldObj, this._renderingEngine.id);
            this._scene.add(this._mainNode);
        }
        this._boundingBoxSensitiveData = [];
        this._currentSDTFOverview = this.createSDTFOverview();
        this.updateNode(root, this._mainNode);
        this._boundingBox =
            root.boundingBoxViewport[this._renderingEngine.id].clone();
        for (let i = 0; i < this._boundingBoxSensitiveData.length; i++)
            this._renderingEngine.lightLoader.adjustToBoundingBox(this._boundingBoxSensitiveData[i].data, this._boundingBoxSensitiveData[i].dataChild, this._boundingBox);
        if (!(this._boundingBox.min[0] === oldBB.min[0] &&
            this._boundingBox.min[1] === oldBB.min[1] &&
            this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] &&
            this._boundingBox.max[1] === oldBB.max[1] &&
            this._boundingBox.max[2] === oldBB.max[2])) {
            if (!((_a = this._stateEngine.viewportEngines[this._renderingEngine.id]) === null || _a === void 0 ? void 0 : _a.boundingBoxCreated.resolved) &&
                !this._boundingBox.isEmpty())
                (_b = this._stateEngine.viewportEngines[this._renderingEngine.id]) === null || _b === void 0 ? void 0 : _b.boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, {
                viewportId: this._renderingEngine.id,
                boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                },
            });
        }
        if (this._boundingBox.isEmpty()) {
            // check if all outputs that should be loaded at the start of a session are loaded
            // if the bounding box is empty then, emit the event
            if (Object.values(this._stateEngine.sessionEngines).every((s) => s && s.initialOutputsLoaded.resolved === true)) {
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_EMPTY, {
                    viewportId: this._renderingEngine.id,
                });
            }
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount +
            this._renderingEngine.materialLoader.maxMapCount);
        /**
         *
         * Three.js texture upload and compiling
         * This step is needed as three.js would compile the shaders and initialize the texture on the first render call instead.
         *
         */
        // we initialize all texture and then clear the cache
        const threeJsTextureCache = this._renderingEngine.materialLoader.threeJsTextureCache;
        for (const key in threeJsTextureCache) {
            if (threeJsTextureCache[key].usage === 0) {
                threeJsTextureCache[key].texture.dispose();
                delete threeJsTextureCache[key];
            }
            else if (threeJsTextureCache[key].initialized === false) {
                this._renderingEngine.renderer.initTexture(threeJsTextureCache[key].texture);
                threeJsTextureCache[key].initialized = true;
            }
        }
        // we compile the shaders
        this._renderingEngine.renderer.compile(this._renderingEngine.scene, this._hiddenCamera);
    }
    // #endregion Public Methods (6)
    // #region Private Methods (5)
    collectSDTFItemData(node) {
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFItemData)
                return node.data[i];
        if (!node.parent)
            return;
        return this.collectSDTFItemData(node.parent);
    }
    createSDTFOverview(node = this._tree.root) {
        const out = new viewer_shared_types_1.SDTFOverviewData({});
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFOverviewData)
                out.merge(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out.merge(new viewer_shared_types_1.SDTFOverviewData(this.createSDTFOverview(node.children[i])));
        return out.overview;
    }
    getBone(node) {
        let bone;
        this._mainNode.traverse((o) => {
            if (o.SDid === node.id)
                bone = o;
        });
        return bone;
    }
    injectAttributeData(node, data) {
        const itemData = this.collectSDTFItemData(node);
        const visData = {
            material: new viewer_shared_types_1.MaterialStandardData({
                color: this._renderingEngine.defaultMaterialColor,
                opacity: 1,
            }),
            matrix: gl_matrix_1.mat4.create(),
        };
        if (this._renderingEngine.visualizeAttributes) {
            const userVisData = this._renderingEngine.visualizeAttributes(this._currentSDTFOverview, itemData);
            this._inputValidator.validateAndError("Viewer.visualizeAttributes", userVisData, "object", true);
            this._inputValidator.validateAndError("Viewer.visualizeAttributes", userVisData.matrix, "mat4", true);
            visData.material = userVisData.material;
            visData.matrix = userVisData.matrix;
        }
        node.addTransformation({
            id: "sdtf",
            matrix: visData.matrix,
        });
        if (data instanceof viewer_shared_types_1.GeometryData)
            data.attributeMaterial = visData.material;
    }
    removeData(dataObject) {
        if (dataObject.userData.removed === true)
            return;
        dataObject.userData.removed = true;
        switch (true) {
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.GEOMETRY:
                dataObject.traverse((o) => {
                    if (dataObject.id !== o.id && o.userData.removed === true)
                        return;
                    o.userData.removed = true;
                    if (o instanceof THREE.Mesh ||
                        o instanceof THREE.Line ||
                        o instanceof THREE.Points ||
                        o instanceof THREE.LineSegments ||
                        o instanceof THREE.LineLoop) {
                        this.scene.remove(o);
                        this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid +
                            "_" +
                            o.geometry.userData.SDversion);
                        this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid +
                            "_" +
                            o.material.userData.SDversion);
                        const texturesToRemove = [];
                        for (const t in o.material) {
                            if (o.material[t] instanceof THREE.Texture) {
                                o.material[t].name = t;
                                if (t !== "envMap") {
                                    if (!texturesToRemove.includes(o.material[t]))
                                        texturesToRemove.push(o.material[t]);
                                }
                            }
                        }
                        for (const texture of texturesToRemove) {
                            if (texture.userData.cacheKey) {
                                this._renderingEngine.materialLoader
                                    .threeJsTextureCache[texture.userData.cacheKey].usage--;
                            }
                            else {
                                if (texture.name === "sphericalNormalMap") {
                                    this._renderingEngine.geometryLoader.removeFromGemSphericalMapsCache(o.geometry.userData.primitiveSDid +
                                        "_" +
                                        o.geometry.userData
                                            .primitiveSDversion);
                                    texture.dispose();
                                }
                                else {
                                    texture.dispose();
                                }
                            }
                        }
                    }
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.THREEJS:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.MATERIAL:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.LIGHT:
                dataObject.traverse((o) => {
                    if (o instanceof THREE.Light)
                        o.dispose();
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR:
                this._renderingEngine.htmlElementAnchorLoader.removeData(dataObject.SDid, dataObject.SDversion);
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.ANIMATION:
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
}
exports.SceneTreeManager = SceneTreeManager;
// #endregion Classes (1)
//# sourceMappingURL=SceneTreeManager.js.map
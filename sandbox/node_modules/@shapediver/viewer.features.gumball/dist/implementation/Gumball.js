"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Gumball_eventEngine, _Gumball_keysPressed, _Gumball_matrixId, _Gumball_nodes, _Gumball_parentObject, _Gumball_singleNode, _Gumball_transformControls, _Gumball_transformationControlsPlaceholder, _Gumball_viewport, _Gumball_cameraFreezeFlag, _Gumball_canvasEventListenerToken, _Gumball_closed, _Gumball_continuousRenderingFlag, _Gumball_continuousShadowMapUpdateFlag, _Gumball_currentMatrix, _Gumball_enableRotation, _Gumball_enableRotationX, _Gumball_enableRotationY, _Gumball_enableRotationZ, _Gumball_enableScaling, _Gumball_enableScalingX, _Gumball_enableScalingY, _Gumball_enableScalingZ, _Gumball_enableTranslation, _Gumball_enableTranslationX, _Gumball_enableTranslationY, _Gumball_enableTranslationZ, _Gumball_initialOffset, _Gumball_initialTransform, _Gumball_matrix, _Gumball_moving, _Gumball_pivotDragging, _Gumball_pivotOffset, _Gumball_previousGumballMatrix, _Gumball_reuseTransformation, _Gumball_scale, _Gumball_show, _Gumball_space;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gumball = void 0;
const THREE = __importStar(require("three"));
const viewer_1 = require("@shapediver/viewer");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const TransformControls_1 = require("../three/TransformControls");
/* eslint-disable @typescript-eslint/no-unused-vars */
class Gumball {
    // #endregion Properties (38)
    // #region Constructors (1)
    constructor(viewport, nodes, settings) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        // #region Properties (38)
        _Gumball_eventEngine.set(this, viewer_shared_services_1.EventEngine.instance);
        _Gumball_keysPressed.set(this, {});
        _Gumball_matrixId.set(this, 'SD_gumball_matrix');
        _Gumball_nodes.set(this, []);
        _Gumball_parentObject.set(this, new THREE.Object3D());
        _Gumball_singleNode.set(this, void 0);
        _Gumball_transformControls.set(this, void 0);
        _Gumball_transformationControlsPlaceholder.set(this, new THREE.Object3D());
        _Gumball_viewport.set(this, void 0);
        _Gumball_cameraFreezeFlag.set(this, void 0);
        _Gumball_canvasEventListenerToken.set(this, void 0);
        _Gumball_closed.set(this, false);
        _Gumball_continuousRenderingFlag.set(this, void 0);
        _Gumball_continuousShadowMapUpdateFlag.set(this, void 0);
        _Gumball_currentMatrix.set(this, new THREE.Matrix4());
        _Gumball_enableRotation.set(this, true);
        _Gumball_enableRotationX.set(this, true);
        _Gumball_enableRotationY.set(this, true);
        _Gumball_enableRotationZ.set(this, true);
        _Gumball_enableScaling.set(this, true);
        _Gumball_enableScalingX.set(this, true);
        _Gumball_enableScalingY.set(this, true);
        _Gumball_enableScalingZ.set(this, true);
        _Gumball_enableTranslation.set(this, true);
        _Gumball_enableTranslationX.set(this, true);
        _Gumball_enableTranslationY.set(this, true);
        _Gumball_enableTranslationZ.set(this, true);
        _Gumball_initialOffset.set(this, gl_matrix_1.vec3.create());
        _Gumball_initialTransform.set(this, []);
        _Gumball_matrix.set(this, gl_matrix_1.mat4.create());
        _Gumball_moving.set(this, false);
        _Gumball_pivotDragging.set(this, false);
        _Gumball_pivotOffset.set(this, gl_matrix_1.mat4.create());
        _Gumball_previousGumballMatrix.set(this, []);
        _Gumball_reuseTransformation.set(this, true);
        _Gumball_scale.set(this, 0.15);
        _Gumball_show.set(this, true);
        _Gumball_space.set(this, 'local');
        __classPrivateFieldSet(this, _Gumball_viewport, viewport, "f");
        __classPrivateFieldSet(this, _Gumball_canvasEventListenerToken, __classPrivateFieldGet(this, _Gumball_viewport, "f").addCanvasEventListener(this), "f");
        __classPrivateFieldSet(this, _Gumball_nodes, nodes, "f");
        __classPrivateFieldSet(this, _Gumball_singleNode, nodes.length === 1, "f");
        __classPrivateFieldSet(this, _Gumball_transformControls, new TransformControls_1.TransformControls(viewport.threeJsCoreObjects.camera, viewport.threeJsCoreObjects.renderer.domElement, this.updateObjects.bind(this), this.updateObjectMatrices.bind(this)), "f");
        this.enableRotation = (_a = settings === null || settings === void 0 ? void 0 : settings.enableRotation) !== null && _a !== void 0 ? _a : true;
        this.enableRotationX = (_c = (_b = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : true;
        this.enableRotationY = (_e = (_d = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _d === void 0 ? void 0 : _d.y) !== null && _e !== void 0 ? _e : true;
        this.enableRotationZ = (_g = (_f = settings === null || settings === void 0 ? void 0 : settings.enableRotationAxes) === null || _f === void 0 ? void 0 : _f.z) !== null && _g !== void 0 ? _g : true;
        this.enableScaling = (_h = settings === null || settings === void 0 ? void 0 : settings.enableScaling) !== null && _h !== void 0 ? _h : false;
        this.enableScalingX = (_k = (_j = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _j === void 0 ? void 0 : _j.x) !== null && _k !== void 0 ? _k : true;
        this.enableScalingY = (_m = (_l = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _l === void 0 ? void 0 : _l.y) !== null && _m !== void 0 ? _m : true;
        this.enableScalingZ = (_p = (_o = settings === null || settings === void 0 ? void 0 : settings.enableScalingAxes) === null || _o === void 0 ? void 0 : _o.z) !== null && _p !== void 0 ? _p : true;
        this.enableTranslation = (_q = settings === null || settings === void 0 ? void 0 : settings.enableTranslation) !== null && _q !== void 0 ? _q : true;
        this.enableTranslationX = (_s = (_r = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _r === void 0 ? void 0 : _r.x) !== null && _s !== void 0 ? _s : true;
        this.enableTranslationY = (_u = (_t = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _t === void 0 ? void 0 : _t.y) !== null && _u !== void 0 ? _u : true;
        this.enableTranslationZ = (_w = (_v = settings === null || settings === void 0 ? void 0 : settings.enableTranslationAxes) === null || _v === void 0 ? void 0 : _v.z) !== null && _w !== void 0 ? _w : true;
        this.scale = (_x = settings === null || settings === void 0 ? void 0 : settings.scale) !== null && _x !== void 0 ? _x : 0.15;
        // we don't allow to change the space for now
        __classPrivateFieldSet(this, _Gumball_space, (_y = settings === null || settings === void 0 ? void 0 : settings.space) !== null && _y !== void 0 ? _y : 'local', "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").space = __classPrivateFieldGet(this, _Gumball_space, "f");
        // we don't allow to change the reuseTransformation for now
        __classPrivateFieldSet(this, _Gumball_reuseTransformation, (_z = settings === null || settings === void 0 ? void 0 : settings.reuseTransformation) !== null && _z !== void 0 ? _z : true, "f");
        this.setup();
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (32)
    get closed() {
        return __classPrivateFieldGet(this, _Gumball_closed, "f");
    }
    get enableRotation() {
        return __classPrivateFieldGet(this, _Gumball_enableRotation, "f");
    }
    set enableRotation(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotation, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = value;
    }
    get enableRotationX() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationX, "f");
    }
    set enableRotationX(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationX = value;
    }
    get enableRotationY() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationY, "f");
    }
    set enableRotationY(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationY = value;
    }
    get enableRotationZ() {
        return __classPrivateFieldGet(this, _Gumball_enableRotationZ, "f");
    }
    set enableRotationZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableRotationZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotationZ = value;
    }
    get enableScaling() {
        return __classPrivateFieldGet(this, _Gumball_enableScaling, "f");
    }
    set enableScaling(value) {
        __classPrivateFieldSet(this, _Gumball_enableScaling, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = value;
    }
    get enableScalingX() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingX, "f");
    }
    set enableScalingX(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingX = value;
    }
    get enableScalingY() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingY, "f");
    }
    set enableScalingY(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingY = value;
    }
    get enableScalingZ() {
        return __classPrivateFieldGet(this, _Gumball_enableScalingZ, "f");
    }
    set enableScalingZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableScalingZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScalingZ = value;
    }
    get enableTranslation() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslation, "f");
    }
    set enableTranslation(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslation, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = value;
    }
    get enableTranslationX() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationX, "f");
    }
    set enableTranslationX(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationX, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationX = value;
    }
    get enableTranslationY() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationY, "f");
    }
    set enableTranslationY(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationY, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationY = value;
    }
    get enableTranslationZ() {
        return __classPrivateFieldGet(this, _Gumball_enableTranslationZ, "f");
    }
    set enableTranslationZ(value) {
        __classPrivateFieldSet(this, _Gumball_enableTranslationZ, value, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslationZ = value;
    }
    get matrix() {
        return __classPrivateFieldGet(this, _Gumball_matrix, "f");
    }
    get reuseTransformation() {
        return __classPrivateFieldGet(this, _Gumball_reuseTransformation, "f");
    }
    get scale() {
        return __classPrivateFieldGet(this, _Gumball_scale, "f");
    }
    set scale(value) {
        __classPrivateFieldSet(this, _Gumball_scale, value, "f");
        const size = viewer_1.sceneTree.root.boundingBox.boundingSphere.radius * value;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").setSize(size);
    }
    get show() {
        return __classPrivateFieldGet(this, _Gumball_show, "f");
    }
    set show(value) {
        __classPrivateFieldSet(this, _Gumball_show, value, "f");
    }
    get space() {
        return __classPrivateFieldGet(this, _Gumball_space, "f");
    }
    // #endregion Public Getters And Setters (32)
    // #region Public Methods (10)
    close() {
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").remove(__classPrivateFieldGet(this, _Gumball_transformControls, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").remove(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").detach();
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").dispose();
        __classPrivateFieldGet(this, _Gumball_viewport, "f").threeJsCoreObjects.scene.remove(__classPrivateFieldGet(this, _Gumball_parentObject, "f"));
        __classPrivateFieldGet(this, _Gumball_viewport, "f").removeCanvasEventListener(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        if (__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"))
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"));
        if (__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"))
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"));
        if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"))
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
    }
    keyPressed(key) {
        if (Array.isArray(key)) {
            // check if one of the keys is pressed
            let result = false;
            for (let i = 0; i < key.length; i++) {
                result = result || this.keyPressCheck(key[i]);
            }
            return result;
        }
        else {
            return this.keyPressCheck(key);
        }
    }
    onKeyDown(event) {
        if (this.closed)
            return;
        __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[event.key] = true;
        if (__classPrivateFieldGet(this, _Gumball_moving, "f") === false && Object.values(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).length === 1 && this.keyPressed('p') && __classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === false) {
            this.activatePivotDragging();
        }
    }
    onKeyUp(event) {
        if (this.closed)
            return;
        delete __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[event.key];
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true && !this.keyPressed('p')) {
            this.deactivatePivotDragging();
        }
    }
    onMouseWheel(event) { }
    onPointerDown(event) {
        if (this.closed)
            return;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerDown(event);
        __classPrivateFieldSet(this, _Gumball_moving, __classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging, "f");
        if (__classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging || __classPrivateFieldGet(this, _Gumball_transformControls, "f").hovering)
            __classPrivateFieldGet(this, _Gumball_viewport, "f").addRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
    }
    onPointerEnd(event) {
        if (this.closed)
            return;
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
        __classPrivateFieldGet(this, _Gumball_viewport, "f").removeRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerUp(event);
    }
    onPointerMove(event) {
        if (this.closed)
            return;
        if (!__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"))
            __classPrivateFieldSet(this, _Gumball_continuousRenderingFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_RENDERING), "f");
        if (!__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"))
            __classPrivateFieldSet(this, _Gumball_continuousShadowMapUpdateFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CONTINUOUS_SHADOW_MAP_UPDATE), "f");
        if (__classPrivateFieldGet(this, _Gumball_moving, "f") === false && Object.values(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).length === 1 && this.keyPressed('p') && __classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === false) {
            this.activatePivotDragging();
        }
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true && !this.keyPressed('p')) {
            this.deactivatePivotDragging();
        }
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerHover(event);
        if (__classPrivateFieldGet(this, _Gumball_moving, "f"))
            __classPrivateFieldGet(this, _Gumball_transformControls, "f").onPointerMove(event);
        if (__classPrivateFieldGet(this, _Gumball_transformControls, "f").dragging || __classPrivateFieldGet(this, _Gumball_transformControls, "f").hovering) {
            __classPrivateFieldGet(this, _Gumball_viewport, "f").addRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        }
        else {
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeRestrictedCanvasListenerToken(__classPrivateFieldGet(this, _Gumball_canvasEventListenerToken, "f"));
        }
    }
    onPointerOut(event) {
        if (this.closed)
            return;
        if (__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f")) {
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousRenderingFlag, "f"));
            __classPrivateFieldSet(this, _Gumball_continuousRenderingFlag, undefined, "f");
        }
        if (__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f")) {
            __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_continuousShadowMapUpdateFlag, "f"));
            __classPrivateFieldSet(this, _Gumball_continuousShadowMapUpdateFlag, undefined, "f");
        }
        __classPrivateFieldGet(this, _Gumball_viewport, "f").render();
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
    }
    onPointerUp(event) {
        if (this.closed)
            return;
        __classPrivateFieldSet(this, _Gumball_moving, false, "f");
    }
    // #endregion Public Methods (10)
    // #region Private Methods (7)
    activatePivotDragging() {
        __classPrivateFieldSet(this, _Gumball_pivotDragging, true, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").pivotDragged = true;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = true;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = false;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = false;
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f") === true && this.reuseTransformation === true) {
            const index = __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations.findIndex(t => t.id === 'SD_gumball_matrix');
            if (index !== -1) {
                __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.clone(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations[index].matrix);
            }
            else {
                __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.create();
            }
        }
        __classPrivateFieldSet(this, _Gumball_currentMatrix, __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix.clone()
            .multiply(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f")).invert()), "f");
    }
    deactivatePivotDragging() {
        __classPrivateFieldSet(this, _Gumball_pivotDragging, false, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").pivotDragged = false;
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableTranslation = __classPrivateFieldGet(this, _Gumball_enableTranslation, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableRotation = __classPrivateFieldGet(this, _Gumball_enableRotation, "f");
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").enableScaling = __classPrivateFieldGet(this, _Gumball_enableScaling, "f");
    }
    getMatrix(previousMatrix) {
        const m = new THREE.Matrix4().copy(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix);
        const placeholderMatrix = gl_matrix_1.mat4.fromValues(...m.toArray());
        const initialOffsetCorrectionMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.negate(gl_matrix_1.vec3.create(), __classPrivateFieldGet(this, _Gumball_initialOffset, "f")));
        const placeholderMatrixWithoutInitialOffset = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), placeholderMatrix, initialOffsetCorrectionMatrix);
        __classPrivateFieldSet(this, _Gumball_matrix, gl_matrix_1.mat4.clone(placeholderMatrixWithoutInitialOffset), "f");
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f") === true) {
            if (this.reuseTransformation === true) {
                const finalMatrix = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
                return finalMatrix;
            }
            else {
                const finalMatrix = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
                gl_matrix_1.mat4.multiply(finalMatrix, finalMatrix, previousMatrix);
                return finalMatrix;
            }
        }
        else {
            const finalMatrix = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.multiply(finalMatrix, placeholderMatrixWithoutInitialOffset, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f")));
            gl_matrix_1.mat4.multiply(finalMatrix, finalMatrix, previousMatrix);
            return finalMatrix;
        }
    }
    keyPressCheck(key) {
        const pressedKeys = Object.keys(__classPrivateFieldGet(this, _Gumball_keysPressed, "f")).filter(key => __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[key] === true);
        // check if it the only key that is pressed
        if (key.includes('+') && key.length > 1) {
            const keys = key.split('+');
            // there are more keys pressed than the keys in the combination
            if (keys.length !== pressedKeys.length)
                return false;
            let result = true;
            for (let i = 0; i < keys.length; i++)
                result = result && (__classPrivateFieldGet(this, _Gumball_keysPressed, "f")[keys[i]] || false);
            return result;
        }
        else {
            // there are also other keys pressed
            if (pressedKeys.length > 1)
                return false;
            return __classPrivateFieldGet(this, _Gumball_keysPressed, "f")[key] || false;
        }
    }
    setup() {
        // assign the position to the transformation controls objects
        if (__classPrivateFieldGet(this, _Gumball_singleNode, "f")) {
            const index = __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations.findIndex(t => t.id === 'SD_gumball_matrix');
            if (index !== -1) {
                __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.clone(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].transformations[index].matrix);
            }
            else {
                __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[0] = gl_matrix_1.mat4.create();
            }
            if (this.reuseTransformation === true) {
                const trueBB = new viewer_1.Box();
                __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].traverseData(d => {
                    if (d instanceof viewer_1.GeometryData) {
                        trueBB.union(d.boundingBox);
                    }
                });
                gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), trueBB.boundingSphere.center);
                __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
                const transformations = {};
                __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].traverse(c => {
                    if (c.name.startsWith('mesh_') && c.parent)
                        transformations[c.parent.name] = gl_matrix_1.mat4.clone(c.parent.nodeMatrix);
                });
                if (Object.keys(transformations).length === 1 && Object.keys(transformations)[0] !== 'no_transformations') {
                    __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.clone(transformations[Object.keys(transformations)[0]]);
                    const initialWorldTransform = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].worldMatrix, __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0]);
                    __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().fromArray(initialWorldTransform));
                }
                else {
                    __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.create();
                    __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_nodes, "f")[0].worldMatrix));
                }
            }
            else {
                __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[0] = gl_matrix_1.mat4.create();
                gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), __classPrivateFieldGet(this, _Gumball_nodes, "f")[0].boundingBox.boundingSphere.center);
                __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
            }
        }
        else {
            const boundingBox = new viewer_1.Box();
            __classPrivateFieldSet(this, _Gumball_previousGumballMatrix, [], "f");
            for (let i = 0; i < __classPrivateFieldGet(this, _Gumball_nodes, "f").length; i++) {
                const node = __classPrivateFieldGet(this, _Gumball_nodes, "f")[i];
                boundingBox.union(node.boundingBox);
                const index = node.transformations.findIndex(t => t.id === 'SD_gumball_matrix');
                if (index !== -1) {
                    __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f").push(gl_matrix_1.mat4.clone(node.transformations[index].matrix));
                }
                else {
                    __classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f").push(gl_matrix_1.mat4.create());
                }
                const transformations = {};
                node.traverse(c => {
                    if (c.name.startsWith('mesh_') && c.parent) {
                        transformations[c.parent.name] = gl_matrix_1.mat4.clone(c.parent.nodeMatrix);
                    }
                });
                if (Object.keys(transformations).length === 1 && Object.keys(transformations)[0] !== 'no_transformations') {
                    __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i] = gl_matrix_1.mat4.clone(transformations[Object.keys(transformations)[0]]);
                }
                else {
                    __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i] = gl_matrix_1.mat4.create();
                }
            }
            gl_matrix_1.vec3.copy(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"), boundingBox.boundingSphere.center);
            __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").applyMatrix4(new THREE.Matrix4().makeTranslation(new THREE.Vector3().fromArray(__classPrivateFieldGet(this, _Gumball_initialOffset, "f"))));
        }
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").attach(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").setSize(__classPrivateFieldGet(this, _Gumball_scale, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").add(__classPrivateFieldGet(this, _Gumball_transformControls, "f"));
        __classPrivateFieldGet(this, _Gumball_parentObject, "f").add(__classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f"));
        __classPrivateFieldGet(this, _Gumball_viewport, "f").threeJsCoreObjects.scene.add(__classPrivateFieldGet(this, _Gumball_parentObject, "f"));
        // we register the CAMERA_FREEZE whenever the dragging happens
        __classPrivateFieldGet(this, _Gumball_transformControls, "f").addEventListener('dragging-changed', (event) => {
            if (event.value === true) {
                if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"))
                    __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
                __classPrivateFieldSet(this, _Gumball_cameraFreezeFlag, __classPrivateFieldGet(this, _Gumball_viewport, "f").addFlag(viewer_1.FLAG_TYPE.CAMERA_FREEZE), "f");
            }
            else if (__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f")) {
                __classPrivateFieldGet(this, _Gumball_viewport, "f").removeFlag(__classPrivateFieldGet(this, _Gumball_cameraFreezeFlag, "f"));
                __classPrivateFieldSet(this, _Gumball_cameraFreezeFlag, undefined, "f");
            }
        });
    }
    updateObjectMatrices() {
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true) {
            const currentMatrix = __classPrivateFieldGet(this, _Gumball_transformationControlsPlaceholder, "f").matrix.clone()
                .multiply(new THREE.Matrix4().fromArray(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f")).invert());
            const delta = new THREE.Matrix4().multiplyMatrices(__classPrivateFieldGet(this, _Gumball_currentMatrix, "f").clone().invert(), currentMatrix);
            gl_matrix_1.mat4.multiply(__classPrivateFieldGet(this, _Gumball_pivotOffset, "f"), __classPrivateFieldGet(this, _Gumball_pivotOffset, "f"), gl_matrix_1.mat4.fromValues(...delta.toArray()));
            this.deactivatePivotDragging();
        }
        else {
            const eventData = {
                viewportId: __classPrivateFieldGet(this, _Gumball_viewport, "f").id,
                transformations: [],
                localTransformations: [],
                nodes: []
            };
            __classPrivateFieldGet(this, _Gumball_nodes, "f").forEach((node, i) => {
                const matrix = this.getMatrix(__classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[i]);
                eventData.nodes.push(node);
                if (__classPrivateFieldGet(this, _Gumball_singleNode, "f")) {
                    eventData.transformations.push(gl_matrix_1.mat4.clone(matrix));
                    gl_matrix_1.mat4.multiply(matrix, matrix, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
                }
                else {
                    eventData.transformations.push(gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), matrix, __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
                }
                const transformation = node.transformations.find(t => t.id === __classPrivateFieldGet(this, _Gumball_matrixId, "f"));
                eventData.localTransformations.push(gl_matrix_1.mat4.clone(matrix));
                if (transformation) {
                    transformation.matrix = matrix;
                }
                else {
                    node.transformations.push({
                        id: __classPrivateFieldGet(this, _Gumball_matrixId, "f"),
                        matrix
                    });
                }
                node.updateVersion();
            });
            // emit the event
            __classPrivateFieldGet(this, _Gumball_eventEngine, "f").emitEvent(viewer_shared_services_1.EVENTTYPE_GUMBALL.MATRIX_CHANGED, eventData);
        }
    }
    updateObjects() {
        if (__classPrivateFieldGet(this, _Gumball_pivotDragging, "f") === true)
            return;
        __classPrivateFieldGet(this, _Gumball_nodes, "f").forEach((node, i) => {
            const threeJsObject = node.convertedObject[__classPrivateFieldGet(this, _Gumball_viewport, "f").id];
            if (threeJsObject) {
                const matrix = this.getMatrix(__classPrivateFieldGet(this, _Gumball_previousGumballMatrix, "f")[i]);
                if (__classPrivateFieldGet(this, _Gumball_singleNode, "f"))
                    gl_matrix_1.mat4.multiply(matrix, matrix, gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), __classPrivateFieldGet(this, _Gumball_initialTransform, "f")[i]));
                threeJsObject.matrixAutoUpdate = false;
                threeJsObject.matrix.copy(new THREE.Matrix4().fromArray(matrix));
                threeJsObject.matrixWorldNeedsUpdate = true;
            }
        });
    }
}
exports.Gumball = Gumball;
_Gumball_eventEngine = new WeakMap(), _Gumball_keysPressed = new WeakMap(), _Gumball_matrixId = new WeakMap(), _Gumball_nodes = new WeakMap(), _Gumball_parentObject = new WeakMap(), _Gumball_singleNode = new WeakMap(), _Gumball_transformControls = new WeakMap(), _Gumball_transformationControlsPlaceholder = new WeakMap(), _Gumball_viewport = new WeakMap(), _Gumball_cameraFreezeFlag = new WeakMap(), _Gumball_canvasEventListenerToken = new WeakMap(), _Gumball_closed = new WeakMap(), _Gumball_continuousRenderingFlag = new WeakMap(), _Gumball_continuousShadowMapUpdateFlag = new WeakMap(), _Gumball_currentMatrix = new WeakMap(), _Gumball_enableRotation = new WeakMap(), _Gumball_enableRotationX = new WeakMap(), _Gumball_enableRotationY = new WeakMap(), _Gumball_enableRotationZ = new WeakMap(), _Gumball_enableScaling = new WeakMap(), _Gumball_enableScalingX = new WeakMap(), _Gumball_enableScalingY = new WeakMap(), _Gumball_enableScalingZ = new WeakMap(), _Gumball_enableTranslation = new WeakMap(), _Gumball_enableTranslationX = new WeakMap(), _Gumball_enableTranslationY = new WeakMap(), _Gumball_enableTranslationZ = new WeakMap(), _Gumball_initialOffset = new WeakMap(), _Gumball_initialTransform = new WeakMap(), _Gumball_matrix = new WeakMap(), _Gumball_moving = new WeakMap(), _Gumball_pivotDragging = new WeakMap(), _Gumball_pivotOffset = new WeakMap(), _Gumball_previousGumballMatrix = new WeakMap(), _Gumball_reuseTransformation = new WeakMap(), _Gumball_scale = new WeakMap(), _Gumball_show = new WeakMap(), _Gumball_space = new WeakMap();
//# sourceMappingURL=Gumball.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformControlsPlane = exports.TransformControlsGizmo = exports.TransformControls = void 0;
const three_1 = require("three");
/* eslint-disable @typescript-eslint/no-explicit-any */
const _raycaster = new three_1.Raycaster();
const _tempVector = new three_1.Vector3();
const _tempVector2 = new three_1.Vector3();
const _tempQuaternion = new three_1.Quaternion();
const _unit = {
    X: new three_1.Vector3(1, 0, 0),
    Y: new three_1.Vector3(0, 1, 0),
    Z: new three_1.Vector3(0, 0, 1)
};
var TransformationType;
(function (TransformationType) {
    TransformationType["TRANSLATION"] = "translation";
    TransformationType["ROTATION"] = "rotation";
    TransformationType["SCALE"] = "scale";
})(TransformationType || (TransformationType = {}));
class TransformControls extends three_1.Object3D {
    // #endregion Properties (59)
    // #region Constructors (1)
    constructor(camera, domElement, updateCallback, updateMatricesCallback) {
        super();
        // #region Properties (59)
        this._axis = null;
        this._cameraPosition = new three_1.Vector3();
        this._cameraQuaternion = new three_1.Quaternion();
        this._dragging = false;
        this._enableRotation = true;
        this._enableRotationX = true;
        this._enableRotationY = true;
        this._enableRotationZ = true;
        this._enableScaling = true;
        this._enableScalingX = true;
        this._enableScalingY = true;
        this._enableScalingZ = true;
        this._enableTranslation = true;
        this._enableTranslationX = true;
        this._enableTranslationY = true;
        this._enableTranslationZ = true;
        this._enabled = true;
        this._eye = new three_1.Vector3();
        this._hovering = false;
        this._object = undefined;
        this._parentQuaternionInv = new three_1.Quaternion();
        this._pivotDragged = false;
        this._pointEnd = new three_1.Vector3();
        this._pointStart = new three_1.Vector3();
        this._rotationAngle = 0;
        this._rotationAxis = new three_1.Vector3();
        this._rotationSnap = null;
        this._scaleSnap = null;
        this._showX = true;
        this._showY = true;
        this._showZ = true;
        this._size = 1;
        this._space = 'local';
        this._translationSnap = null;
        this._worldPosition = new three_1.Vector3();
        this._worldPositionStart = new three_1.Vector3();
        this._worldQuaternion = new three_1.Quaternion();
        this._worldQuaternionStart = new three_1.Quaternion();
        this.userData.ambientOcclusion = false;
        this._camera = camera;
        this._updateCallback = updateCallback;
        this._updateMatricesCallback = updateMatricesCallback;
        if (domElement === undefined) {
            console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
            domElement = document;
        }
        this.isTransformControls = true;
        this.visible = false;
        this.domElement = domElement;
        this.domElement.style.touchAction = 'none'; // disable touch scroll
        const _gizmo = new TransformControlsGizmo(this);
        this._gizmo = _gizmo;
        this.add(_gizmo);
        const _plane = new TransformControlsPlane(this);
        this._plane = _plane;
        this.add(_plane);
        // Define properties with getters/setter
        // Setting the defined property will automatically trigger change event
        // Defined properties are passed down to gizmo and plane
        this._offset = new three_1.Vector3();
        this._startNorm = new three_1.Vector3();
        this._endNorm = new three_1.Vector3();
        this._cameraScale = new three_1.Vector3();
        this._parentPosition = new three_1.Vector3();
        this._parentQuaternion = new three_1.Quaternion();
        this._parentQuaternion = new three_1.Quaternion();
        this._parentScale = new three_1.Vector3();
        this._worldScaleStart = new three_1.Vector3();
        this._worldQuaternionInv = new three_1.Quaternion();
        this._worldScale = new three_1.Vector3();
        this._positionStart = new three_1.Vector3();
        this._quaternionStart = new three_1.Quaternion();
        this._scaleStart = new three_1.Vector3();
    }
    // #endregion Constructors (1)
    // #region Public Getters And Setters (66)
    get axis() {
        return this._axis;
    }
    set axis(value) {
        this._axis = value;
    }
    get camera() {
        return this._camera;
    }
    get cameraPosition() {
        return this._cameraPosition;
    }
    get cameraQuaternion() {
        return this._cameraQuaternion;
    }
    get dragging() {
        return this._dragging;
    }
    set dragging(value) {
        this._dragging = value;
        this.dispatchEvent({ type: 'dragging-changed', value });
    }
    get enableRotation() {
        return this._enableRotation;
    }
    set enableRotation(value) {
        this._enableRotation = value;
    }
    get enableRotationX() {
        return this._enableRotationX;
    }
    set enableRotationX(value) {
        this._enableRotationX = value;
    }
    get enableRotationY() {
        return this._enableRotationY;
    }
    set enableRotationY(value) {
        this._enableRotationY = value;
    }
    get enableRotationZ() {
        return this._enableRotationZ;
    }
    set enableRotationZ(value) {
        this._enableRotationZ = value;
    }
    get enableScaling() {
        return this._enableScaling;
    }
    set enableScaling(value) {
        this._enableScaling = value;
    }
    get enableScalingX() {
        return this._enableScalingX;
    }
    set enableScalingX(value) {
        this._enableScalingX = value;
    }
    get enableScalingY() {
        return this._enableScalingY;
    }
    set enableScalingY(value) {
        this._enableScalingY = value;
    }
    get enableScalingZ() {
        return this._enableScalingZ;
    }
    set enableScalingZ(value) {
        this._enableScalingZ = value;
    }
    get enableTranslation() {
        return this._enableTranslation;
    }
    set enableTranslation(value) {
        this._enableTranslation = value;
    }
    get enableTranslationX() {
        return this._enableTranslationX;
    }
    set enableTranslationX(value) {
        this._enableTranslationX = value;
    }
    get enableTranslationY() {
        return this._enableTranslationY;
    }
    set enableTranslationY(value) {
        this._enableTranslationY = value;
    }
    get enableTranslationZ() {
        return this._enableTranslationZ;
    }
    set enableTranslationZ(value) {
        this._enableTranslationZ = value;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = value;
    }
    get eye() {
        return this._eye;
    }
    get hovering() {
        return this._hovering;
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        this._mode = value;
    }
    get object() {
        return this._object;
    }
    set object(value) {
        this._object = value;
    }
    get pivotDragged() {
        return this._pivotDragged;
    }
    set pivotDragged(value) {
        this._pivotDragged = value;
    }
    get pointEnd() {
        return this._pointEnd;
    }
    get pointStart() {
        return this._pointStart;
    }
    get rotationAngle() {
        return this._rotationAngle;
    }
    set rotationAngle(value) {
        this._rotationAngle = value;
    }
    get rotationAxis() {
        return this._rotationAxis;
    }
    get rotationSnap() {
        return this._rotationSnap;
    }
    set rotationSnap(value) {
        this._rotationSnap = value;
    }
    get scaleSnap() {
        return this._scaleSnap;
    }
    set scaleSnap(value) {
        this._scaleSnap = value;
    }
    get showX() {
        return this._showX;
    }
    set showX(value) {
        this._showX = value;
    }
    get showY() {
        return this._showY;
    }
    set showY(value) {
        this._showY = value;
    }
    get showZ() {
        return this._showZ;
    }
    set showZ(value) {
        this._showZ = value;
    }
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
    }
    get space() {
        return this._space;
    }
    set space(value) {
        this._space = value;
    }
    get translationSnap() {
        return this._translationSnap;
    }
    set translationSnap(value) {
        this._translationSnap = value;
    }
    get worldPosition() {
        return this._worldPosition;
    }
    get worldPositionStart() {
        return this._worldPositionStart;
    }
    get worldQuaternion() {
        return this._worldQuaternion;
    }
    get worldQuaternionStart() {
        return this._worldQuaternionStart;
    }
    // #endregion Public Getters And Setters (66)
    // #region Public Methods (21)
    // Set current object
    attach(object) {
        this.object = object;
        this.visible = true;
        return this;
    }
    // Detach from object
    detach() {
        this.object = undefined;
        this.visible = false;
        this.axis = null;
        return this;
    }
    dispose() {
        this.traverse(function (child) {
            if (child.geometry)
                child.geometry.dispose();
            if (child.material)
                child.material.dispose();
        });
    }
    getPointer(event) {
        if (this.domElement.ownerDocument.pointerLockElement) {
            return {
                x: 0,
                y: 0,
                button: event.button
            };
        }
        else {
            const rect = this.domElement.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left) / rect.width * 2 - 1,
                y: -(event.clientY - rect.top) / rect.height * 2 + 1,
                button: event.button
            };
        }
    }
    getRaycaster() {
        return _raycaster;
    }
    intersectObjectWithRay(object, raycaster, includeInvisible) {
        const allIntersections = raycaster.intersectObject(object, true);
        for (let i = 0; i < allIntersections.length; i++) {
            if (allIntersections[i].object.visible || includeInvisible) {
                return allIntersections[i];
            }
        }
        return false;
    }
    onPointerDown(event) {
        if (!this.enabled)
            return;
        if (!document.pointerLockElement) {
            this.domElement.setPointerCapture(event.pointerId);
        }
        this.pointerHover(this.getPointer(event));
        this.pointerDown(this.getPointer(event));
    }
    onPointerHover(event) {
        if (!this.enabled)
            return;
        switch (event.pointerType) {
            case 'mouse':
            case 'pen':
                this.pointerHover(this.getPointer(event));
                break;
        }
    }
    onPointerMove(event) {
        if (!this.enabled)
            return;
        this.pointerMove(this.getPointer(event));
    }
    onPointerUp(event) {
        if (!this.enabled)
            return;
        this.domElement.releasePointerCapture(event.pointerId);
        this.pointerUp(this.getPointer(event));
    }
    pointerDown(pointer) {
        var _a, _b;
        if (this.object === undefined || this.dragging === true || (pointer != null && pointer.button !== 0))
            return;
        if (this.axis !== null) {
            if (pointer !== null)
                _raycaster.setFromCamera(pointer, this.camera);
            const planeIntersect = this.intersectObjectWithRay(this._plane, _raycaster, true);
            if (planeIntersect) {
                this.object.updateMatrixWorld();
                (_b = (_a = this.object) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.updateMatrixWorld();
                this._positionStart.copy(this.object.position);
                this._quaternionStart.copy(this.object.quaternion);
                this._scaleStart.copy(this.object.scale);
                this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
                this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
            }
            this.dragging = true;
        }
    }
    pointerHover(pointer) {
        if (this.object === undefined || this.dragging === true)
            return;
        if (pointer !== null)
            _raycaster.setFromCamera(pointer, this.camera);
        const intersections = [];
        if (this.enableTranslation) {
            const intersection = this.intersectObjectWithRay(this._gizmo.picker.translate, _raycaster, true);
            if (intersection) {
                intersections.push({
                    mode: TransformationType.TRANSLATION,
                    intersection
                });
            }
        }
        if (this.enableRotation) {
            const intersection = this.intersectObjectWithRay(this._gizmo.picker.rotate, _raycaster, true);
            if (intersection) {
                intersections.push({
                    mode: TransformationType.ROTATION,
                    intersection
                });
            }
        }
        if (this.enableScaling && this.space === 'local') {
            const intersection = this.intersectObjectWithRay(this._gizmo.picker.scale, _raycaster, true);
            if (intersection) {
                intersections.push({
                    mode: TransformationType.SCALE,
                    intersection
                });
            }
        }
        intersections.sort((a, b) => a.intersection.distance - b.intersection.distance);
        if (intersections.length > 0) {
            this.axis = intersections[0].intersection.object.name;
            this.mode = intersections[0].mode;
        }
        else {
            this.axis = null;
            this.mode = undefined;
        }
        this._hovering = intersections.length > 0;
    }
    pointerMove(pointer) {
        const axis = this.axis;
        const object = this.object;
        let space = this.space;
        if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {
            space = 'world';
        }
        if (object === undefined || axis === null || this.dragging === false || (pointer !== null && pointer.button !== -1))
            return;
        if (pointer !== null)
            _raycaster.setFromCamera(pointer, this.camera);
        const planeIntersect = this.intersectObjectWithRay(this._plane, _raycaster, true);
        if (!planeIntersect)
            return;
        this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
        if (this.mode === TransformationType.TRANSLATION) {
            // Apply translate
            this._offset.copy(this.pointEnd).sub(this.pointStart);
            if (space === 'local' && axis !== 'XYZ') {
                this._offset.applyQuaternion(this._worldQuaternionInv);
            }
            if (axis.indexOf('X') === -1)
                this._offset.x = 0;
            if (axis.indexOf('Y') === -1)
                this._offset.y = 0;
            if (axis.indexOf('Z') === -1)
                this._offset.z = 0;
            if (space === 'local' && axis !== 'XYZ') {
                this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
            }
            else {
                this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
            }
            object.position.copy(this._offset).add(this._positionStart);
            // Apply translation snap
            if (this.translationSnap) {
                if (space === 'local') {
                    object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
                    if (axis.search('X') !== -1) {
                        object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
                    }
                    if (axis.search('Y') !== -1) {
                        object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
                    }
                    if (axis.search('Z') !== -1) {
                        object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
                    }
                    object.position.applyQuaternion(this._quaternionStart);
                }
                if (space === 'world') {
                    if (object.parent) {
                        object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
                    }
                    if (axis.search('X') !== -1) {
                        object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
                    }
                    if (axis.search('Y') !== -1) {
                        object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
                    }
                    if (axis.search('Z') !== -1) {
                        object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
                    }
                    if (object.parent) {
                        object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
                    }
                }
            }
        }
        if (this.mode === TransformationType.SCALE && space === 'local') {
            if (axis.search('XYZ') !== -1) {
                let d = this.pointEnd.length() / this.pointStart.length();
                if (this.pointEnd.dot(this.pointStart) < 0)
                    d *= -1;
                _tempVector2.set(d, d, d);
            }
            else {
                _tempVector.copy(this.pointStart);
                _tempVector2.copy(this.pointEnd);
                _tempVector.applyQuaternion(this._worldQuaternionInv);
                _tempVector2.applyQuaternion(this._worldQuaternionInv);
                _tempVector2.divide(_tempVector);
                if (axis.search('X') === -1) {
                    _tempVector2.x = 1;
                }
                if (axis.search('Y') === -1) {
                    _tempVector2.y = 1;
                }
                if (axis.search('Z') === -1) {
                    _tempVector2.z = 1;
                }
            }
            // Apply scale
            object.scale.copy(this._scaleStart).multiply(_tempVector2);
            if (this.scaleSnap) {
                if (axis.search('X') !== -1) {
                    object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
                }
                if (axis.search('Y') !== -1) {
                    object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
                }
                if (axis.search('Z') !== -1) {
                    object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
                }
            }
        }
        if (this.mode === TransformationType.ROTATION) {
            this._offset.copy(this.pointEnd).sub(this.pointStart);
            const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
            let _inPlaneRotation = false;
            if (axis === 'XYZE') {
                this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
                this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
            }
            else if (axis === 'X' || axis === 'Y' || axis === 'Z') {
                this.rotationAxis.copy(_unit[axis]);
                _tempVector.copy(_unit[axis]);
                if (space === 'local') {
                    _tempVector.applyQuaternion(this.worldQuaternion);
                }
                _tempVector.cross(this.eye);
                // When _tempVector is 0 after cross with this.eye the vectors are parallel and should use in-plane rotation logic.
                if (_tempVector.length() === 0) {
                    _inPlaneRotation = true;
                }
                else {
                    this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
                }
            }
            if (axis === 'E' || _inPlaneRotation) {
                this.rotationAxis.copy(this.eye);
                this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
                this._startNorm.copy(this.pointStart).normalize();
                this._endNorm.copy(this.pointEnd).normalize();
                this.rotationAngle *= (this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1);
            }
            // Apply rotation snap
            if (this.rotationSnap)
                this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
            // Apply rotate
            if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {
                object.quaternion.copy(this._quaternionStart);
                object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
            }
            else {
                this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
                object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
                object.quaternion.multiply(this._quaternionStart).normalize();
            }
        }
        if (this._updateCallback)
            this._updateCallback();
    }
    pointerUp(pointer) {
        if (pointer !== null && pointer.button !== 0)
            return;
        if (this.dragging && (this.axis !== null)) {
            if (this._updateMatricesCallback)
                this._updateMatricesCallback();
        }
        this.dragging = false;
        this.axis = null;
    }
    reset() {
        var _a, _b, _c;
        if (!this.enabled)
            return;
        if (this.dragging) {
            (_a = this.object) === null || _a === void 0 ? void 0 : _a.position.copy(this._positionStart);
            (_b = this.object) === null || _b === void 0 ? void 0 : _b.quaternion.copy(this._quaternionStart);
            (_c = this.object) === null || _c === void 0 ? void 0 : _c.scale.copy(this._scaleStart);
            this.pointStart.copy(this.pointEnd);
        }
    }
    setRotationSnap(rotationSnap) {
        this.rotationSnap = rotationSnap;
    }
    setScaleSnap(scaleSnap) {
        this.scaleSnap = scaleSnap;
    }
    setSize(size) {
        this.size = size;
    }
    setSpace(space) {
        this.space = space;
    }
    setTranslationSnap(translationSnap) {
        this.translationSnap = translationSnap;
    }
    // updateMatrixWorld updates key transformation variables
    updateMatrixWorld(force = false) {
        if (this.object !== undefined) {
            this.object.updateMatrixWorld();
            if (this.object.parent === null) {
                console.error('TransformControls: The attached 3D object must be a part of the scene graph.');
            }
            else {
                this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
            }
            this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
            this._parentQuaternionInv.copy(this._parentQuaternion).invert();
            this._worldQuaternionInv.copy(this.worldQuaternion).invert();
        }
        this.camera.updateMatrixWorld();
        this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
        if (this.camera.isOrthographicCamera) {
            this.camera.getWorldDirection(this.eye).negate();
        }
        else {
            this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
        }
        super.updateMatrixWorld(force);
    }
}
exports.TransformControls = TransformControls;
// mouse / touch event handlers
//
// Reusable utility variables
const _tempEuler = new three_1.Euler();
const _alignVector = new three_1.Vector3(0, 1, 0);
const _zeroVector = new three_1.Vector3(0, 0, 0);
const _lookAtMatrix = new three_1.Matrix4();
const _tempQuaternion2 = new three_1.Quaternion();
const _identityQuaternion = new three_1.Quaternion();
const _dirVector = new three_1.Vector3();
const _tempMatrix = new three_1.Matrix4();
const _unitX = new three_1.Vector3(1, 0, 0);
const _unitY = new three_1.Vector3(0, 1, 0);
const _unitZ = new three_1.Vector3(0, 0, 1);
const _v1 = new three_1.Vector3();
const _v2 = new three_1.Vector3();
const _v3 = new three_1.Vector3();
class TransformControlsGizmo extends three_1.Object3D {
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor(_transformControls) {
        super();
        this._transformControls = _transformControls;
        this.isTransformControlsGizmo = true;
        this.type = 'TransformControlsGizmo';
        // shared materials
        const gizmoMaterial = new three_1.MeshBasicMaterial({
            depthTest: false,
            depthWrite: false,
            fog: false,
            toneMapped: false,
            transparent: true
        });
        const gizmoLineMaterial = new three_1.LineBasicMaterial({
            depthTest: false,
            depthWrite: false,
            fog: false,
            toneMapped: false,
            transparent: true
        });
        // Make unique material for each axis/color
        const materialInvisible = gizmoMaterial.clone();
        materialInvisible.opacity = 0.15;
        const translationMaterialInvisible = materialInvisible.clone();
        const rotationMaterialInvisible = materialInvisible.clone();
        const scaleMaterialInvisible = materialInvisible.clone();
        const materialHelper = gizmoLineMaterial.clone();
        materialHelper.opacity = 0.5;
        const translationMaterialHelper = materialHelper.clone();
        const rotationMaterialHelper = materialHelper.clone();
        const scaleMaterialHelper = materialHelper.clone();
        const materialRed = gizmoMaterial.clone();
        materialRed.color.setHex(0xff0000);
        const translationMaterialRed = materialRed.clone();
        const rotationMaterialRed = materialRed.clone();
        const scaleMaterialRed = materialRed.clone();
        const materialGreen = gizmoMaterial.clone();
        materialGreen.color.setHex(0x00ff00);
        const translationMaterialGreen = materialGreen.clone();
        const rotationMaterialGreen = materialGreen.clone();
        const scaleMaterialGreen = materialGreen.clone();
        const materialBlue = gizmoMaterial.clone();
        materialBlue.color.setHex(0x0000ff);
        const translationMaterialBlue = materialBlue.clone();
        const rotationMaterialBlue = materialBlue.clone();
        const scaleMaterialBlue = materialBlue.clone();
        const materialRedTransparent = gizmoMaterial.clone();
        materialRedTransparent.color.setHex(0xff0000);
        materialRedTransparent.opacity = 0.5;
        const translationMaterialRedTransparent = materialRedTransparent.clone();
        const scaleMaterialRedTransparent = materialRedTransparent.clone();
        const materialGreenTransparent = gizmoMaterial.clone();
        materialGreenTransparent.color.setHex(0x00ff00);
        materialGreenTransparent.opacity = 0.5;
        const translationMaterialGreenTransparent = materialGreenTransparent.clone();
        const scaleMaterialGreenTransparent = materialGreenTransparent.clone();
        const materialBlueTransparent = gizmoMaterial.clone();
        materialBlueTransparent.color.setHex(0x0000ff);
        materialBlueTransparent.opacity = 0.5;
        const translationMaterialBlueTransparent = materialBlueTransparent.clone();
        const scaleMaterialBlueTransparent = materialBlueTransparent.clone();
        const materialWhiteTransparent = gizmoMaterial.clone();
        materialWhiteTransparent.opacity = 0.25;
        const translationMaterialWhiteTransparent = materialWhiteTransparent.clone();
        const scaleMaterialWhiteTransparent = materialWhiteTransparent.clone();
        const materialYellowTransparent = gizmoMaterial.clone();
        materialYellowTransparent.color.setHex(0xffff00);
        materialYellowTransparent.opacity = 0.25;
        const rotationMaterialYellowTransparent = materialYellowTransparent.clone();
        const materialGray = gizmoMaterial.clone();
        materialGray.color.setHex(0x787878);
        const rotationMaterialGray = materialGray.clone();
        // reusable geometry
        const arrowGeo = new three_1.CylinderGeometry(0, 0.04, 0.1, 12);
        arrowGeo.translate(0, 0.05, 0);
        const translationArrowGeometry = arrowGeo.clone();
        const scaleHandleGeometry = new three_1.BoxGeometry(0.08, 0.08, 0.08);
        scaleHandleGeometry.translate(0, 0.04, 0);
        const lineGeo = new three_1.BufferGeometry();
        lineGeo.setAttribute('position', new three_1.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
        const translationLineGeometry = lineGeo.clone();
        const scaleLineGeometry = lineGeo.clone();
        const rotationLineGeometry = lineGeo.clone();
        const lineGeo2 = new three_1.CylinderGeometry(0.0075, 0.0075, 0.5, 3);
        lineGeo2.translate(0, 0.25, 0);
        const translationLineGeometry2 = lineGeo2.clone();
        function CircleGeometry(radius, arc) {
            const geometry = new three_1.TorusGeometry(radius, 0.0075, 3, 64, arc * Math.PI * 2);
            geometry.rotateY(Math.PI / 2);
            geometry.rotateX(Math.PI / 2);
            return geometry;
        }
        // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position
        function TranslateHelperGeometry() {
            const geometry = new three_1.BufferGeometry();
            geometry.setAttribute('position', new three_1.Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
            return geometry;
        }
        const gizmoTranslate = {
            X: [
                [new three_1.Mesh(translationArrowGeometry, translationMaterialRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
                // [new Mesh(translationArrowGeometry, translationMaterialRed), [- 0.5, 0, 0], [0, 0, Math.PI / 2]],
                [new three_1.Mesh(translationLineGeometry2, translationMaterialRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
            ],
            Y: [
                [new three_1.Mesh(translationArrowGeometry, translationMaterialGreen), [0, 0.5, 0]],
                // [new Mesh(translationArrowGeometry, translationMaterialGreen), [0, - 0.5, 0], [Math.PI, 0, 0]],
                [new three_1.Mesh(translationLineGeometry2, translationMaterialGreen)]
            ],
            Z: [
                [new three_1.Mesh(translationArrowGeometry, translationMaterialBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
                // [new Mesh(translationArrowGeometry, translationMaterialBlue), [0, 0, - 0.5], [- Math.PI / 2, 0, 0]],
                [new three_1.Mesh(translationLineGeometry2, translationMaterialBlue), null, [Math.PI / 2, 0, 0]]
            ],
            XYZ: [
                [new three_1.Mesh(new three_1.OctahedronGeometry(0.1, 0), translationMaterialWhiteTransparent.clone()), [0, 0, 0]]
            ],
            XY: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialBlueTransparent.clone()), [0.25, 0.25, 0]]
            ],
            YZ: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialRedTransparent.clone()), [0, 0.25, 0.25], [0, Math.PI / 2, 0]]
            ],
            XZ: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.15, 0.15, 0.01), translationMaterialGreenTransparent.clone()), [0.25, 0, 0.25], [-Math.PI / 2, 0, 0]]
            ]
        };
        const pickerTranslate = {
            X: [
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [- 0.3, 0, 0], [0, 0, Math.PI / 2]]
            ],
            Y: [
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0.3, 0]],
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, - 0.3, 0], [0, 0, Math.PI]]
            ],
            Z: [
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), translationMaterialInvisible), [0, 0, - 0.3], [- Math.PI / 2, 0, 0]]
            ],
            XYZ: [
                [new three_1.Mesh(new three_1.OctahedronGeometry(0.2, 0), translationMaterialInvisible)]
            ],
            XY: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0.25, 0.25, 0]]
            ],
            YZ: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0, 0.25, 0.25], [0, Math.PI / 2, 0]]
            ],
            XZ: [
                [new three_1.Mesh(new three_1.BoxGeometry(0.2, 0.2, 0.01), translationMaterialInvisible), [0.25, 0, 0.25], [-Math.PI / 2, 0, 0]]
            ]
        };
        const helperTranslate = {
            START: [
                [new three_1.Mesh(new three_1.OctahedronGeometry(0.01, 2), translationMaterialHelper), null, null, null, 'helper']
            ],
            END: [
                [new three_1.Mesh(new three_1.OctahedronGeometry(0.01, 2), translationMaterialHelper), null, null, null, 'helper']
            ],
            DELTA: [
                [new three_1.Line(TranslateHelperGeometry(), translationMaterialHelper), null, null, null, 'helper']
            ],
            X: [
                [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']
            ],
            Y: [
                [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']
            ],
            Z: [
                [new three_1.Line(translationLineGeometry, translationMaterialHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']
            ]
        };
        const rotationScale = 1.5;
        const gizmoRotate = {
            // XYZE: [
            //     [new Mesh(CircleGeometry(0.5 * rotationScale, 1), rotationMaterialGray), null, [0, Math.PI / 2, 0]]
            // ],
            X: [
                [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialRed)]
            ],
            Y: [
                [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialGreen), null, [0, 0, -Math.PI / 2]]
            ],
            Z: [
                [new three_1.Mesh(CircleGeometry(0.5 * rotationScale, 0.5), rotationMaterialBlue), null, [0, Math.PI / 2, 0]]
            ],
            E: [
                [new three_1.Mesh(CircleGeometry(0.6 * rotationScale, 1), rotationMaterialYellowTransparent), null, [0, Math.PI / 2, 0]]
            ]
        };
        const helperRotate = {
            AXIS: [
                [new three_1.Line(rotationLineGeometry, rotationMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']
            ]
        };
        const pickerRotate = {
            // XYZE: [
            //     [new Mesh(new SphereGeometry(0.25 * rotationScale, 10, 8), rotationMaterialInvisible)]
            // ],
            X: [
                [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]],
            ],
            Y: [
                [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]],
            ],
            Z: [
                [new three_1.Mesh(new three_1.TorusGeometry(0.5 * rotationScale, 0.1, 4, 24), rotationMaterialInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]],
            ],
            E: [
                [new three_1.Mesh(new three_1.TorusGeometry(0.6 * rotationScale, 0.1, 2, 24), rotationMaterialInvisible)]
            ]
        };
        const gizmoScale = {
            X: [
                // [new Mesh(scaleHandleGeometry, scaleMaterialRed), [0.5, 0, 0], [0, 0, - Math.PI / 2]],
                // [new Mesh(scaleLineGeometry2, scaleMaterialRed), [0, 0, 0], [0, 0, - Math.PI / 2]],
                [new three_1.Mesh(scaleHandleGeometry, scaleMaterialRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
            ],
            Y: [
                // [new Mesh(scaleHandleGeometry, scaleMaterialGreen), [0, 0.5, 0]],
                // [new Mesh(scaleLineGeometry2, scaleMaterialGreen)],
                [new three_1.Mesh(scaleHandleGeometry, scaleMaterialGreen), [0, -0.5, 0], [0, 0, Math.PI]],
            ],
            Z: [
                // [new Mesh(scaleHandleGeometry, scaleMaterialBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
                // [new Mesh(scaleLineGeometry2, scaleMaterialBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
                [new three_1.Mesh(scaleHandleGeometry, scaleMaterialBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
            ],
            // XY: [
            //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialBlueTransparent), [0.15, 0.15, 0]]
            // ],
            // YZ: [
            //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
            // ],
            // XZ: [
            //     [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), scaleMaterialGreenTransparent), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]
            // ],
            // XYZ: [
            //     [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), scaleMaterialWhiteTransparent.clone())],
            // ]
        };
        const pickerScale = {
            X: [
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0.3, 0, 0], [0, 0, - Math.PI / 2]],
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
            ],
            Y: [
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0.3, 0]],
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
            ],
            Z: [
                // [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
                [new three_1.Mesh(new three_1.CylinderGeometry(0.2, 0, 0.6, 4), scaleMaterialInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
            ],
            // XY: [
            //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0.15, 0.15, 0]],
            // ],
            // YZ: [
            //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
            // ],
            // XZ: [
            //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), scaleMaterialInvisible), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]],
            // ],
            // XYZ: [
            //     [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), scaleMaterialInvisible), [0, 0, 0]],
            // ]
        };
        const helperScale = {
            X: [
                [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']
            ],
            Y: [
                [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']
            ],
            Z: [
                [new three_1.Line(scaleLineGeometry, scaleMaterialHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']
            ]
        };
        // Creates an Object3D with gizmos described in custom hierarchy definition.
        function setupGizmo(gizmoMap) {
            const gizmo = new three_1.Object3D();
            for (const name in gizmoMap) {
                for (let i = gizmoMap[name].length; i--;) {
                    const object = gizmoMap[name][i][0].clone();
                    const position = gizmoMap[name][i][1];
                    const rotation = gizmoMap[name][i][2];
                    const scale = gizmoMap[name][i][3];
                    const tag = gizmoMap[name][i][4];
                    // name and tag properties are essential for picking and updating logic.
                    object.name = name;
                    object.userData.ambientOcclusion = false;
                    object.tag = tag;
                    if (position) {
                        object.position.set(position[0], position[1], position[2]);
                    }
                    if (rotation) {
                        object.rotation.set(rotation[0], rotation[1], rotation[2]);
                    }
                    if (scale) {
                        object.scale.set(scale[0], scale[1], scale[2]);
                    }
                    object.updateMatrix();
                    const tempGeometry = object.geometry.clone();
                    tempGeometry.applyMatrix4(object.matrix);
                    object.geometry = tempGeometry;
                    object.renderOrder = Infinity;
                    object.position.set(0, 0, 0);
                    object.rotation.set(0, 0, 0);
                    object.scale.set(1, 1, 1);
                    gizmo.add(object);
                }
            }
            return gizmo;
        }
        // Gizmo creation
        this.gizmo = {
            'translate': setupGizmo(gizmoTranslate),
            'rotate': setupGizmo(gizmoRotate),
            'scale': setupGizmo(gizmoScale),
        };
        this.picker = {
            'translate': setupGizmo(pickerTranslate),
            'rotate': setupGizmo(pickerRotate),
            'scale': setupGizmo(pickerScale),
        };
        this.helper = {
            'translate': setupGizmo(helperTranslate),
            'rotate': setupGizmo(helperRotate),
            'scale': setupGizmo(helperScale),
        };
        this.add(this.gizmo['scale']);
        this.add(this.picker['scale']);
        this.add(this.helper['scale']);
        this.add(this.gizmo['translate']);
        this.add(this.picker['translate']);
        this.add(this.helper['translate']);
        this.add(this.gizmo['rotate']);
        this.add(this.picker['rotate']);
        this.add(this.helper['rotate']);
        // Pickers should be hidden always
        this.picker['translate'].visible = false;
        this.picker['rotate'].visible = false;
        this.picker['scale'].visible = false;
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    // updateMatrixWorld will update transformations and appearance of individual handles
    updateMatrixWorld(force) {
        var _a;
        const space = this._transformControls.space;
        let quaternion = new three_1.Quaternion();
        if (space === 'local') {
            (_a = this._transformControls.object) === null || _a === void 0 ? void 0 : _a.getWorldQuaternion(quaternion);
        }
        else {
            quaternion = _identityQuaternion;
        }
        // Show only gizmos for current transform mode
        this.gizmo['translate'].visible = this._transformControls.enableTranslation;
        this.gizmo['rotate'].visible = this._transformControls.enableRotation;
        this.gizmo['scale'].visible = this._transformControls.enableScaling && this._transformControls.space === 'local';
        this.helper['translate'].visible = this._transformControls.enableTranslation;
        this.helper['rotate'].visible = this._transformControls.enableRotation;
        this.helper['scale'].visible = this._transformControls.enableScaling && this._transformControls.space === 'local';
        let handles = [];
        if (this._transformControls.enableTranslation) {
            let pickers = this.picker.translate.children;
            let gizmos = this.gizmo.translate.children;
            let helpers = this.helper.translate.children;
            // filter out all X handles if X is disabled
            if (this._transformControls.enableTranslationX === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'X');
            // filter out all Y handles if Y is disabled
            if (this._transformControls.enableTranslationY === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Y');
            // filter out all Z handles if Z is disabled
            if (this._transformControls.enableTranslationZ === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Z');
            handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
            handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
            handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.TRANSLATION })));
        }
        if (this._transformControls.enableRotation) {
            let pickers = this.picker.rotate.children;
            let gizmos = this.gizmo.rotate.children;
            let helpers = this.helper.rotate.children;
            // filter out all X handles if X is disabled
            if (this._transformControls.enableRotationX === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'X');
            // filter out all Y handles if Y is disabled
            if (this._transformControls.enableRotationY === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Y');
            // filter out all Z handles if Z is disabled
            if (this._transformControls.enableRotationZ === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Z');
            // filter out all E handles if one of the axis is disabled
            if (this._transformControls.enableRotationX === false || this._transformControls.enableRotationY === false || this._transformControls.enableRotationZ === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'E');
            handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.ROTATION })));
            handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.ROTATION })));
            handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.ROTATION })));
        }
        if (this._transformControls.enableScaling && this._transformControls.space === 'local') {
            let pickers = this.picker.scale.children;
            let gizmos = this.gizmo.scale.children;
            let helpers = this.helper.scale.children;
            // filter out all X handles if X is disabled
            if (this._transformControls.enableScalingX === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'X');
            // filter out all Y handles if Y is disabled
            if (this._transformControls.enableScalingY === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Y');
            // filter out all Z handles if Z is disabled
            if (this._transformControls.enableScalingZ === false)
                [pickers, gizmos, helpers] = this.filterOutAxis(pickers, gizmos, helpers, 'Z');
            handles = handles.concat(pickers.map((object) => ({ object, mode: TransformationType.SCALE })));
            handles = handles.concat(gizmos.map((object) => ({ object, mode: TransformationType.SCALE })));
            handles = handles.concat(helpers.map((object) => ({ object, mode: TransformationType.SCALE })));
        }
        for (let i = 0; i < handles.length; i++) {
            const handle = handles[i];
            // hide aligned to camera
            handle.object.visible = true;
            handle.object.rotation.set(0, 0, 0);
            handle.object.position.copy(this._transformControls.worldPosition);
            let factor;
            if (this._transformControls.camera.isOrthographicCamera) {
                factor = (this._transformControls.camera.top - this._transformControls.camera.bottom) / this._transformControls.camera.zoom;
            }
            else {
                factor = this._transformControls.worldPosition.distanceTo(this._transformControls.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this._transformControls.camera.fov / 360) / this._transformControls.camera.zoom, 7);
            }
            handle.object.scale.set(1, 1, 1).multiplyScalar(factor * this._transformControls.size);
            // TODO: simplify helpers and consider decoupling from gizmo
            if (handle.object.tag === 'helper') {
                handle.object.visible = false;
                if (handle.object.name === 'AXIS') {
                    handle.object.visible = !!this._transformControls.axis;
                    if (this._transformControls.axis === 'X') {
                        _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
                        handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                        if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                            handle.object.visible = false;
                        }
                    }
                    if (this._transformControls.axis === 'Y') {
                        _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
                        handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                        if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                            handle.object.visible = false;
                        }
                    }
                    if (this._transformControls.axis === 'Z') {
                        _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
                        handle.object.quaternion.copy(quaternion).multiply(_tempQuaternion);
                        if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) > 0.9) {
                            handle.object.visible = false;
                        }
                    }
                    if (this._transformControls.axis === 'XYZE') {
                        _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
                        _alignVector.copy(this._transformControls.rotationAxis);
                        handle.object.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
                        handle.object.quaternion.multiply(_tempQuaternion);
                        handle.object.visible = this._transformControls.dragging;
                    }
                    if (this._transformControls.axis === 'E') {
                        handle.object.visible = false;
                    }
                }
                else if (handle.object.name === 'START') {
                    handle.object.position.copy(this._transformControls.worldPositionStart);
                    handle.object.visible = this._transformControls.dragging;
                }
                else if (handle.object.name === 'END') {
                    handle.object.position.copy(this._transformControls.worldPosition);
                    handle.object.visible = this._transformControls.dragging;
                }
                else if (handle.object.name === 'DELTA') {
                    handle.object.position.copy(this._transformControls.worldPositionStart);
                    handle.object.quaternion.copy(this._transformControls.worldQuaternionStart);
                    _tempVector.set(1e-10, 1e-10, 1e-10).add(this._transformControls.worldPositionStart).sub(this._transformControls.worldPosition).multiplyScalar(-1);
                    _tempVector.applyQuaternion(this._transformControls.worldQuaternionStart.clone().invert());
                    handle.object.scale.copy(_tempVector);
                    handle.object.visible = this._transformControls.dragging;
                }
                else {
                    handle.object.quaternion.copy(quaternion);
                    if (this._transformControls.dragging) {
                        handle.object.position.copy(this._transformControls.worldPositionStart);
                    }
                    else {
                        handle.object.position.copy(this._transformControls.worldPosition);
                    }
                    if (this._transformControls.axis) {
                        handle.object.visible = this._transformControls.axis.search(handle.object.name) !== -1;
                    }
                }
                // If updating helper, skip rest of the loop
                continue;
            }
            // Align handles to current local or world rotation
            handle.object.quaternion.copy(quaternion);
            if ((this._transformControls.enableTranslation && handle.mode === TransformationType.TRANSLATION) || (this._transformControls.enableScaling && handle.mode === TransformationType.SCALE)) {
                // Hide translate and scale axis facing the camera
                const AXIS_HIDE_THRESHOLD = 0.99;
                const PLANE_HIDE_THRESHOLD = 0.2;
                if (handle.object.name === 'X') {
                    if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
                if (handle.object.name === 'Y') {
                    if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
                if (handle.object.name === 'Z') {
                    if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) > AXIS_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
                if (handle.object.name === 'XY') {
                    if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
                if (handle.object.name === 'YZ') {
                    if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
                if (handle.object.name === 'XZ') {
                    if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this._transformControls.eye)) < PLANE_HIDE_THRESHOLD) {
                        handle.object.scale.set(1e-10, 1e-10, 1e-10);
                        handle.object.visible = false;
                    }
                }
            }
            if (this._transformControls.enableRotation) {
                // Align handle.objects to current local or world rotation
                _tempQuaternion2.copy(quaternion);
                _alignVector.copy(this._transformControls.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
                if (handle.object.name.search('E') !== -1) {
                    handle.object.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this._transformControls.eye, _zeroVector, _unitY));
                }
                if (handle.object.name === 'X') {
                    _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
                    handle.object.quaternion.copy(_tempQuaternion);
                }
                if (handle.object.name === 'Y') {
                    _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
                    handle.object.quaternion.copy(_tempQuaternion);
                }
                if (handle.object.name === 'Z') {
                    _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
                    handle.object.quaternion.copy(_tempQuaternion);
                }
            }
            // Hide disabled axes
            handle.object.visible = handle.object.visible && (handle.object.name.indexOf('X') === -1 || this._transformControls.showX);
            handle.object.visible = handle.object.visible && (handle.object.name.indexOf('Y') === -1 || this._transformControls.showY);
            handle.object.visible = handle.object.visible && (handle.object.name.indexOf('Z') === -1 || this._transformControls.showZ);
            handle.object.visible = handle.object.visible && (handle.object.name.indexOf('E') === -1 || (this._transformControls.showX && this._transformControls.showY && this._transformControls.showZ));
            // highlight selected axis
            if (!(handle.object.material instanceof three_1.MeshNormalMaterial)) {
                handle.object.material._color = handle.object.material._color || handle.object.material.color.clone();
                handle.object.material._opacity = handle.object.material._opacity || handle.object.material.opacity;
                handle.object.material.color.copy(handle.object.material._color);
                handle.object.material.opacity = handle.object.material._opacity;
                if (this._transformControls.enabled && this._transformControls.axis && handle.mode === this._transformControls.mode) {
                    if (handle.object.name === this._transformControls.axis) {
                        handle.object.material.color.setHex(0xffff00);
                        handle.object.material.opacity = 1.0;
                    }
                    else if (this._transformControls.axis.split('').some(function (a) {
                        return handle.object.name === a;
                    })) {
                        handle.object.material.color.setHex(0xffff00);
                        handle.object.material.opacity = 1.0;
                    }
                }
                else if (this._transformControls.enabled && this._transformControls.pivotDragged) {
                    handle.object.material.color.setHex(0xffff00);
                    handle.object.material.opacity = 1.0;
                }
            }
        }
        super.updateMatrixWorld(force);
    }
    // #endregion Public Methods (1)
    // #region Private Methods (1)
    filterOutAxis(pickers, gizmos, helpers, axis) {
        const pickersAxis = pickers.filter((object) => object.name.includes(axis));
        const gizmosAxis = gizmos.filter((object) => object.name.includes(axis));
        const helpersAxis = helpers.filter((object) => object.name.includes(axis));
        [pickersAxis, gizmosAxis, helpersAxis].forEach((objects) => {
            objects.forEach((object) => {
                object.visible = false;
            });
        });
        pickers = pickers.filter((object) => !object.name.includes(axis));
        gizmos = gizmos.filter((object) => !object.name.includes(axis));
        helpers = helpers.filter((object) => !object.name.includes(axis));
        return [pickers, gizmos, helpers];
    }
}
exports.TransformControlsGizmo = TransformControlsGizmo;
//
class TransformControlsPlane extends three_1.Mesh {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_transformControls) {
        super(new three_1.PlaneGeometry(100000, 100000, 2, 2), new three_1.MeshBasicMaterial({ visible: false, wireframe: true, side: three_1.DoubleSide, transparent: true, opacity: 0.1, toneMapped: false }));
        this._transformControls = _transformControls;
        this.isTransformControlsPlane = true;
        this.type = 'TransformControlsPlane';
    }
    // #endregion Constructors (1)
    // #region Public Methods (1)
    updateMatrixWorld(force) {
        const space = this._transformControls.space;
        this.position.copy(this._transformControls.worldPosition);
        _v1.copy(_unitX).applyQuaternion(space === 'local' ? this._transformControls.worldQuaternion : _identityQuaternion);
        _v2.copy(_unitY).applyQuaternion(space === 'local' ? this._transformControls.worldQuaternion : _identityQuaternion);
        _v3.copy(_unitZ).applyQuaternion(space === 'local' ? this._transformControls.worldQuaternion : _identityQuaternion);
        // Align the plane for current transform mode, axis and space.
        _alignVector.copy(_v2);
        if (this._transformControls.mode === TransformationType.TRANSLATION || this._transformControls.mode === TransformationType.SCALE) {
            switch (this._transformControls.axis) {
                case 'X':
                    _alignVector.copy(this._transformControls.eye).cross(_v1);
                    _dirVector.copy(_v1).cross(_alignVector);
                    break;
                case 'Y':
                    _alignVector.copy(this._transformControls.eye).cross(_v2);
                    _dirVector.copy(_v2).cross(_alignVector);
                    break;
                case 'Z':
                    _alignVector.copy(this._transformControls.eye).cross(_v3);
                    _dirVector.copy(_v3).cross(_alignVector);
                    break;
                case 'XY':
                    _dirVector.copy(_v3);
                    break;
                case 'YZ':
                    _dirVector.copy(_v1);
                    break;
                case 'XZ':
                    _alignVector.copy(_v3);
                    _dirVector.copy(_v2);
                    break;
                case 'XYZ':
                case 'E':
                    _dirVector.set(0, 0, 0);
                    break;
                default:
            }
        }
        if (this._transformControls.mode === TransformationType.ROTATION) {
            // special case for rotate
            _dirVector.set(0, 0, 0);
        }
        if (_dirVector.length() === 0) {
            // If in rotate mode, make the plane parallel to camera
            this.quaternion.copy(this._transformControls.cameraQuaternion);
        }
        else {
            _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
            this.quaternion.setFromRotationMatrix(_tempMatrix);
        }
        super.updateMatrixWorld(force);
    }
}
exports.TransformControlsPlane = TransformControlsPlane;
//# sourceMappingURL=TransformControls.js.map
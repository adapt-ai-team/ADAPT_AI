import { Camera, Intersection, Mesh, Object3D, Quaternion, Raycaster, Vector3 } from 'three';
declare enum TransformationType {
    TRANSLATION = "translation",
    ROTATION = "rotation",
    SCALE = "scale"
}
declare class TransformControls extends Object3D {
    private _axis;
    private _camera;
    private _cameraPosition;
    private _cameraQuaternion;
    private _cameraScale;
    private _dragging;
    private _enableRotation;
    private _enableRotationX;
    private _enableRotationY;
    private _enableRotationZ;
    private _enableScaling;
    private _enableScalingX;
    private _enableScalingY;
    private _enableScalingZ;
    private _enableTranslation;
    private _enableTranslationX;
    private _enableTranslationY;
    private _enableTranslationZ;
    private _enabled;
    private _endNorm;
    private _eye;
    private _gizmo;
    private _hovering;
    private _mode?;
    private _object;
    private _offset;
    private _parentPosition;
    private _parentQuaternion;
    private _parentQuaternionInv;
    private _parentScale;
    private _pivotDragged;
    private _plane;
    private _pointEnd;
    private _pointStart;
    private _positionStart;
    private _quaternionStart;
    private _rotationAngle;
    private _rotationAxis;
    private _rotationSnap;
    private _scaleSnap;
    private _scaleStart;
    private _showX;
    private _showY;
    private _showZ;
    private _size;
    private _space;
    private _startNorm;
    private _translationSnap;
    private _updateCallback;
    private _updateMatricesCallback;
    private _worldPosition;
    private _worldPositionStart;
    private _worldQuaternion;
    private _worldQuaternionInv;
    private _worldQuaternionStart;
    private _worldScale;
    private _worldScaleStart;
    domElement: HTMLElement;
    isTransformControls: boolean;
    constructor(camera: Camera, domElement?: HTMLElement, updateCallback?: () => void, updateMatricesCallback?: () => void);
    get axis(): string | null;
    set axis(value: string | null);
    get camera(): Camera;
    get cameraPosition(): Vector3;
    get cameraQuaternion(): Quaternion;
    get dragging(): boolean;
    set dragging(value: boolean);
    get enableRotation(): boolean;
    set enableRotation(value: boolean);
    get enableRotationX(): boolean;
    set enableRotationX(value: boolean);
    get enableRotationY(): boolean;
    set enableRotationY(value: boolean);
    get enableRotationZ(): boolean;
    set enableRotationZ(value: boolean);
    get enableScaling(): boolean;
    set enableScaling(value: boolean);
    get enableScalingX(): boolean;
    set enableScalingX(value: boolean);
    get enableScalingY(): boolean;
    set enableScalingY(value: boolean);
    get enableScalingZ(): boolean;
    set enableScalingZ(value: boolean);
    get enableTranslation(): boolean;
    set enableTranslation(value: boolean);
    get enableTranslationX(): boolean;
    set enableTranslationX(value: boolean);
    get enableTranslationY(): boolean;
    set enableTranslationY(value: boolean);
    get enableTranslationZ(): boolean;
    set enableTranslationZ(value: boolean);
    get enabled(): boolean;
    set enabled(value: boolean);
    get eye(): Vector3;
    get hovering(): boolean;
    get mode(): TransformationType | undefined;
    set mode(value: TransformationType | undefined);
    get object(): Object3D | undefined;
    set object(value: Object3D | undefined);
    get pivotDragged(): boolean;
    set pivotDragged(value: boolean);
    get pointEnd(): Vector3;
    get pointStart(): Vector3;
    get rotationAngle(): number;
    set rotationAngle(value: number);
    get rotationAxis(): Vector3;
    get rotationSnap(): number | null;
    set rotationSnap(value: number | null);
    get scaleSnap(): number | null;
    set scaleSnap(value: number | null);
    get showX(): boolean;
    set showX(value: boolean);
    get showY(): boolean;
    set showY(value: boolean);
    get showZ(): boolean;
    set showZ(value: boolean);
    get size(): number;
    set size(value: number);
    get space(): string;
    set space(value: string);
    get translationSnap(): number | null;
    set translationSnap(value: number | null);
    get worldPosition(): Vector3;
    get worldPositionStart(): Vector3;
    get worldQuaternion(): Quaternion;
    get worldQuaternionStart(): Quaternion;
    attach(object: Object3D): this;
    detach(): this;
    dispose(): void;
    getPointer(event: PointerEvent): {
        x: number;
        y: number;
        button: number;
    };
    getRaycaster(): Raycaster;
    intersectObjectWithRay(object: Object3D, raycaster: Raycaster, includeInvisible: boolean): false | Intersection<Object3D<import("three").Object3DEventMap>>;
    onPointerDown(event: PointerEvent): void;
    onPointerHover(event: PointerEvent): void;
    onPointerMove(event: PointerEvent): void;
    onPointerUp(event: PointerEvent): void;
    pointerDown(pointer: {
        x: number;
        y: number;
        button: any;
    }): void;
    pointerHover(pointer: {
        x: number;
        y: number;
        button: any;
    }): void;
    pointerMove(pointer: {
        x: number;
        y: number;
        button: any;
    }): void;
    pointerUp(pointer: {
        x: number;
        y: number;
        button: any;
    }): void;
    reset(): void;
    setRotationSnap(rotationSnap: number): void;
    setScaleSnap(scaleSnap: number): void;
    setSize(size: number): void;
    setSpace(space: string): void;
    setTranslationSnap(translationSnap: number): void;
    updateMatrixWorld(force?: boolean): void;
}
declare class TransformControlsGizmo extends Object3D {
    readonly _transformControls: TransformControls;
    gizmo: {
        translate: Object3D;
        rotate: Object3D;
        scale: Object3D;
    };
    helper: {
        translate: Object3D;
        rotate: Object3D;
        scale: Object3D;
    };
    isTransformControlsGizmo: true;
    picker: {
        translate: Object3D;
        rotate: Object3D;
        scale: Object3D;
    };
    type: 'TransformControlsGizmo';
    constructor(_transformControls: TransformControls);
    updateMatrixWorld(force: boolean): void;
    private filterOutAxis;
}
declare class TransformControlsPlane extends Mesh {
    readonly _transformControls: TransformControls;
    isTransformControlsPlane: true;
    type: 'TransformControlsPlane';
    constructor(_transformControls: TransformControls);
    updateMatrixWorld(force: boolean): void;
}
export { TransformControls, TransformControlsGizmo, TransformControlsPlane };
//# sourceMappingURL=TransformControls.d.ts.map